<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Acoustic & Vibration Properties of Plates - Debugged</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body { font-family: 'Segoe UI', Meiryo, sans-serif; margin: 0; padding: 10px; font-size: 14px; background-color: #f4f4f4; display: flex; flex-direction: column; gap: 15px; }
        .input-column, .output-column { display: flex; flex-direction: column; gap: 15px; width: 100%; }
        fieldset { border: 1px solid #ccc; border-radius: 5px; padding: 15px; background-color: #fff; margin: 0; }
        legend { font-weight: bold; padding: 0 5px; }
        .form-grid { display: grid; grid-template-columns: 140px 1fr 40px; align-items: center; gap: 8px; }
        .form-grid-condensed { display: grid; grid-template-columns: 140px 1fr; align-items: center; gap: 8px; }
        label { font-size: 14px; }
        input, select { width: 100%; padding: 8px; box-sizing: border-box; border: 1px solid #ccc; border-radius: 3px; }
        button.calc-btn-tab { width: auto; padding: 8px 20px; float: right; margin-top: 10px; background-color: #5cb85c; color: white; border-color: #4cae4c; border-radius: 4px; }
        .tabs { display: flex; flex-wrap: wrap; border-bottom: 1px solid #ccc; }
        .tab-button { padding: 10px 15px; cursor: pointer; background: #f1f1f1; border: 1px solid #ccc; border-bottom: none; border-radius: 5px 5px 0 0; margin-bottom: -1px; }
        .tab-button.active { background: #fff; border-bottom: 1px solid #fff; }
        .tab-content { display: none; padding: 15px; border: 1px solid #ccc; border-top: none; clear: both; }
        .tab-content.active { display: block; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: right; }
        th { background-color: #f2f2f2; text-align: center; }
        .chart-wrapper { position: relative; width: 100%; }
        .formula-container { margin-top: 20px; padding: 15px; background-color: #fafafa; border: 1px solid #eee; border-radius: 5px; font-size: 13px; }
        .formula-container h5 { margin-top: 0; margin-bottom: 10px; font-size: 1.1em; border-bottom: 1px solid #ddd; padding-bottom: 5px; }
        @media (min-width: 900px) {
            body { flex-direction: row; align-items: flex-start; }
            .input-column { width: 420px; min-width: 420px; }
            .output-column { flex-grow: 1; }
            .chart-wrapper { height: 400px; }
        }
    </style>
</head>
<body>
    <div class="input-column">
        <fieldset><legend>Common Input Conditions</legend>
            <div class="form-grid">
                <label for="material-select">Material:</label>
                <select id="material-select"></select><span></span>
                <label for="thick-input">Thickness (h):</label><input type="number" id="thick-input" value="12.0"><span>mm</span>
                <label for="lx-input">Length (Lx):</label><input type="number" id="lx-input" value="1000"><span>mm</span>
                <label for="ly-input">Width (Ly):</label><input type="number" id="ly-input" value="1000"><span>mm</span>
            </div>
        </fieldset>
        <fieldset><legend>Material Properties (Editable)</legend>
            <div class="form-grid">
                <label for="e-input">Young's Modulus (E):</label><input type="text" id="e-input"><span>Pa</span>
                <label for="rho-input">Density (ρ):</label><input type="text" id="rho-input"><span>kg/m³</span>
                <label for="nu-input">Poisson's Ratio (ν):</label><input type="text" id="nu-input"><span></span>
            </div>
        </fieldset>
        <fieldset><legend>Advanced Conditions</legend>
            <div class="form-grid-condensed">
                <label for="baffle-cond">Baffle Condition:</label>
                <select id="baffle-cond"><option value="1">In-plane</option><option value="2">Rigid</option></select>
            </div>
        </fieldset>
        <fieldset><legend>Driving-Point Impedance</legend>
            <div class="form-grid-condensed">
                <label>Position X (mm):</label><input type="number" id="pos-x" value="500">
                <label>Position Y (mm):</label><input type="number" id="pos-y" value="500">
            </div>
        </fieldset>
    </div>

    <div class="output-column">
        <div class="tabs">
            <button class="tab-button active" onclick="openTab(event, 'basic-tab')">Basic Properties</button>
            <button class="tab-button" onclick="openTab(event, 'natural-freq-tab')">Natural Frequencies</button>
            <button class="tab-button" onclick="openTab(event, 'impedance-tab')">Impedance</button>
            <button class="tab-button" onclick="openTab(event, 'stl-tab')">Sound Transmission Loss (STL)</button>
            <button class="tab-button" onclick="openTab(event, 'rad-tab')">Radiation Efficiency (σ)</button>
        </div>

        <div id="basic-tab" class="tab-content active">
            <table id="basic-results-table"></table>
            <div id="basic-formula" class="formula-container"></div>
            <button class="calc-btn-tab" onclick="calculateBasic()">Calculate</button>
        </div>

        <div id="natural-freq-tab" class="tab-content">
            <table id="natural-freq-table"></table>
            <div id="natural-freq-formula" class="formula-container"></div>
            <button class="calc-btn-tab" onclick="calculateNaturalFreq()">Calculate</button>
        </div>

        <div id="impedance-tab" class="tab-content">
            <div class="chart-wrapper"><canvas id="impedance-chart"></canvas></div>
            <div style="max-height: 200px; overflow-y: auto; margin-top: 10px;">
                <table id="impedance-table"></table>
            </div>
            <hr>
            <table id="inf-impedance-table"></table>
            <div id="impedance-formula" class="formula-container"></div>
            <button class="calc-btn-tab" onclick="calculateImpedance()">Calculate</button>
        </div>

        <div id="stl-tab" class="tab-content">
            <div class="chart-wrapper"><canvas id="stl-chart"></canvas></div>
            <div style="max-height: 200px; overflow-y: auto; margin-top: 10px;"><table id="stl-table"></table></div>
            <div id="stl-formula" class="formula-container"></div>
            <button class="calc-btn-tab" onclick="calculateSTL()">Calculate</button>
        </div>

        <div id="rad-tab" class="tab-content">
            <div class="chart-wrapper"><canvas id="rad-chart"></canvas></div>
            <div style="max-height: 200px; overflow-y: auto; margin-top: 10px;"><table id="rad-table"></table></div>
            <div id="rad-formula" class="formula-container"></div>
            <button class="calc-btn-tab" onclick="calculateRadiation()">Calculate</button>
        </div>
    </div>

<script>
/* ---------- constants / UI ---------- */
const MATERIAL_PROPERTIES = {
    "Custom": { "rho": 0, "E": 0, "nu": 0 },
    "Concrete": { "rho": 2.3e3, "E": 2.1e10, "nu": 0.005 },
    "Gypsum Board": { "rho": 0.8e3, "E": 0.18e10, "nu": 0.005 },
    "Plywood": { "rho": 0.6e3, "E": 0.5e10, "nu": 0.30 },
    "Glass": { "rho": 2500, "E": 70.0e9, "nu": 0.23 }
    // ... keep subset to shorten file; original list may be re-added
};

const FREQS = [16,20,25,31.5,40,50,63,80,100,125,160,200,250,315,400,500,630,800,1000,1250,1600,2000,2500,3150,4000,5000,6300,8000];
const THIRD_OCTAVE_TICKS = [16, 31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000];
let charts = {};
const ui = {
    materialSelect: document.getElementById('material-select'),
    thickInput: document.getElementById('thick-input'),
    lxInput: document.getElementById('lx-input'),
    lyInput: document.getElementById('ly-input'),
    etaInput: document.getElementById('eta-input'), // may be null — not used
    eInput: document.getElementById('e-input'),
    rhoInput: document.getElementById('rho-input'),
    nuInput: document.getElementById('nu-input'),
    baffleCond: document.getElementById('baffle-cond'),
    posX: document.getElementById('pos-x'),
    posY: document.getElementById('pos-y'),
    basicTable: document.getElementById('basic-results-table'),
    naturalFreqTable: document.getElementById('natural-freq-table'),
    infImpedanceTable: document.getElementById('inf-impedance-table'),
    impedanceTable: document.getElementById('impedance-table'),
    stlTable: document.getElementById('stl-table'),
    radTable: document.getElementById('rad-table'),
};

/* ---------- small Complex class ---------- */
class Complex {
    constructor(re=0, im=0) { this.re = re; this.im = im; }
    add(z) { return new Complex(this.re + z.re, this.im + z.im); }
    sub(z) { return new Complex(this.re - z.re, this.im - z.im); }
    mul(z) { return new Complex(this.re*z.re - this.im*z.im, this.re*z.im + this.im*z.re); }
    div(z) {
        const d = z.re*z.re + z.im*z.im;
        if (d === 0) return new Complex(Infinity, Infinity);
        return new Complex((this.re*z.re + this.im*z.im) / d, (this.im*z.re - this.re*z.im) / d);
    }
    get magnitude() { return Math.sqrt(this.re*this.re + this.im*this.im); }
    get phase() { return Math.atan2(this.im, this.re); }
    static i() { return new Complex(0, 1); }
}

/* ---------- init ---------- */
document.addEventListener('DOMContentLoaded', () => {
    for (const name in MATERIAL_PROPERTIES) ui.materialSelect.add(new Option(name, name));
    ui.materialSelect.value = "Gypsum Board";
    ui.materialSelect.addEventListener('change', onMaterialSelect);
    onMaterialSelect();
    calculateAllTabs();
});

/* ---------- overall calculation driver ---------- */
function calculateAllTabs() {
    try {
        calculateBasic();
        calculateNaturalFreq();
        calculateImpedance();
        calculateSTL();
        calculateRadiation();
    } catch (e) {
        alert(e.message);
    }
}

/* ---------- input handling ---------- */
function getCommonInputs() {
    const h = parseFloat(ui.thickInput.value) / 1000.0;
    const E = parseFloat(ui.eInput.value);
    const rho = parseFloat(ui.rhoInput.value);
    const nu = parseFloat(ui.nuInput.value);
    if (!(h > 0) || !(E > 0) || !(rho > 0)) throw new Error("Thickness, Young's Modulus, and Density must be positive.");
    const Lx = parseFloat(ui.lxInput.value) / 1000.0;
    const Ly = parseFloat(ui.lyInput.value) / 1000.0;
    if (!(Lx > 0) || !(Ly > 0)) throw new Error("Plate length and width must be positive.");
    const c0 = 343.0;
    const D = (E * Math.pow(h, 3)) / (12 * (1 - nu*nu));
    // critical frequency fc (same formula as before)
    const C_L_p = Math.sqrt(E / (rho * (1 - nu*nu))); // plate-longitudinal wave as in your basic block
    const fc = (c0*c0/(2*Math.PI*h)) * Math.sqrt(12 * rho * (1 - nu*nu) / E);
    return { h, E, rho, nu, Lx, Ly, c0, D, fc };
}

/* ---------- Basic / Natural freq ---------- */
function calculateBasic() {
    try {
        const { h, E, rho, nu, D, fc, Lx, Ly } = getCommonInputs();
        const C_L_p = Math.sqrt(E / (rho * (1 - nu*nu)));
        const S = Lx * Ly;
        const mode_density = (S * Math.sqrt(3)) / (h * C_L_p); // approximate constant modal density for plate
        createTable(ui.basicTable, ["Property", "Value", "Unit"], [
            ["Bending Stiffness (D)", D.toExponential(2), "N·m"],
            ["Critical Frequency (Fc)", fc.toFixed(2), "Hz"],
            ["Longitudinal Plate Wave Speed (C_L,p)", C_L_p.toFixed(2), "m/s"],
            ["Mode Density (n(f))", mode_density.toFixed(3), "modes/Hz"]
        ]);
        document.getElementById('basic-formula').innerHTML = `<h5>Equations for Basic Properties</h5>
            <p><b>Bending Stiffness (D):</b> $$ D = \\frac{E h^3}{12(1-\\nu^2)} $$</p>
            <p><b>Longitudinal Plate Wave Speed (c_{L,p}):</b> $$ c_{L,p} = \\sqrt{\\frac{E}{\\rho(1-\\nu^2)}} $$</p>
            <p><b>Critical Frequency (f_c):</b> $$ f_c = \\frac{c_0^2 \\sqrt{3}}{\\pi h c_{L,p}} $$</p>
            <p><b>Mode Density (n(f)):</b> $$ n(f) = \\frac{S \\sqrt{3}}{h c_{L,p}} $$</p>`;
        if (window.MathJax) MathJax.typeset();
    } catch (e) { alert(e.message); }
}

function calculateNaturalFreq() {
    try {
        const { rho, h, D, Lx, Ly } = getCommonInputs();
        let results = [];
        document.getElementById('natural-freq-formula').innerHTML = `<h5>Natural Frequencies (Simply Supported)</h5>
            <p>$$ f_{m,n} = \\frac{\\pi}{2} \\sqrt{\\frac{D}{\\rho h}} \\left( \\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2 \\right) $$</p>`;
        if (Lx > 0 && Ly > 0) {
            for (let m = 1; m <= 5; m++) {
                for (let n = 1; n <= 5; n++) {
                    const f_mn = (Math.PI / 2) * Math.sqrt(D / (rho * h)) * ((m / Lx)**2 + (n / Ly)**2);
                    results.push([`f(${m},${n})`, f_mn.toFixed(2)]);
                }
            }
        }
        createTable(ui.naturalFreqTable, ["Mode (m,n)", "Frequency (Hz)"], results);
        if (window.MathJax) MathJax.typeset();
    } catch (e) { alert(e.message); }
}

/* ---------- Impedance (fixed) ---------- */
function calculateImpedance() {
    try {
        const { E, rho, h, D, Lx, Ly, fc } = getCommonInputs();
        const posX = parseFloat(ui.posX.value) / 1000.0;
        const posY = parseFloat(ui.posY.value) / 1000.0;
        const S = Lx * Ly;
        const rho_s = rho * h;

        // reference infinite-plate impedance (original formula)
        const C_L = Math.sqrt(E / rho);
        const Z_inf_ref = 2.3 * rho * C_L * h * h;
        const Z_inf_ref_dB = (Z_inf_ref > 0) ? 20 * Math.log10(Z_inf_ref) : null;

        createTable(ui.infImpedanceTable, ["Property", "Value"], [
            ["Infinite Plate Impedance (Z_inf, ref)", `${Z_inf_ref.toExponential(2)} Ns/m³`]
        ]);

        // compute mobility via modal sum (simply supported plate)
        const results = { mag_dB: [], real: [], phase: [], modal_density: [] };
        const tableData = [];

        // modal density (as used earlier — approximately constant for plate)
        const C_L_p = Math.sqrt(E / (rho * (1 - Math.pow(parseFloat(ui.nuInput.value || 0.3), 2))));
        const modalDensity = (S * Math.sqrt(3)) / (h * C_L_p);

        for (const f of FREQS) {
            const omega = 2 * Math.PI * f;
            // frequency-dependent loss factor
            const eta_f = 0.005 + 0.3 / Math.sqrt(Math.max(1e-6, f));

            let Y_sum = new Complex(0,0);
            // modal summation: use correct natural frequency expression and modal mass normalization
            for (let p = 1; p <= 8; p++) { // increase to 8x8 for better representation; adjust if heavy
                for (let q = 1; q <= 8; q++) {
                    // correct modal frequency for simply-supported plate:
                    // f_pq = (pi/2) * sqrt(D / rho_s) * ( (p/Lx)^2 + (q/Ly)^2 )
                    const f_pq = (Math.PI / 2) * Math.sqrt(D / rho_s) * ((p / Lx)**2 + (q / Ly)**2);
                    const omega_pq = 2 * Math.PI * f_pq;

                    // point shape (non-normalized): sin( p*pi*x/Lx ) * sin( q*pi*y/Ly )
                    const psi = Math.sin(p * Math.PI * posX / Lx) * Math.sin(q * Math.PI * posY / Ly);
                    const psi_sq = psi * psi; // this is (phi)^2

                    // denominator = omega_pq^2(1 + i*eta) - omega^2
                    const denom = (new Complex(omega_pq*omega_pq, omega_pq*omega_pq * eta_f)).sub(new Complex(omega*omega, 0));

                    // add contribution: note normalization yields factor 4/(rho_s*S)
                    // so accumulate psi_sq / denom and multiply outside
                    Y_sum = Y_sum.add((new Complex(psi_sq, 0)).div(denom));
                }
            }

            // final point mobility: Y_dp = i * omega * (4 / (rho_s * S)) * Y_sum
            const prefactor = new Complex(4 * omega / (rho_s * S), 0);
            const Y_dp = Complex.i().mul(prefactor).mul(Y_sum);

            // convert to impedance:
            let Z_dp;
            if (Y_dp.re === Infinity || Y_dp.im === Infinity || (Y_dp.re === 0 && Y_dp.im === 0)) {
                Z_dp = new Complex(Infinity, Infinity);
            } else {
                Z_dp = (new Complex(1, 0)).div(Y_dp);
            }

            // magnitude (dB), real part, phase (deg). Handle zero/invalid gracefully.
            const magVal = (isFinite(Z_dp.magnitude) && Z_dp.magnitude > 0) ? 20 * Math.log10(Z_dp.magnitude) : null;
            const reVal  = isFinite(Z_dp.re) ? Z_dp.re : null;
            const phVal  = isFinite(Z_dp.phase) ? (Z_dp.phase * 180 / Math.PI) : null;

            results.mag_dB.push(magVal);
            results.real.push(reVal);
            results.phase.push(phVal);
            results.modal_density.push(modalDensity);

            tableData.push([
                f,
                magVal !== null ? magVal.toFixed(2) : 'NaN',
                reVal !== null ? reVal.toExponential(2) : 'NaN',
                phVal !== null ? phVal.toFixed(1) : 'NaN'
            ]);
        }

        // create datasets: magnitude (dB), Re(Z), Phase, Modal density, Z_inf_ref horizontal
        const datasets = [
            { label: '|Z| [dB re 1 Ns/m³]', data: results.mag_dB, yAxisID: 'y', borderColor: 'rgba(255,99,132,1)' },
            { label: 'Re(Z) [Ns/m³]',        data: results.real,  yAxisID: 'y1', borderColor: 'rgba(54,162,235,1)' },
            { label: 'Phase(Z) [deg]',      data: results.phase, yAxisID: 'y2', borderColor: 'rgba(255,206,86,1)' },
            { label: 'Modal density n(f)',  data: results.modal_density, yAxisID: 'yModal', borderColor: 'rgba(0,120,120,0.8)', borderDash: [5,3] }
        ];
        if (Z_inf_ref_dB !== null) {
            datasets.push({ label: 'Z_inf_ref [dB]', data: FREQS.map(() => Z_inf_ref_dB), yAxisID: 'y', borderColor: 'rgba(0,160,0,0.9)', borderDash: [6,3] });
        }

        // extra drawing: bands, fc vertical line, z_inf value
        const extra = { showBands: true, fc: fc, zInfDb: Z_inf_ref_dB };

        createPlot('impedance-chart', FREQS, datasets, 'Driving-Point Impedance (point)', '|Z| dB', {}, extra);

        createTable(ui.impedanceTable, ['Frequency (Hz)', '|Z| dB', 'Re(Z)', 'Phase (deg)'], tableData);

        document.getElementById('impedance-formula').innerHTML = `<h5>Driving-Point Impedance Equations (modal sum)</h5>
            <p><b>Mobility (Y<sub>dp</sub>):</b> $$ Y_{dp} = i\\omega \\frac{4}{\\rho_s S} \\sum_{p,q} \\frac{\\psi_{p,q}^2(x,y)}{\\omega_{p,q}^2(1+i\\eta)-\\omega^2} $$</p>
            <p><b>Impedance:</b> $$ Z_{dp} = 1 / Y_{dp} $$</p>`;
        if (window.MathJax) MathJax.typeset();

    } catch (e) { alert(e.message); }
}

/* ---------- STL (unchanged) ---------- */
function calculateSTL() {
    try {
        const { rho, h, fc } = getCommonInputs();
        const eta = 0.01;
        const m_dp = rho * h;
        const R_mass = FREQS.map(f => 20 * Math.log10(m_dp * f) - 42.5);
        const R_coincidence = R_mass.map((r, i) => {
            const f = FREQS[i], fr = f / fc;
            if (Math.abs(fr - 1) < 1e-6) return r;
            const c = (2 * eta) / (Math.PI * fr) * (1 / Math.pow(Math.abs(1 - fr * fr), 2));
            return r - 10 * Math.log10(Math.abs(c) + 1);
        });
        createPlot('stl-chart', FREQS, [
            { label: 'Mass Law (Normal Incidence)', data: R_mass },
            { label: 'With Coincidence Dip', data: R_coincidence }
        ], 'Sound Transmission Loss (STL)', 'STL (dB)');
        createTable(ui.stlTable, ['Frequency (Hz)', 'Mass Law (dB)', 'With Coincidence (dB)'], FREQS.map((f, i) => [f, R_mass[i].toFixed(1), R_coincidence[i].toFixed(1)]));
        document.getElementById('stl-formula').innerHTML = `<h5>Sound Transmission Loss Equations</h5><p><b>Surface Density (m''):</b> $$ m'' = \\rho h $$</p><p><b>Mass Law (Normal Incidence, TL_0):</b> $$ TL_0 = 20 \\log_{10}(m'' f) - 42.5 \\; (dB) $$</p>`;
        if (window.MathJax) MathJax.typeset();
    } catch (e) { alert(e.message); }
}

/* ---------- Radiation (unchanged) ---------- */
function calculateRadiation() {
    try {
        const { h, Lx, Ly, c0, fc } = getCommonInputs();
        const C_BC = 1; // simply supported
        const C_OB = parseFloat(ui.baffleCond.value);
        const l = 2 * (Lx + Ly), S = Lx * Ly, lambda_c = c0 / fc, L1 = Math.min(Lx, Ly), L2 = Math.max(Lx, Ly), k_fc = 2 * Math.PI * fc / c0;

        const sigma_simple = FREQS.map(f => {
            let s;
            if (f > fc) s = 1.0;
            else if (Math.abs(f - fc) < 1e-6) s = 0.45 * Math.sqrt(l / lambda_c);
            else s = (l * lambda_c / (Math.PI ** 2 * S)) * Math.sqrt(f / fc);
            return Math.max(1e-4, Math.min(s, 1.0));
        });

        const sigma_leppington = FREQS.map(f => {
            let s;
            const mu = Math.sqrt(fc / f);
            if (f > fc) s = 1 / Math.sqrt(1 - fc / f);
            else if (Math.abs(f - fc) < 1e-6) s = (0.5 - 0.15 * L1 / L2) * Math.sqrt(k_fc * Math.sqrt(L1));
            else {
                const k = 2 * Math.PI * f / c0;
                const mu2_1 = mu ** 2 - 1;
                if (mu2_1 <= 0 || k <= 0) return 1e-4;
                const term1 = l / (2 * Math.PI * k * S * Math.sqrt(mu2_1));
                const term2 = 2 * Math.atanh(1 / mu);
                const term3 = 2 * mu / mu2_1;
                const term4 = C_BC * C_OB - Math.pow(mu, -8) * (C_BC * C_OB - 1);
                s = term1 * (term2 + term3) * term4;
            }
            return Math.max(1e-4, Math.min(s, 1.0));
        });

        const sigma_wallace = FREQS.map(f => {
            const k = 2 * Math.PI * f / c0;
            let sigma_sum = 0;
            for (let p = 1; p <= 5; p++) {
                for (let q = 1; q <= 5; q++) {
                    let s_pq;
                    const p_odd = p % 2 !== 0, q_odd = q % 2 !== 0;
                    if (p_odd && q_odd) {
                        s_pq = (32 * k**2 * Lx * Ly / (Math.PI**5 * p**2 * q**2)) * (1 - (k**2 * Lx * Ly / 12) * ((1 - 8 / (p * Math.PI)**2) * Lx / Ly + (1 - 8 / (q * Math.PI)**2) * Ly / Lx));
                    } else if (p_odd !== q_odd) {
                        if (p_odd && !q_odd) {
                            s_pq = (8 * k**4 * Lx**3 * Ly / (3 * Math.PI**5 * p**2 * q**2)) * (1 - (k**2 * Lx * Ly / 20) * ((1 - 8 / (p * Math.PI)**2) * Lx / Ly + (1 - 24 / (q * Math.PI)**2) * Ly / Lx));
                        } else {
                            s_pq = (8 * k**4 * Ly**3 * Lx / (3 * Math.PI**5 * q**2 * p**2)) * (1 - (k**2 * Ly * Lx / 20) * ((1 - 8 / (q * Math.PI)**2) * Ly / Lx + (1 - 24 / (p * Math.PI)**2) * Lx / Ly));
                        }
                    } else {
                        s_pq = (2 * k**6 * Lx**3 * Ly**3 / (15 * Math.PI**5 * p**2 * q**2)) * (1 - (5 * k**2 * Lx**2 / 64) * ((1 - 24 / (p * Math.PI)**2) * Lx / Ly + (1 - 24 / (q * Math.PI)**2) * Ly / Lx));
                    }
                    sigma_sum += s_pq > 0 ? s_pq : 0;
                }
            }
            return Math.max(1e-4, Math.min(sigma_sum, 1.0));
        });

        createPlot('rad-chart', FREQS, [
            { label: 'Simple Model', data: sigma_simple },
            { label: 'Leppington', data: sigma_leppington },
            { label: 'Wallace (Modes Sum)', data: sigma_wallace }
        ], 'Radiation Efficiency (σ)', 'Coefficient (σ)', { min: 0, max: 1.1 });

        createTable(ui.radTable, ['Frequency (Hz)', 'σ (Simple)', 'σ (Leppington)', 'σ (Wallace)'], FREQS.map((f, i) => [f, sigma_simple[i].toFixed(3), sigma_leppington[i].toFixed(3), sigma_wallace[i].toExponential(2)]));

        document.getElementById('rad-formula').innerHTML = `<h5>Radiation Efficiency (σ) Equations</h5> ...`; // unchanged detailed text
        if (window.MathJax) MathJax.typeset();
    } catch (e) { alert(e.message); }
}

/* ---------- UI helpers ---------- */
function onMaterialSelect() {
    const selected = ui.materialSelect.value;
    const props = MATERIAL_PROPERTIES[selected];
    const isCustom = selected === "Custom";
    ui.eInput.value = isCustom ? "" : props.E.toExponential(2);
    ui.rhoInput.value = isCustom ? "" : props.rho;
    ui.nuInput.value = isCustom ? "" : props.nu;
    [ui.eInput, ui.rhoInput, ui.nuInput].forEach(i => { if (i) i.readOnly = false; });
}
function openTab(evt, name) {
    document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
    document.getElementById(name).classList.add('active');
    evt.currentTarget.classList.add('active');
}
function createTable(tableElement, headers, data) {
    if (!tableElement) return;
    tableElement.innerHTML = `<thead><tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr></thead>
        <tbody>${data.map(row => `<tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>`).join('')}</tbody>`;
}

/* ---------- Enhanced createPlot: supports bands, custom labels, multiple y axes ---------- */
function createPlot(chartId, labels, datasets, title, yAxisLabel = 'dB', yAxisOptions = {}, extra = {}) {
    const canvas = document.getElementById(chartId);
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    if (charts[chartId]) charts[chartId].destroy();

    // numeric labels array
    const numericLabels = labels.map(v => Number(v));

    // determine which y axes are required by datasets
    const axisIDs = new Set(datasets.map(ds => ds.yAxisID || 'y'));

    // build scales
    const scales = {};
    scales.x = {
        type: 'logarithmic',
        title: { display: true, text: 'Frequency (Hz)' },
        ticks: { display: false }, // we'll draw custom labels to ensure every 1/3-octave label appears
        min: Math.min(...numericLabels),
        max: Math.max(...numericLabels)
    };

    // default definitions for typical axes
    const defaultAxis = {
        y: () => ({ position: 'left', title: { display: true, text: yAxisLabel }, ...yAxisOptions }),
        y1: () => ({ position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: 'Re(Z)' } }),
        y2: () => ({ position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: 'Phase (deg)' }, offset: true }),
        yModal: () => ({ position: 'left', grid: { drawOnChartArea: false }, title: { display: true, text: 'Modal density' }, offset: true })
    };

    axisIDs.forEach(id => {
        scales[id] = (defaultAxis[id] ? defaultAxis[id]() : { position: 'right', grid: { drawOnChartArea: false }, title: { display: true, text: id } });
    });

    // plugin to draw shaded bands, custom labels, vertical fc and horizontal zInf line
    const bandPlugin = {
        id: 'bands_' + chartId,
        afterDraw(chart) {
            const ctx = chart.ctx;
            const xScale = chart.scales.x;
            if (!xScale) return;
            const area = chart.chartArea;
            // shaded 1/3-octave bands
            if (extra && extra.showBands) {
                const pow6 = Math.pow(2, 1/6);
                for (let i = 0; i < numericLabels.length; i++) {
                    const fc = numericLabels[i];
                    const fl = fc / pow6, fu = fc * pow6;
                    const x0 = xScale.getPixelForValue(fl);
                    const x1 = xScale.getPixelForValue(fu);
                    if (x1 <= area.left || x0 >= area.right) continue;
                    ctx.save();
                    ctx.fillStyle = (i % 2 === 0) ? 'rgba(200,200,200,0.04)' : 'rgba(180,180,180,0.02)';
                    const left = Math.max(x0, area.left);
                    const right = Math.min(x1, area.right);
                    ctx.fillRect(left, area.top, right - left, area.bottom - area.top);
                    ctx.restore();
                }
            }
            // custom center-frequency labels for every supplied frequency
            ctx.save();
            ctx.font = '11px Arial';
            ctx.fillStyle = '#222';
            ctx.textAlign = 'center';
            const yText = area.bottom + 14;
            for (const fc of numericLabels) {
                const x = xScale.getPixelForValue(fc);
                if (x < area.left - 10 || x > area.right + 10) continue;
                ctx.fillText(String(fc), x, yText);
            }
            ctx.restore();

            // vertical critical frequency line
            if (extra && extra.fc) {
                const xfc = xScale.getPixelForValue(extra.fc);
                if (xfc >= area.left && xfc <= area.right) {
                    ctx.save();
                    ctx.strokeStyle = extra.fcColor || 'rgba(60,60,60,0.9)';
                    ctx.setLineDash([4, 4]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(xfc, area.top);
                    ctx.lineTo(xfc, area.bottom);
                    ctx.stroke();
                    ctx.restore();
                }
            }

            // horizontal Z_inf_ref dB
            if (extra && typeof extra.zInfDb === 'number' && chart.scales.y) {
                const y = chart.scales.y.getPixelForValue(extra.zInfDb);
                if (y >= area.top && y <= area.bottom) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(0,140,0,0.9)';
                    ctx.setLineDash([6, 3]);
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(area.left, y);
                    ctx.lineTo(area.right, y);
                    ctx.stroke();
                    ctx.restore();
                }
            }
        }
    };

    const chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: numericLabels,
            datasets: datasets.map(ds => ({
                ...ds,
                fill: false,
                spanGaps: true,
                borderWidth: 2,
                pointRadius: 2,
                // ensure Chart.js treats values as numbers (null allowed)
                data: ds.data.map(v => (v === null ? null : Number.isFinite(v) ? v : null))
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                title: { display: true, text: title, font: { size: 16 } },
                legend: { position: 'top' }
            },
            scales: scales
        },
        plugins: [ bandPlugin ]
    });

    charts[chartId] = chart;
}

</script>
</body>
</html>
