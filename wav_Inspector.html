<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>WAV Inspector — Data Chunk & Device Metadata</title>
<style>
  :root{
    --bg:#f8fafc; --panel:#fff; --text:#0f172a; --muted:#475569;
    --accent:#2563eb; --ok:#10b981; --warn:#f59e0b; --bad:#ef4444; --chip:#e2e8f0;
    --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  } catch(e){ showErr(e); }
  *{box-sizing:border-box}
  body{margin:0;padding:24px;background:var(--bg);color:var(--text);
       font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo}
  h1{margin:0 0 16px;font-size:clamp(20px,2.4vw,30px)}
  h2{margin:18px 0 8px} h3{margin:8px 0}
  .grid{display:grid;gap:16px;grid-template-columns:repeat(12,minmax(0,1fr))}
  .card{grid-column:span 12;background:var(--panel);border:1px solid #e5e7eb;border-radius:16px;padding:16px;box-shadow:0 8px 24px rgba(15,23,42,.05)}
  @media(min-width:1024px){.span3{grid-column:span 3}.span4{grid-column:span 4}.span5{grid-column:span 5}.span6{grid-column:span 6}.span7{grid-column:span 7}.span8{grid-column:span 8}.span12{grid-column:span 12}}
  .drop{border:2px dashed #cbd5e1;background:#f1f5f9;border-radius:16px;padding:18px;text-align:center;cursor:pointer}
  .btn{background:var(--accent);color:#fff;border:none;padding:8px 12px;border-radius:10px;font-weight:600;cursor:pointer}
  .btn.secondary{background:#111827}
  .btn.ghost{background:#e2e8f0;color:#111827}
  .mono{font-family:var(--mono)} .muted{color:var(--muted)}
  .chip{display:inline-block;padding:2px 8px;border-radius:999px;background:var(--chip);font-family:var(--mono);font-size:12px;margin-right:4px}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{border-top:1px solid #e5e7eb;padding:8px 10px;vertical-align:top}
  th{text-align:left;background:#f8fafc}
  .kv{display:grid;grid-template-columns:220px 1fr;gap:8px}
  .controls{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
  .select,.number,.text{padding:8px 10px;border:1px solid #e5e7eb;border-radius:10px;background:#fff}
  canvas{width:100%;height:200px;border:1px solid #e5e7eb;border-radius:12px;background:#fff}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .bad{color:var(--bad)}
  details>summary{cursor:pointer}
  .bar{height:14px;background:#e2e8f0;border-radius:8px;position:relative;overflow:hidden}
  .bar .seg{position:absolute;top:0;bottom:0;background:#60a5fa}
  .kicker{font-size:12px;color:#64748b;margin-bottom:2px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  .hex{font-family:var(--mono);font-size:12px;background:#f1f5f9;border-radius:8px;padding:8px;overflow:auto}
  .right{float:right}
</style>
</head>
<body>
<h1>WAV Inspector — Data Chunk & Device Metadata</h1>
<div class="grid">

  <div class="card span6">
    <h2>1) ファイルを選択</h2>
    <div id="drop" class="drop">
      ここに WAV をドラッグ＆ドロップ、または
      <label class="btn" for="file">ファイルを選ぶ</label>
      <input id="file" type="file" accept=".wav,audio/wav" multiple style="display:none">
      <div class="muted" style="margin-top:6px">完全フロントエンド処理（アップロードしません）。複数選択でバッチ集計も可。</div>
    </div>
    <div id="fileInfo" class="muted" style="margin-top:8px"></div>
    <div id="err" class="mono" style="margin-top:6px;color:#ef4444"></div>
    <div class="row" style="margin-top:8px">
      <button id="exportJSON" class="btn" disabled>JSONエクスポート</button>
      <button id="exportCSV" class="btn secondary" disabled>CSVエクスポート</button>
    </div>
  </div>

  <div class="card span6">
    <h2>2) 概要</h2>
    <div id="summary" class="kv mono"></div>
  </div>

  <div class="card span4"><h2>RIFF ヘッダ</h2><table id="riffTbl"><tbody></tbody></table></div>
  <div class="card span4"><h2>fmt subchunk</h2><table id="fmtTbl"><tbody></tbody></table></div>
  <div class="card span4"><h2>data（Wave Data）</h2><table id="dataTbl"><tbody></tbody></table></div>

  <div class="card span6"><h2>TYPE subchunk</h2><table id="typeTbl"><tbody></tbody></table></div>
  <div class="card span6"><h2>Wave Settings（WSET）</h2><table id="wsetTbl"><tbody></tbody></table></div>

  <div class="card span6">
    <h2>装置情報</h2>
    <table id="deviceTbl"><tbody></tbody></table>
  </div>
  <div class="card span6">
    <h2>時刻情報</h2>
    <table id="timeTbl"><tbody></tbody></table>
    <div class="kicker">データ窓（プリトリガ含む）</div>
    <div class="bar"><div id="timeBarSeg" class="seg" style="left:0;width:0"></div></div>
  </div>

  <div class="card span12">
    <h2>共通設定（CSET）</h2>
    <div class="grid">
      <div class="span6">
        <h3 style="margin:0 0 6px">共通部</h3>
        <table id="csetCommon"><tbody></tbody></table>
      </div>
      <div class="span6">
        <h3 style="margin:0 0 6px">Chごとの設定</h3>
        <table id="csetCh">
          <thead><tr>
            <th>#</th><th>Name</th><th>Enabled</th><th>Measure</th><th>Sensor</th><th>Range (Vrms)</th>
            <th>Coupling</th><th>HPF</th><th>CCLD</th><th>Invert</th><th>Unit</th>
            <th>EU/bit</th><th>EU/V</th><th>Offset(EU)</th><th>0dB(EU)</th><th>Over</th>
          </tr></thead><tbody></tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="card span12">
    <h2>マーカー（対応チャンクがあれば）</h2>
    <table id="markerTbl">
      <thead><tr><th>Index</th><th>Position (frames)</th><th>Label</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="card span12">
    <h2>スキップしたチャンク</h2>
    <table id="skipTbl">
      <thead><tr><th>Index</th><th>Chunk ID</th><th>Size</th><th>Offset</th><th>ヘッダ(先頭64B)</th></tr></thead>
      <tbody></tbody>
    </table>
  </div>

  <div class="card span12">
    <h2>検証 (Validation)</h2>
    <ul id="validation" class="mono" style="margin:0;padding-left:20px"></ul>
  </div>

  <div class="card span12">
    <h2>3) 波形プレビュー（任意）</h2>
    <div class="controls" style="margin-bottom:8px">
      <label>描画モード:
        <select id="modeSelect" class="select">
          <option value="single">単一CH</option>
          <option value="grid">全CHグリッド</option>
        </select>
      </label>
      <label>チャンネル: <select id="chSelect" class="select"></select></label>
      <label>幅(px): <input id="plotWidth" type="number" class="number" value="1200" min="400" step="100"></label>
      <label>高さ(px): <input id="plotHeight" type="number" class="number" value="200" min="120" step="20"></label>
      <label>最初のNサンプル: <input id="firstN" type="number" class="number" value="16" min="1" step="1"></label>
    </div>
    <div class="controls">
      <label><input type="checkbox" id="euToggle"> EU換算（ValuePerBit/Offset適用）</label>
      <label><input type="checkbox" id="dbfsToggle"> dBFS 併記（整数PCMのみ）</label>
      <label>FS上書き: <input id="fsOverride" type="number" class="number" placeholder="自動" step="1"></label>
      <button id="drawBtn" class="btn" disabled>描画</button>
      <button id="drawAllBtn" class="btn ghost" disabled>全CH描画</button>
    </div>
    <div id="canvasWrap" style="margin-top:12px"></div>
    <details style="margin-top:8px">
      <summary>最初の N サンプル（選択CH）</summary>
      <pre id="firstSamples" class="mono" style="white-space:pre-wrap"></pre>
    </details>
  </div>

  <div class="card span12">
    <h2>バッチ集計（複数ファイル選択時）</h2>
    <table id="batchTbl">
      <thead><tr>
        <th>File</th><th>Fs [Hz]</th><th>Ch</th><th>Bits</th><th>Duration</th><th>Range</th><th>Device</th><th>Start</th>
      </tr></thead><tbody></tbody>
    </table>
  </div>

</div>

<script>
(() => {
  const el = (s)=>document.querySelector(s);
  const fmtNum = (n)=> n.toLocaleString('ja-JP');
  const toTime = (sec)=>{ if(!isFinite(sec))return '-'; const s=Math.floor(sec%60),m=Math.floor(sec/60)%60,h=Math.floor(sec/3600); const ms=Math.round((sec-Math.floor(sec))*1000); return (h? h+':':'')+String(m).padStart(2,'0')+':'+String(s).padStart(2,'0')+'.'+String(ms).padStart(3,'0') };
  const fourCC = (dv,o)=> String.fromCharCode(dv.getUint8(o), dv.getUint8(o+1), dv.getUint8(o+2), dv.getUint8(o+3));
  const readStr = (dv, off, len)=>{ let s=''; for(let i=0;i<len;i++){ const c=dv.getUint8(off+i); if(c===0) break; s+=String.fromCharCode(c); } return s.trim(); };
  const getI64 = (dv, off)=> Number(dv.getBigInt64(off, true));
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const hex2 = (n)=> n.toString(16).padStart(2,'0');
  const ver32 = (u32)=>{ const h=u32.toString(16).padStart(8,'0'); return `${h.slice(0,2)}.${h.slice(2,4)}.${h.slice(4,6)}${h.slice(6,8)}`; };

  function appendKV(tbody, k, v){ const tr=document.createElement('tr'); const th=document.createElement('th'); th.textContent=k; const td=document.createElement('td'); td.innerHTML=v; tr.appendChild(th); tr.appendChild(td); tbody.appendChild(tr); }
  function setTable(tbody, rows){ tbody.innerHTML=''; rows.forEach(r=>appendKV(tbody, r[0], r[1])); }

  // ====== ENUM MAPS ======
  const RANGE_CODE = {3:'100 Hz',5:'500 Hz',6:'1 kHz',8:'5 kHz',9:'10 kHz',10:'20 kHz'};
  const RATIO_CODE = {1:'×2.56'};
  const SENSOR_CODE = {2:'Mic',3:'Piezo Accel.',4:'Sound Level Meter',6:'Vibration Level Meter',20:'Other (AC)',21:'Other (DC)'};
  const COUPLING = {0:'AC',1:'DC'};
  const HPF = {0:'OFF',4:'1 Hz',12:'10 Hz'};
  const TRIG_MODE = {0:'Free',1:'Single',2:'Repeat'};
  const TRIG_SOURCE = {4:'External',16:'Time Waveform',512:'Timer'};
  const TACHO = {0:'OFF',2:'ON'};
  const INPUT_RANGE = {2:'0.01 V (−40 dB)',4:'0.1 V (−20 dB)',6:'1 V (0 dB)',8:'10 V (+20 dB)'};

  // ====== Parsers ======
  function parseTYPE(dv, off){
    const csize=dv.getUint32(off+4,true); const dataOff=off+8;
    return {id:'TYPE', size:csize, dataOffset:dataOff, fileType: readStr(dv,dataOff,8), fileRev: dv.getUint16(dataOff+8,true)};
  } catch(e){ showErr(e); }
  function parseWSET(dv, off){
    const csize=dv.getUint32(off+4,true); const dataOff=off+8;
    return {id:'WSET', size:csize, dataOffset:dataOff, pretime: dv.getInt16(dataOff+2, true)};
  } catch(e){ showErr(e); }
  function parseCSET(dv, off){
    const csize=dv.getUint32(off+4,true); const dataOff=off+8; let p=dataOff;
    const common={};
    common.productType = readStr(dv,p,12); p+=12;
    common.repeatSerial = dv.getUint16(p,true); p+=2;
    common.fileSerial   = dv.getUint16(p,true); p+=2;
    common.startTimeMs  = getI64(dv,p); p+=8;
    common.actualRecordTimeMs = getI64(dv,p); p+=8;
    common.unitEquippedCh = dv.getUint16(p,true); p+=2;
    common.totalEnabledCh = dv.getUint16(p,true); p+=2;
    p+=2; // reserved
    common.unitId     = dv.getUint16(p,true); p+=2;
    common.unitName   = readStr(dv,p,40); p+=40;
    common.unitType   = readStr(dv,p,8);  p+=8;
    common.unitSerial = readStr(dv,p,16); p+=16;
    common.unitCpuVer = dv.getUint32(p,true); p+=4;
    common.unitDspVer = dv.getUint32(p,true); p+=4;
    common.unitCpldVer= dv.getUint32(p,true); p+=4;
    common.unitSubMiconVer = dv.getUint32(p,true); p+=4;
    common.triggerMode   = dv.getInt16(p,true); p+=2;
    common.triggerSource = dv.getInt16(p,true); p+=2;
    common.triggerChannel= dv.getInt16(p,true); p+=2;
    common.triggerLevelWave = dv.getInt32(p,true); p+=4;
    p+=2; p+=4; // reserved
    common.triggerSlope = dv.getInt16(p,true); p+=2;
    common.triggerStartDateTime = getI64(dv,p); p+=8;
    common.triggerStopDateTime  = getI64(dv,p+8); p+=8;
    p+=16;
    common.triggerIntervalSec = dv.getInt32(p,true); p+=4;
    common.measureFreqRangeCode = dv.getInt16(p,true); p+=2;
    common.measureFreqRatioCode = dv.getInt16(p,true); p+=2;
    common.tachoCodecMode = dv.getInt16(p,true); p+=2;
    p+=24; // reserved

    const chBlockSize=114;
    const remain=csize-(p-dataOff);
    const nCh=Math.max(0, Math.floor(remain/chBlockSize));
    const channels=[];
    for(let i=0;i<nCh;i++){
      let q=p+i*chBlockSize;
      const ch={};
      ch.name = readStr(dv,q,40); q+=40;
      ch.number = dv.getInt16(q,true); q+=2;
      ch.enabled = !!dv.getInt16(q+2,true); q+=4;
      ch.measureEnabled = !!dv.getInt16(q,true); q+=2;
      ch.sensorType = dv.getInt16(q+2,true); q+=4;
      ch.sensorRangeCode = dv.getInt16(q,true); q+=2;
      ch.coupling = dv.getInt16(q+2,true); q+=4;
      ch.ccld = !!dv.getInt16(q,true); q+=2;
      ch.inversion = !!dv.getInt16(q+2,true); q+=4;
      ch.hpfCutoff = dv.getInt16(q,true); q+=2;
      q+=2; // reserved
      ch.unit = readStr(dv,q,8); q+=8;
      ch.valuePerBit = dv.getFloat64(q,true); q+=8;
      ch.valuePerVolt = dv.getFloat64(q,true); q+=8;
      ch.offsetValue  = dv.getFloat64(q,true); q+=8;
      ch.zeroDbEU     = dv.getFloat64(q,true); q+=8;
      ch.overload     = dv.getUint16(q,true); q+=2;
      q+=2; q+=10; // reserved
      channels.push(ch);
    } catch(e){ showErr(e); }
    return {id:'CSET', size:csize, dataOffset:dataOff, common, channels};
  } catch(e){ showErr(e); }
  function parseCUE(dv, off){
    // 'cue ' chunk: ref: RIFF spec
    const size=dv.getUint32(off+4,true); const dataOff=off+8;
    const num=dv.getUint32(dataOff,true);
    const points=[]; let p=dataOff+4;
    for(let i=0;i<num;i++){
      const id=dv.getUint32(p,true); const pos=dv.getUint32(p+4,true);
      // skip rest 16 bytes (chunk ID etc.)
      p+=24;
      points.push({id, position:pos});
    } catch(e){ showErr(e); }
    return {id:'cue ', size, dataOffset:dataOff, points};
  } catch(e){ showErr(e); }
  function parseLIST_ADTL(dv, off){
    const size=dv.getUint32(off+4,true); const dataOff=off+8;
    const listType = fourCC(dv,dataOff);
    const items=[];
    if(listType!=='adtl') return {id:'LIST', size, dataOffset:dataOff, items};
    let p=dataOff+4;
    while(p+8 <= off+8+size){
      const subId=fourCC(dv,p); const subSize=dv.getUint32(p+4,true); const subOff=p+8;
      if(subId==='labl' || subId==='note'){
        const cuePointId=dv.getUint32(subOff,true);
        const txt=readStr(dv, subOff+4, subSize-4);
        items.push({type:subId, cuePointId, text:txt});
      } catch(e){ showErr(e); }
      p = subOff + subSize + (subSize%2);
    } catch(e){ showErr(e); }
    return {id:'LIST', size, dataOffset:dataOff, items};
  } catch(e){ showErr(e); }

  function parseWav(buf){
    const dv=new DataView(buf); const bytes=dv.byteLength;
    const header={riff:fourCC(dv,0), size:dv.getUint32(4,true), wave:fourCC(dv,8)};
    let off=12;
    const skipped=[]; let fmt=null, data=null, type=null, wset=null, cset=null, cue=null, adtl=null;
    while(off+8<=bytes){
      const id=fourCC(dv,off); const size=dv.getUint32(off+4,true); const dataOffset=off+8;
      if(id==='fmt '){
        const wFormatTag=dv.getUint16(dataOffset,true), nChannels=dv.getUint16(dataOffset+2,true);
        const nSamplesPerSec=dv.getUint32(dataOffset+4,true), nAvgBytesPerSec=dv.getUint32(dataOffset+8,true);
        const nBlockAlign=dv.getUint16(dataOffset+12,true), wBitsPerSample=dv.getUint16(dataOffset+14,true);
        fmt={id,size,dataOffset,wFormatTag,nChannels,nSamplesPerSec,nAvgBytesPerSec,nBlockAlign,wBitsPerSample};
      } catch(e){ showErr(e); }else if(id==='data'){
        data={id,size,dataOffset};
      } catch(e){ showErr(e); }else if(id==='TYPE'){ type=parseTYPE(dv,off);
      } catch(e){ showErr(e); }else if(id==='WSET'){ wset=parseWSET(dv,off);
      } catch(e){ showErr(e); }else if(id==='CSET'){ cset=parseCSET(dv,off);
      } catch(e){ showErr(e); }else if(id==='cue '){ cue=parseCUE(dv,off);
      } catch(e){ showErr(e); }else if(id==='LIST'){ adtl=parseLIST_ADTL(dv,off);
      } catch(e){ showErr(e); }else{
        skipped.push({id,size,dataOffset, head:Array.from(new Uint8Array(dv.buffer, dataOffset, Math.min(64, size)))});
      } catch(e){ showErr(e); }
      off = dataOffset + size + (size%2);
    } catch(e){ showErr(e); }
    return {header, fmt, data, type, wset, cset, cue, adtl, skipped, dv};
  } catch(e){ showErr(e); }

  // ====== Waveform / EU & dBFS ======
  function pcmIntToFloat(val, bits, fsOverride){
    const full = fsOverride>0 ? fsOverride : Math.pow(2, bits-1);
    return val / full;
  } catch(e){ showErr(e); }
  function valToEU(v, chMeta){
    // EU = v * valuePerBit + offsetValue (v is integer sample count for PCM, float value for IEEE? -> for float WAV, EU換算非適用)
    return v * (chMeta?.valuePerBit ?? 1) + (chMeta?.offsetValue ?? 0);
    // valuePerVolt/zeroDbEU は用途に応じて別の換算に使用
  } catch(e){ showErr(e); }
  function toDbFS(v, bits, fsOverride){
    const full = fsOverride>0 ? fsOverride : Math.pow(2, bits-1);
    const x = Math.abs(v) / full;
    return (x>0) ? (20*Math.log10(x)) : -Infinity;
  } catch(e){ showErr(e); }
  function drawWaveform(parsed,{channelIndex=0,width=1200,height=200, eu=false, dbfs=false, fsOverride=0}){
    const {dv,data,fmt,cset}=parsed;
    const canvas=document.createElement('canvas'); canvas.width=width; canvas.height=height;
    const ctx=canvas.getContext('2d'); ctx.fillStyle='#fff'; ctx.fillRect(0,0,width,height);
    ctx.strokeStyle='#334155'; ctx.lineWidth=1;
    const mid=height/2; ctx.beginPath(); ctx.moveTo(0,mid); ctx.lineTo(width,mid); ctx.stroke();

    const bytesPerSample=fmt.wBitsPerSample/8, blockAlign=fmt.nBlockAlign, frames=Math.floor(data.size/blockAlign);
    const fmtTag=fmt.wFormatTag, samplesPerPx=Math.max(1,Math.floor(frames/width)); const ch=channelIndex;
    const bits=fmt.wBitsPerSample;
    const chMeta = cset?.channels?.[ch] || null;

    let frame=0;
    for(let x=0;x<width;x++){
      let sMin=1e9,sMax=-1e9;
      for(let i=0;i<samplesPerPx && frame<frames;i++,frame++){
        const off=data.dataOffset + frame*blockAlign + ch*bytesPerSample;
        let v=0;
        if(fmtTag===0x0001){
          if(bytesPerSample===1) v = dv.getInt8(off);
          else if(bytesPerSample===2) v = dv.getInt16(off,true);
          else if(bytesPerSample===3){ const b0=dv.getUint8(off),b1=dv.getUint8(off+1),b2=dv.getUint8(off+2); let val=(b2<<16)|(b1<<8)|b0; if(val&0x800000) val|=0xff000000; v=val; }
          else if(bytesPerSample===4) v = dv.getInt32(off,true);
          if (eu){ v = valToEU(v, chMeta); }
          else if (dbfs){ v = pcmIntToFloat(v, bits, fsOverride); }
          else { v = pcmIntToFloat(v, bits, fsOverride); } // normalize to ±1 for drawing
        } catch(e){ showErr(e); }else if(fmtTag===0x0003){
          v = (bytesPerSample===4) ? dv.getFloat32(off,true) : (bytesPerSample===8? dv.getFloat64(off,true) : 0);
          // For float WAV, EU変換は未適用（係数が整数カウント基準でないため）。描画は±1想定でスケーリング。
        } catch(e){ showErr(e); }
        if(v<sMin) sMin=v; if(v>sMax) sMax=v;
      } catch(e){ showErr(e); }
      const y1=mid - sMax*(height*0.48), y2=mid - sMin*(height*0.48);
      ctx.beginPath(); ctx.moveTo(x,y1); ctx.lineTo(x,y2); ctx.stroke();
    } catch(e){ showErr(e); }
    return canvas;
  } catch(e){ showErr(e); }
  function extractSamples(parsed, ch, N, eu=false, dbfs=false, fsOverride=0){
    const {dv,data,fmt,cset}=parsed;
    const bytesPerSample=fmt.wBitsPerSample/8, blockAlign=fmt.nBlockAlign, frames=Math.floor(data.size/blockAlign), fmtTag=fmt.wFormatTag, bits=fmt.wBitsPerSample;
    const len=Math.min(N,frames), out=[]; const chMeta=cset?.channels?.[ch]||null;
    for(let i=0;i<len;i++){
      const off=data.dataOffset + i*blockAlign + ch*bytesPerSample;
      let raw=0;
      if(fmtTag===0x0001){
        if(bytesPerSample===1) raw=dv.getInt8(off);
        else if(bytesPerSample===2) raw=dv.getInt16(off,true);
        else if(bytesPerSample===3){ const b0=dv.getUint8(off),b1=dv.getUint8(off+1),b2=dv.getUint8(off+2); let val=(b2<<16)|(b1<<8)|b0; if(val&0x800000) val|=0xff000000; raw=val; }
        else if(bytesPerSample===4) raw=dv.getInt32(off,true);
        const norm = pcmIntToFloat(raw, bits, fsOverride);
        const euv = eu ? valToEU(raw, chMeta) : null;
        const db = dbfs ? toDbFS(raw, bits, fsOverride) : null;
        out.push({raw, norm, eu:euv, dbfs:db});
      } catch(e){ showErr(e); }else if(fmtTag===0x0003){
        const val = (bytesPerSample===4) ? dv.getFloat32(off,true) : (bytesPerSample===8? dv.getFloat64(off,true) : 0);
        out.push({raw:val, norm:val, eu:null, dbfs:null});
      } catch(e){ showErr(e); }
    } catch(e){ showErr(e); }
    return out;
  } catch(e){ showErr(e); }

  // ====== UI elements ======
  const riffTbl=el('#riffTbl tbody'), fmtTbl=el('#fmtTbl tbody'), dataTbl=el('#dataTbl tbody');
  const typeTbl=el('#typeTbl tbody'), wsetTbl=el('#wsetTbl tbody');
  const deviceTbl=el('#deviceTbl tbody'), timeTbl=el('#timeTbl tbody'), timeSeg=el('#timeBarSeg');
  const csetCommon=el('#csetCommon tbody'), csetCh=el('#csetCh tbody');
  const markerTbl=el('#markerTbl tbody'), skipTbl=el('#skipTbl tbody');
  const summary=el('#summary'), validation=el('#validation'); const fileInfo=el('#fileInfo');
  const chSelect=el('#chSelect'), drawBtn=el('#drawBtn'), drawAllBtn=el('#drawAllBtn'), canvasWrap=el('#canvasWrap'), firstSamplesPre=el('#firstSamples');
  const fileInput=el('#file'), drop=el('#drop'), plotWidth=el('#plotWidth'), plotHeight=el('#plotHeight'), modeSelect=el('#modeSelect');
  const firstN=el('#firstN'), euToggle=el('#euToggle'), dbfsToggle=el('#dbfsToggle'), fsOverride=el('#fsOverride');
  const exportJSON=el('#exportJSON'), exportCSV=el('#exportCSV'), batchTbl=el('#batchTbl tbody');
  let parsed=null; let parsedBatch=[]; let currentFileName='';

  function friendly(map, code){ return (code in map)? map[code] : `Unknown (code ${code})`; }

  function renderAll(p){
    // RIFF / fmt / data
    setTable(riffTbl,[
      ['Chunk ID', `<span class="mono">${p.header.riff}</span>`],
      ['Chunk Size', `${fmtNum(p.header.size)} bytes`],
      ['riffType', `<span class="mono">${p.header.wave}</span>`],
    ]);
    if(p.fmt){
      const f=p.fmt;
      setTable(fmtTbl,[
        ['Chunk ID', `<span class="mono">${f.id}</span>`],
        ['Chunk Size', `${fmtNum(f.size)} bytes`],
        ['Offset', fmtNum(f.dataOffset)],
        ['wFormatTag', `0x${f.wFormatTag.toString(16).padStart(4,'0')} ${f.wFormatTag===1?'(PCM)':(f.wFormatTag===3?'(IEEE float)':'')}`],
        ['nChannels', fmtNum(f.nChannels)],
        ['nSamplesPerSec', `${fmtNum(f.nSamplesPerSec)} Hz`],
        ['nAvgBytesPerSec', fmtNum(f.nAvgBytesPerSec)],
        ['nBlockAlign', fmtNum(f.nBlockAlign)],
        ['wBitsPerSample', `${fmtNum(f.wBitsPerSample)} bit`],
      ]);
    } catch(e){ showErr(e); } else setTable(fmtTbl,[['エラー','<span class="bad">fmt が見つかりません</span>']]);

    if(p.data){
      const f=p.fmt, d=p.data; const frames=f?Math.floor(d.size/f.nBlockAlign):0; const dur=f?frames/f.nSamplesPerSec:NaN;
      setTable(dataTbl,[
        ['Chunk ID', `<span class="mono">${d.id}</span>`],
        ['Chunk Size', `${fmtNum(d.size)} bytes`],
        ['Offset', fmtNum(d.dataOffset)],
        ['推定フレーム数', fmtNum(frames)],
        ['推定デュレーション', `${toTime(dur)} ${f? '('+f.nSamplesPerSec+' Hz)':''}`],
        ['チャンネル数', f?fmtNum(f.nChannels):'Unknown'],
        ['量子化', f? `${f.wBitsPerSample} bit`:'Unknown'],
      ]);
    } catch(e){ showErr(e); } else setTable(dataTbl,[['エラー','<span class="bad">data が見つかりません</span>']]);

    // TYPE / WSET
    if(p.type){
      const t=p.type;
      setTable(typeTbl,[
        ['Chunk ID', `<span class="mono">${t.id}</span>`],
        ['Chunk Size', `${fmtNum(t.size)} bytes`],
        ['File Type', `<span class="mono">${t.fileType}</span>`],
        ['File Revision', `${fmtNum(t.fileRev)} <span class="chip">0x${t.fileRev.toString(16)}</span>`],
      ]);
    } catch(e){ showErr(e); } else setTable(typeTbl,[['情報','TYPE は見つかりません']]);
    if(p.wset){
      const w=p.wset;
      setTable(wsetTbl,[
        ['Chunk ID', `<span class="mono">${w.id}</span>`],
        ['Chunk Size', `${fmtNum(w.size)} bytes`],
        ['プリトリガ秒 (Pre-time)', `${w.pretime} s（0 / -1 / -5 等）`],
      ]);
    } catch(e){ showErr(e); } else setTable(wsetTbl,[['情報','WSET は見つかりません']]);

    // Device info
    deviceTbl.innerHTML='';
    if(p.cset){
      const c=p.cset.common;
      setTable(deviceTbl,[
        ['Unit Name', `<span class="mono">${c.unitName}</span>`],
        ['Unit Type', `<span class="mono">${c.unitType}</span>`],
        ['Unit Serial', `<span class="mono">${c.unitSerial}</span>`],
        ['CPU/DSP/CPLD/Sub', `${ver32(c.unitCpuVer)} / ${ver32(c.unitDspVer)} / ${ver32(c.unitCpldVer)} / ${ver32(c.unitSubMiconVer)}`],
        ['Equipped / Enabled CH', `${fmtNum(c.unitEquippedCh)} / ${fmtNum(c.totalEnabledCh)}`],
        ['Product Type', `<span class="mono">${c.productType}</span>`],
      ]);
    } catch(e){ showErr(e); } else setTable(deviceTbl,[['情報','CSET 未検出のため装置情報は表示できません']]);

    // Time info + bar
    timeTbl.innerHTML='';
    let startMs=null, actualMs=null, pre=0;
    if(p.cset){
      const c=p.cset.common;
      startMs=c.startTimeMs; actualMs=c.actualRecordTimeMs;
      const startLocal = new Date(c.startTimeMs);
      const startISO = new Date(c.startTimeMs).toISOString();
      const tStart = c.triggerStartDateTime ? new Date(c.triggerStartDateTime) : null;
      const tStop  = c.triggerStopDateTime ? new Date(c.triggerStopDateTime) : null;
      setTable(timeTbl,[
        ['録音開始 (Local / ISO)', `${startLocal.toLocaleString()}<br><span class="mono">${startISO}</span>`],
        ['実記録時間', `${fmtNum(c.actualRecordTimeMs)} ms (${toTime(c.actualRecordTimeMs/1000)})`],
        ['Trigger Start', tStart? tStart.toLocaleString() : '—'],
        ['Trigger Stop', tStop? tStop.toLocaleString() : '—'],
        ['Trigger Interval (s)', fmtNum(c.triggerIntervalSec)],
      ]);
    } catch(e){ showErr(e); } else {
      setTable(timeTbl,[['情報','CSET 未検出のため時刻情報は表示できません']]);
    } catch(e){ showErr(e); }
    if(p.wset) pre = p.wset.pretime||0;
    // draw time bar segment: pre (if negative) indicates pre-trigger window before 0
    const durSec = (p.fmt && p.data) ? Math.floor(p.data.size/p.fmt.nBlockAlign)/p.fmt.nSamplesPerSec : 0;
    const totalSec = durSec + Math.max(0, -pre);
    const leftPct = totalSec>0 ? (Math.max(0, -pre)/totalSec)*100 : 0;
    const widthPct= totalSec>0 ? (durSec/totalSec)*100 : 0;
    timeSeg.style.left = leftPct+'%'; timeSeg.style.width = widthPct+'%';

    // CSET tables
    csetCommon.innerHTML=''; csetCh.innerHTML='';
    if(p.cset){
      const c=p.cset.common;
      const rangeStr = friendly(RANGE_CODE, c.measureFreqRangeCode);
      const ratioStr = friendly(RATIO_CODE, c.measureFreqRatioCode);
      setTable(csetCommon,[
        ['Measure Frequency Range', `${rangeStr}`],
        ['Measure Frequency Ratio', `${ratioStr}`],
        ['Tacho Codec', friendly(TACHO, c.tachoCodecMode)],
        ['Trigger Mode / Source / Ch', `${friendly(TRIG_MODE,c.triggerMode)} / ${friendly(TRIG_SOURCE,c.triggerSource)} / ${fmtNum(c.triggerChannel)}`],
        ['Trigger Level (Wave) / Slope', `${fmtNum(c.triggerLevelWave)} / ${(c.triggerSlope===0?'+(立上り)':(c.triggerSlope===1?'−(立下り)':'Unknown ('+c.triggerSlope+')'))}`],
        ['CSET Size / Offset', `${fmtNum(p.cset.size)} bytes / ${fmtNum(p.cset.dataOffset)}`],
      ]);
      p.cset.channels.forEach((ch,i)=>{
        const tr=document.createElement('tr');
        tr.innerHTML = `<td>${fmtNum(ch.number||i+1)}</td>
                        <td class="mono">${ch.name||''}</td>
                        <td>${ch.enabled?'true':'false'}</td>
                        <td>${ch.measureEnabled?'true':'false'}</td>
                        <td>${friendly(SENSOR_CODE, ch.sensorType)}</td>
                        <td>${friendly(INPUT_RANGE, ch.sensorRangeCode)}</td>
                        <td>${friendly(COUPLING, ch.coupling)}</td>
                        <td>${friendly(HPF, ch.hpfCutoff)}</td>
                        <td>${ch.ccld?'ON':'OFF'}</td>
                        <td>${ch.inversion?'true':'false'}</td>
                        <td class="mono">${ch.unit}</td>
                        <td class="mono">${(typeof ch.valuePerBit==="number" ? ch.valuePerBit.toExponential(3) : (ch.valuePerBit??""))}</td>
                        <td class="mono">${(typeof ch.valuePerVolt==="number" ? ch.valuePerVolt.toExponential(3) : (ch.valuePerVolt??""))}</td>
                        <td class="mono">${ch.offsetValue}</td>
                        <td class="mono">${ch.zeroDbEU}</td>
                        <td>${ch.overload? 'あり':'なし'}</td>`;
        csetCh.appendChild(tr);
      } catch(e){ showErr(e); });
    } catch(e){ showErr(e); } else {
      csetCommon.innerHTML='<tr><td>情報</td><td>CSET は見つかりません</td></tr>';
    } catch(e){ showErr(e); }

    // Markers
    markerTbl.innerHTML='';
    if(p.cue){
      const labels = {};
      if(p.adtl){ p.adtl.items.forEach(it=>{ if(it.type==='labl'||it.type==='note') labels[it.cuePointId]=it.text; }); }
      p.cue.points.forEach((pt,i)=>{
        const tr=document.createElement('tr');
        tr.innerHTML = `<td>${i+1}</td><td>${fmtNum(pt.position)}</td><td class="mono">${labels[pt.id]||''}</td>`;
        markerTbl.appendChild(tr);
      } catch(e){ showErr(e); });
    } catch(e){ showErr(e); } else {
      const tr=document.createElement('tr'); tr.innerHTML='<td colspan="3">対応マーカーチャンクが見つかりません（cue/adtl）</td>'; markerTbl.appendChild(tr);
    } catch(e){ showErr(e); }

    // Skipped + hex
    skipTbl.innerHTML='';
    p.skipped.forEach((c,i)=>{
      const tr=document.createElement('tr');
      const hexHead = (c.head||[]).map(b=>hex2(b)).join(' ');
      tr.innerHTML = `<td>${i+1}</td><td class="mono">${c.id}</td><td>${fmtNum(c.size)}</td><td>${fmtNum(c.dataOffset)}</td><td><details><summary>表示</summary><div class="hex">${hexHead}</div></details></td>`;
      skipTbl.appendChild(tr);
    } catch(e){ showErr(e); });

    // Summary (no '-')
    const frames = (p.data && p.fmt)? Math.floor(p.data.size/p.fmt.nBlockAlign):0;
    const dur = (p.fmt? frames/p.fmt.nSamplesPerSec : NaN);
    const rangeSummary = p.cset ? friendly(RANGE_CODE, p.cset.common.measureFreqRangeCode) : 'なし (CSET 未検出)';
    const deviceSummary = p.cset ? (p.cset.common.unitName || p.cset.common.productType || 'Unknown') : 'Unknown';
    const startSummary = p.cset ? new Date(p.cset.common.startTimeMs).toLocaleString() : 'Unknown';
    summary.innerHTML = `
      <div>サンプルレート: <span class="chip">${p.fmt?fmtNum(p.fmt.nSamplesPerSec):'Unknown'} Hz</span></div>
      <div>レンジ: <span class="chip">${rangeSummary}</span></div>
      <div>使用機器: <span class="chip">${deviceSummary}</span></div>
      <div>開始時刻: <span class="chip">${startSummary}</span></div>
      <div>長さ: <span class="chip">${toTime(dur)}</span></div>
    `;

    // Validation
    validation.innerHTML='';
    const addVal=(ok,msg)=>{ const li=document.createElement('li'); li.innerHTML=(ok?'<span class="ok">OK</span> ':'<span class="bad">NG</span> ')+msg; validation.appendChild(li); };
    addVal(p.header.riff==='RIFF', `'RIFF' ヘッダ`);
    addVal(p.header.wave==='WAVE', `'WAVE' タイプ`);
    addVal(!!p.fmt, '`fmt ` の存在');
    if(p.fmt){
      const computed=p.fmt.nChannels*p.fmt.wBitsPerSample/8;
      addVal(p.fmt.nBlockAlign===computed, `nBlockAlign = nChannels × wBitsPerSample / 8 (${p.fmt.nBlockAlign} vs ${computed})`);
      const nabps = p.fmt.nSamplesPerSec * p.fmt.nBlockAlign;
      addVal(p.fmt.nAvgBytesPerSec===nabps, `nAvgBytesPerSec = Fs × nBlockAlign (${p.fmt.nAvgBytesPerSec} vs ${nabps})`);
    } catch(e){ showErr(e); }
    addVal(!!p.data, '`data` の存在');
    if(p.data && p.fmt){ addVal((p.data.size%p.fmt.nBlockAlign)===0, `data サイズが blockAlign の整数倍`); }
    if(p.cset && p.fmt && p.data){
      const frames = Math.floor(p.data.size/p.fmt.nBlockAlign);
      const estFrames = Math.round((p.cset.common.actualRecordTimeMs/1000) * p.fmt.nSamplesPerSec);
      const diff = Math.abs(frames - estFrames);
      const ok = (estFrames>0) ? (diff/estFrames <= 0.02) : false; // ±2%
      addVal(ok, `frames と 実記録時間(×Fs) の整合 (${fmtNum(frames)} vs ${fmtNum(estFrames)}, 差 ${fmtNum(diff)})`);
    } catch(e){ showErr(e); }

    // CH selector & buttons
    chSelect.innerHTML='';
    if(p.fmt && p.data){
      for(let i=0;i<p.fmt.nChannels;i++){ const o=document.createElement('option'); o.value=i; o.textContent=`CH${i+1}`; chSelect.appendChild(o); }
      drawBtn.disabled=false; drawAllBtn.disabled=false;
    } catch(e){ showErr(e); }else{
      drawBtn.disabled=true; drawAllBtn.disabled=true;
    } catch(e){ showErr(e); }
  } catch(e){ showErr(e); }

  // ====== Export ======
  function toJSON(p, fileName){
    return {
      file: fileName,
      header: p.header, fmt: p.fmt, data: p.data,
      type: p.type, wset: p.wset, cset: p.cset,
      markers: {cue: p.cue, adtl: p.adtl},
      skipped: p.skipped.map(s=>({id:s.id,size:s.size,offset:s.dataOffset}))
    } catch(e){ showErr(e); };
  } catch(e){ showErr(e); }
  function toCSVRow(p, fileName){
    const Fs = p.fmt?.nSamplesPerSec ?? '';
    const Ch = p.fmt?.nChannels ?? '';
    const Bits = p.fmt?.wBitsPerSample ?? '';
    const frames = (p.data && p.fmt)? Math.floor(p.data.size/p.fmt.nBlockAlign):0;
    const dur = (p.fmt? frames/p.fmt.nSamplesPerSec : 0);
    const Range = p.cset ? friendly(RANGE_CODE, p.cset.common.measureFreqRangeCode) : 'CSETなし';
    const Device = p.cset ? (p.cset.common.unitName || p.cset.common.productType || '') : '';
    const Start = p.cset ? new Date(p.cset.common.startTimeMs).toISOString() : '';
    return [fileName, Fs, Ch, Bits, dur.toFixed(3), Range, Device, Start];
  } catch(e){ showErr(e); }
  function downloadText(name, text){
    const blob = new Blob([text], {type:'text/plain'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; a.click(); URL.revokeObjectURL(a.href);
  } catch(e){ showErr(e); }

  // ====== Handlers ======
  async function handleFiles(files){
    try {
    parsedBatch=[]; batchTbl.innerHTML='';
    if(!files || files.length===0) return;
    if(files.length===1){
      await handleFile(files[0]);
    } catch(e){ showErr(e); } else {
      fileInfo.textContent = `${files.length} ファイルを読み込み中…`;
      for(const f of files){
        const buf=await f.arrayBuffer(); const p=parseWav(buf);
        parsedBatch.push({name:f.name, parsed:p});
        // append batch row
        const row = toCSVRow(p, f.name);
        const tr=document.createElement('tr'); tr.innerHTML = `<td class="mono">${row[0]}</td><td>${row[1]}</td><td>${row[2]}</td><td>${row[3]}</td><td>${row[4]}</td><td>${row[5]}</td><td class="mono">${row[6]}</td><td class="mono">${row[7]}</td>`;
        batchTbl.appendChild(tr);
      } catch(e){ showErr(e); }
      // also display details of the first file
      currentFileName = files[0].name;
      parsed = parsedBatch[0].parsed;
      renderAll(parsed);
      exportJSON.disabled=false; exportCSV.disabled=false;
      fileInfo.textContent = `最初の1件を詳細表示中：${files[0].name}`;
    } catch(e){ showErr(e); }
    } catch(e){ showErr(e); } catch(e){ showErr(e); }
  } catch(e){ showErr(e); }
  async function handleFile(file){
    try {
    currentFileName = file.name;
    fileInfo.textContent = `${file.name}（${fmtNum(file.size)} bytes）読み込み中…`;
    const buf = await file.arrayBuffer();
    parsed = parseWav(buf);
    renderAll(parsed);
    exportJSON.disabled=false; exportCSV.disabled=false;
    fileInfo.textContent = `${file.name} を解析しました。`;
    errBox.textContent = '';
  } catch(e){ showErr(e); }

  // Draw buttons
  drawBtn.addEventListener('click', ()=>{
    if(!parsed || !parsed.fmt || !parsed.data) return;
    const ch=parseInt(chSelect.value,10)||0;
    const w=Math.max(200, parseInt(el('#plotWidth').value,10)||1200);
    const h=Math.max(120, parseInt(el('#plotHeight').value,10)||200);
    const eu=el('#euToggle').checked, dbfs=el('#dbfsToggle').checked;
    const fs = parseFloat(fsOverride.value)||0;
    canvasWrap.innerHTML='';
    canvasWrap.appendChild(drawWaveform(parsed,{channelIndex:ch,width:w,height:h,eu,dbfs,fsOverride:fs}));
    const N=parseInt(firstN.value,10)||16;
    const arr = extractSamples(parsed,ch,N,eu,dbfs,fs);
    const lines = arr.map((o,i)=>{
      let s=`[${i}] raw=${o.raw}`;
      if(o.dbfs!==null) s += `, dbFS=${(o.dbfs===-Infinity?'-Inf':o.dbfs.toFixed(2))}`;
      if(o.eu!==null) s += `, EU=${o.eu}`;
      return s;
    } catch(e){ showErr(e); }).join('\n');
    firstSamplesPre.textContent = lines;
  } catch(e){ showErr(e); });
  drawAllBtn.addEventListener('click', ()=>{
    if(!parsed || !parsed.fmt || !parsed.data) return;
    const n=parsed.fmt.nChannels;
    const cols = (n>=4)? 2 : 1;
    const w=Math.max(200, parseInt(el('#plotWidth').value,10)||1200);
    const h=Math.max(120, parseInt(el('#plotHeight').value,10)||200);
    const eu=el('#euToggle').checked, dbfs=el('#dbfsToggle').checked;
    const fs = parseFloat(fsOverride.value)||0;
    canvasWrap.innerHTML='';
    for(let ch=0; ch<n; ch++){
      const title=document.createElement('div'); title.className='kicker'; title.textContent=`CH${ch+1}`;
      canvasWrap.appendChild(title);
      canvasWrap.appendChild(drawWaveform(parsed,{channelIndex:ch,width:w,height:h,eu,dbfs,fsOverride:fs}));
    } catch(e){ showErr(e); }
  } catch(e){ showErr(e); });

  // Export buttons
  exportJSON.addEventListener('click', ()=>{
    if(parsedBatch.length>0){
      const arr = parsedBatch.map(x=>toJSON(x.parsed, x.name));
      downloadText('wav_inspect_batch.json', JSON.stringify(arr, null, 2));
    } catch(e){ showErr(e); } else if(parsed){
      downloadText((currentFileName||'wave')+'_inspect.json', JSON.stringify(toJSON(parsed, currentFileName), null, 2));
    } catch(e){ showErr(e); }
  } catch(e){ showErr(e); });
  exportCSV.addEventListener('click', ()=>{
    let rows = [['File','Fs_Hz','Ch','Bits','Duration_s','Range','Device','Start_ISO']];
    if(parsedBatch.length>0){
      parsedBatch.forEach(x=>rows.push(toCSVRow(x.parsed, x.name)));
    } catch(e){ showErr(e); } else if(parsed){
      rows.push(toCSVRow(parsed, currentFileName||'wave'));
    } catch(e){ showErr(e); }
    const csv = rows.map(r=>r.map(v=>(String(v).includes(',')?`"${String(v).replace(/"/g,'""')}"`:String(v))).join(',')).join('\n');
    downloadText('wav_inspect_summary.csv', csv);
  } catch(e){ showErr(e); });

  // Drag & Drop & input
  drop.addEventListener('dragover', (e)=>{ e.preventDefault(); });
  drop.addEventListener('drop', (e)=>{ e.preventDefault(); const files=e.dataTransfer.files; if(files?.length) handleFiles(files); });
  fileInput.addEventListener('change', (e)=>{ const files=e.target.files; if(files?.length) handleFiles(files); });

})();
</script>
</body>
</html>
