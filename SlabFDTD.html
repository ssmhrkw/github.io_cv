<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Slab FDTD Prototype — WebWorker・Freehand・録画・FFT</title>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
:root{--bg:#f7f8fb;--card:#fff;--ink:#0f172a;--muted:#475569;--accent:#2563eb}
body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,"Noto Sans JP"}
.wrap{max-width:1200px;margin:12px auto;padding:12px}
.grid{display:grid;grid-template-columns:380px 1fr;gap:12px}
.card{background:var(--card);padding:12px;border-radius:10px;border:1px solid #e6edf3}
label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
input,select,button{width:100%;padding:8px;border-radius:8px;border:1px solid #e6edf3;margin-bottom:8px;box-sizing:border-box}
.modeToggle{display:flex;gap:8px;margin-bottom:8px}
.modeToggle button{flex:1;padding:8px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;cursor:pointer}
.modeToggle button.active{background:#eef6ff;border-color:var(--accent)}
#drawCanvas{width:100%;height:220px;border-radius:6px;background:#fff;touch-action:none}
#heatCanvas{width:100%;height:480px;background:#fff;display:block;border-radius:6px}
.small{font-size:13px;color:var(--muted)}
.inline{display:flex;gap:8px}
.controls-row{display:flex;gap:8px;align-items:center}
#plotFFT{height:240px}
.slider{width:100%}
.playbar{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
<div class="wrap">
  <h2>Slab FDTD Prototype — Freehand, WebWorker, Recording, FFT</h2>
  <div class="grid">
    <div class="card">
      <div><strong>描画モード</strong></div>
      <div class="modeToggle">
        <button id="modeVertex" class="">Vertex</button>
        <button id="modeFree" class="active">Freehand (Apple Pencil 対応)</button>
      </div>
      <canvas id="drawCanvas" width=800 height=360></canvas>
      <div class="inline">
        <button id="clearBtn">Clear</button>
        <button id="closeBtn">Close (vertex)</button>
        <button id="smoothFillBtn">Smooth & Fill</button>
        <button id="rectBtn">Full Rect</button>
      </div>

      <hr/>
      <div><strong>モデル & 解析</strong></div>
      <div class="controls-row">
        <div style="flex:1"><label>Lx [m]</label><input id="Lx" type="number" step="0.01" value="5.00"></div>
        <div style="flex:1"><label>Ly [m]</label><input id="Ly" type="number" step="0.01" value="4.00"></div>
      </div>
      <div class="controls-row">
        <div style="flex:1"><label>Material</label>
          <select id="material">
            <option value="concrete">Concrete (E=30e9,ν=0.2,ρ=2400,h=0.15)</option>
            <option value="light">Light (E=2e9,ν=0.25,ρ=1200,h=0.10)</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div style="flex:1"><label>h [m]</label><input id="h" type="number" step="0.01" value="0.15"></div>
      </div>
      <div class="controls-row">
        <div style="flex:1"><label>Ngrid</label><input id="Ngrid" type="number" value="64" min="24" max="160"></div>
        <div style="flex:1"><label>Frames (saved)</label><input id="Nframes" type="number" value="96" min="8" max="512"></div>
      </div>
      <div class="controls-row">
        <div style="flex:1"><label>speedFactor (安定性)</label><input id="speedFactor" type="number" step="0.05" value="0.18"></div>
        <div style="flex:1"><label>Preset source</label>
          <select id="srcPreset">
            <option value="center">Center</option>
            <option value="dice5">Dice-5</option>
            <option value="corner0">Corner0</option>
            <option value="corner1">Corner1</option>
            <option value="corner2">Corner2</option>
            <option value="corner3">Corner3</option>
          </select>
        </div>
      </div>

      <div class="controls-row">
        <div style="flex:1"><label>Force type</label><select id="fType"><option value="impulse">Impulse</option><option value="pulse">Pulse</option></select></div>
        <div style="flex:1"><label>dx override (0 = auto)</label><input id="dx" type="number" step="0.01" value="0"></div>
      </div>

      <div class="inline">
        <button id="runBtn" class="btn">Run</button>
        <button id="stopBtn">Stop</button>
        <button id="snapshotBtn">Snapshot PNG</button>
      </div>

      <hr/>
      <div><strong>Playback & Recording</strong></div>
      <div class="playbar">
        <button id="playBtn">Play</button>
        <button id="pauseBtn">Pause</button>
        <button id="prevBtn">◀</button>
        <button id="nextBtn">▶</button>
        <input id="frameSlider" class="slider" type="range" min="0" value="0">
      </div>
      <div class="inline" style="margin-top:6px">
        <button id="startRec">Start Recording (WebM)</button>
        <button id="stopRec">Stop Recording</button>
        <a id="recDownload" style="display:inline-block;margin-left:8px"></a>
      </div>

      <hr/>
      <div><strong>Probe & FFT</strong></div>
      <div class="controls-row">
        <div style="flex:1"><label>Probe x [m]</label><input id="px" type="number" step="0.01" value="2.50"></div>
        <div style="flex:1"><label>Probe y [m]</label><input id="py" type="number" step="0.01" value="2.00"></div>
      </div>
      <div class="controls-row">
        <div style="flex:1"><label>Choice</label>
          <select id="vfChoice"><option value="v_over_F">v / F</option><option value="F_over_v">F / v</option></select>
        </div>
        <div style="flex:1"><label>Window</label><select id="winType"><option value="none">none</option><option value="hann">hann</option></select></div>
      </div>
      <div class="inline">
        <button id="analyzeBtn">Analyze (Probe FFT)</button>
        <select id="peakSelect"><option value="">--peaks--</option></select>
        <button id="showMode">Show Mode Map</button>
      </div>
      <div style="margin-top:8px" class="small">
        <strong>注意</strong>：近似スキームです。dx小→正確だが遅い。安定性は speedFactor を下げると安全です。
      </div>
    </div>

    <div class="card">
      <canvas id="heatCanvas" width=800 height=480></canvas>
      <div id="plotFFT"></div>
    </div>
  </div>
</div>

<script>
/* ========== Utilities ========== */
const $ = id => document.getElementById(id);
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

/* ========== Drawing (vertex + freehand with Apple Pencil support) ========== */
const drawCanvas = $('drawCanvas');
const dctx = drawCanvas.getContext('2d');
let mode = 'free'; // 'vertex' or 'free'
$('modeVertex').onclick = ()=>{ mode='vertex'; $('modeVertex').classList.add('active'); $('modeFree').classList.remove('active'); };
$('modeFree').onclick = ()=>{ mode='free'; $('modeFree').classList.add('active'); $('modeVertex').classList.remove('active'); };

let vertices = [], closed=false, freePath=[];
let isDrawing=false;
function redrawCanvas(){
  dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
  dctx.fillStyle='#fff'; dctx.fillRect(0,0,drawCanvas.width,drawCanvas.height);
  // free path
  if(freePath.length>0){
    dctx.strokeStyle='#e11'; dctx.lineWidth=2; dctx.beginPath();
    dctx.moveTo(freePath[0][0], freePath[0][1]);
    for(let i=1;i<freePath.length;i++) dctx.lineTo(freePath[i][0], freePath[i][1]);
    dctx.stroke();
  }
  // polygon
  if(vertices.length>0){
    dctx.strokeStyle='#2563eb'; dctx.lineWidth=2; dctx.beginPath();
    dctx.moveTo(vertices[0][0], vertices[0][1]);
    for(let i=1;i<vertices.length;i++) dctx.lineTo(vertices[i][0], vertices[i][1]);
    if(closed) dctx.closePath();
    dctx.stroke();
    for(const p of vertices){ dctx.fillStyle='#2563eb'; dctx.beginPath(); dctx.arc(p[0],p[1],3,0,Math.PI*2); dctx.fill(); }
  }
}
drawCanvas.addEventListener('pointerdown', (ev)=>{
  const r = drawCanvas.getBoundingClientRect();
  const x = ev.clientX - r.left, y = ev.clientY - r.top;
  if(mode==='free'){
    isDrawing=true; freePath.push([x,y]); drawCanvas.setPointerCapture(ev.pointerId);
  } else {
    if(!closed){ vertices.push([x,y]); }
  }
  redrawCanvas();
});
drawCanvas.addEventListener('pointermove', (ev)=>{
  if(mode!=='free' || !isDrawing) return;
  const r = drawCanvas.getBoundingClientRect();
  const x = ev.clientX - r.left, y = ev.clientY - r.top;
  freePath.push([x,y]); // pressure not used
  // incremental draw
  const L = freePath.length;
  if(L>1){ dctx.strokeStyle='#e11'; dctx.lineWidth=2; dctx.beginPath(); dctx.moveTo(freePath[L-2][0], freePath[L-2][1]); dctx.lineTo(freePath[L-1][0], freePath[L-1][1]); dctx.stroke(); }
});
drawCanvas.addEventListener('pointerup', (ev)=>{
  if(mode!=='free') return;
  isDrawing=false; drawCanvas.releasePointerCapture(ev.pointerId);
});
$('clearBtn').onclick = ()=>{ vertices=[]; freePath=[]; closed=false; redrawCanvas(); mask=null; showMaskPreview(); };
$('closeBtn').onclick = ()=>{ if(vertices.length>2){ closed=true; redrawCanvas(); } };
$('rectBtn').onclick = ()=>{ vertices=[[10,10],[drawCanvas.width-10,10],[drawCanvas.width-10,drawCanvas.height-10],[10,drawCanvas.height-10]]; closed=true; freePath=[]; redrawCanvas(); createMaskFromVertices(vertices); showMaskPreview(); };

/* RDP simplify */
function rdp(points, eps){
  if(points.length < 3) return points.slice();
  const distToSeg = (p,a,b)=>{
    const px=p[0], py=p[1], ax=a[0], ay=a[1], bx=b[0], by=b[1];
    const dx=bx-ax, dy=by-ay;
    if(dx===0 && dy===0) return Math.hypot(px-ax,py-ay);
    const t = ((px-ax)*dx + (py-ay)*dy) / (dx*dx+dy*dy);
    if(t<0) return Math.hypot(px-ax,py-ay);
    if(t>1) return Math.hypot(px-bx,py-by);
    const projx = ax+t*dx, projy = ay+t*dy;
    return Math.hypot(px-projx,py-projy);
  };
  let maxd=0, idx=0;
  for(let i=1;i<points.length-1;i++){
    const d = distToSeg(points[i], points[0], points[points.length-1]);
    if(d>maxd){ maxd=d; idx=i; }
  }
  if(maxd > eps){
    const l = rdp(points.slice(0, idx+1), eps);
    const r = rdp(points.slice(idx), eps);
    return l.slice(0,-1).concat(r);
  } else return [points[0], points[points.length-1]];
}

/* mask creation */
let mask = null; // {w,h,arr}
function createMaskFromVertices(verts){
  const Ngrid = Math.max(24, Math.min(160, parseInt($('Ngrid').value||64)));
  const W = Ngrid, H = Math.max(8, Math.round(Ngrid * drawCanvas.height / drawCanvas.width));
  const arr = new Uint8Array(W*H);
  for(let j=0;j<H;j++){
    for(let i=0;i<W;i++){
      const cx = i*(drawCanvas.width/W) + drawCanvas.width/(2*W);
      const cy = j*(drawCanvas.height/H) + drawCanvas.height/(2*H);
      if(pointInPoly(cx,cy,verts)) arr[j*W+i]=1;
    }
  }
  mask = {w:W,h:H,arr};
}
function pointInPoly(x,y,poly){
  let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i][0], yi=poly[i][1], xj=poly[j][0], yj=poly[j][1];
    const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
    if(intersect) inside=!inside;
  }
  return inside;
}
$('smoothFillBtn').onclick = ()=>{
  let pts = freePath.length>10 ? freePath.slice() : vertices.slice();
  if(pts.length<6) return alert('もっとしっかり描いてください');
  pts.push(pts[0]);
  const simp = rdp(pts, 2.0);
  vertices = simp.map(p=>[p[0],p[1]]); closed=true; freePath=[];
  createMaskFromVertices(vertices);
  redrawCanvas(); showMaskPreview();
};

/* preview mask on heat plot */
const heatCanvas = $('heatCanvas'); const hctx = heatCanvas.getContext('2d');
function showMaskPreview(){
  const Nx = mask?mask.w:Math.max(24,parseInt($('Ngrid').value||64));
  const Ny = mask?mask.h:Math.max(8,Math.round(Nx*drawCanvas.height/drawCanvas.width));
  const img = hctx.createImageData(Nx,Ny);
  for(let j=0;j<Ny;j++){
    for(let i=0;i<Nx;i++){
      const idx = j*Nx+i;
      const v = mask ? (mask.arr[idx]?200:255) : 255;
      const p = (j*Nx + i)*4;
      img.data[p]=v; img.data[p+1]=v; img.data[p+2]=v; img.data[p+3]=255;
    }
  }
  // scale to canvas
  const tmp = document.createElement('canvas'); tmp.width=Nx; tmp.height=Ny; tmp.getContext('2d').putImageData(img,0,0);
  hctx.clearRect(0,0,heatCanvas.width,heatCanvas.height);
  hctx.drawImage(tmp,0,0,heatCanvas.width,heatCanvas.height);
}

/* ========== WebWorker FDTD ========== */
/* We'll create inline worker via Blob */
const workerCode = `self.onmessage = function(e){
  const cfg = e.data;
  const Lx = cfg.Lx, Ly=cfg.Ly, E=cfg.E, nu=cfg.nu, rho=cfg.rho, h=cfg.h;
  const Ngrid = cfg.Ngrid, Nframes = cfg.Nframes, speedFactor=cfg.speedFactor;
  const mask = cfg.mask; // {w,h,arr}
  const dx = cfg.dx>0 ? cfg.dx : Math.max(Lx/(Ngrid-1), Ly/(Ngrid-1));
  const Nx = Ngrid, Ny = Ngrid;
  const mass = rho*h;
  const D = E * Math.pow(h,3) / (12*(1 - nu*nu));
  const dt = Math.max(1e-8, speedFactor * dx*dx * Math.sqrt(mass/D));
  const totalSteps = Nframes; // one step per frame for simplicity
  // arrays
  const size = Nx*Ny;
  let w = new Float32Array(size), wprev = new Float32Array(size), wnext = new Float32Array(size);
  // map mask to numerical grid (mask may have different resolution)
  const maskArr = new Uint8Array(size);
  if(mask){
    for(let j=0;j<Ny;j++){
      for(let i=0;i<Nx;i++){
        const mi = Math.floor(i / Nx * mask.w);
        const mj = Math.floor(j / Ny * mask.h);
        maskArr[j*Nx+i] = mask.arr[mj*mask.w + mi] ? 1 : 0;
      }
    }
  } else { for(let k=0;k<size;k++) maskArr[k]=1; }
  // source mapping (center)
  const sx = Math.round(Nx/2), sy=Math.round(Ny/2);
  const srcIdx = sy*Nx + sx;
  // simple run
  // use minimal biharmonic: lap then lap(lap)
  function lapField(arr){
    const lap = new Float32Array(size);
    for(let j=1;j<Ny-1;j++){
      for(let i=1;i<Nx-1;i++){
        const idx=j*Nx+i;
        if(!maskArr[idx]) continue;
        lap[idx] = (arr[idx-1] + arr[idx+1] + arr[idx-Nx] + arr[idx+Nx] - 4*arr[idx])/(dx*dx);
      }
    }
    return lap;
  }
  // store frames as Float32Array flattened
  const frames = [];
  for(let step=0; step<totalSteps; step++){
    // apply short impulse
    const F = new Float32Array(size);
    if(step < Math.max(1, Math.floor(totalSteps*0.02))) F[srcIdx] = 1.0;
    const lap = lapField(w);
    const bih = lapField(lap);
    const coeff = (dt*dt)/mass;
    for(let idx=0; idx<size; idx++){
      if(!maskArr[idx]){ wnext[idx]=0; continue; }
      const rhs = F[idx] - D * bih[idx];
      wnext[idx] = 2*w[idx] - wprev[idx] + coeff * rhs;
    }
    // rotate
    wprev.set(w); w.set(wnext);
    // copy frame
    frames.push(w.slice(0));
    if(step%Math.max(1,Math.floor(totalSteps/10))===0){
      self.postMessage({type:'progress',progress: Math.round(100*step/totalSteps)});
    }
  }
  // send result
  self.postMessage({type:'done',frames:frames, dx:dx, dt:dt, Nx:Nx, Ny:Ny});
};`;
const workerBlob = new Blob([workerCode], {type:'application/javascript'});
const workerURL = URL.createObjectURL(workerBlob);

/* control flow */
let computeWorker = null;
let globalResult = null; // {frames,dx,dt,Nx,Ny}
$('runBtn').onclick = ()=>{
  // gather params
  if(!mask) { alert('まずマスクを作成してください（Freehandで描きSmooth & Fill）'); return; }
  $('runBtn').disabled = true;
  const mat = $('material').value;
  if(mat==='concrete'){ $('h').value=0.15; }
  else if(mat==='light'){ $('h').value=0.10; }
  const cfg = {
    Lx: parseFloat($('Lx').value), Ly: parseFloat($('Ly').value),
    E: mat==='concrete' ? 3e10 : (mat==='light'?2e9:3e10),
    nu: mat==='concrete'?0.2:0.25,
    rho: mat==='concrete'?2400:1200,
    h: parseFloat($('h').value),
    Ngrid: parseInt($('Ngrid').value),
    Nframes: parseInt($('Nframes').value),
    speedFactor: parseFloat($('speedFactor').value),
    mask: mask,
    dx: parseFloat($('dx').value)
  };
  computeWorker = new Worker(workerURL);
  computeWorker.onmessage = (ev)=>{
    const msg = ev.data;
    if(msg.type==='progress'){ console.log('progress', msg.progress); }
    if(msg.type==='done'){
      globalResult = msg;
      $('runBtn').disabled = false;
      console.log('done', msg);
      // show final frame and enable controls
      renderFrameToCanvas(msg.frames[msg.frames.length-1], msg.Nx, msg.Ny, mask);
      setupPlayback(msg.frames, msg);
    }
  };
  computeWorker.postMessage(cfg);
};

/* stop */
$('stopBtn').onclick = ()=>{
  if(computeWorker){ computeWorker.terminate(); computeWorker=null; $('runBtn').disabled=false; alert('計算を中止しました'); }
};

/* render heatmap to canvas (fast) */
function renderFrameToCanvas(frame,Nx,Ny,maskObj){
  // create ImageData Nx x Ny scaled to canvas
  const minMax = getMinMax(frame);
  const minV = minMax.min, maxV = minMax.max;
  const img = hctx.createImageData(Nx,Ny);
  for(let j=0;j<Ny;j++){
    for(let i=0;i<Nx;i++){
      const v = frame[j*Nx+i];
      const norm = (v - minV) / (maxV - minV + 1e-15);
      const col = viridisColor(norm);
      const p = (j*Nx+i)*4;
      img.data[p]=col[0]; img.data[p+1]=col[1]; img.data[p+2]=col[2]; img.data[p+3]=255;
    }
  }
  const tmp = document.createElement('canvas'); tmp.width=Nx; tmp.height=Ny; tmp.getContext('2d').putImageData(img,0,0);
  hctx.clearRect(0,0,heatCanvas.width,heatCanvas.height);
  hctx.drawImage(tmp,0,0,heatCanvas.width,heatCanvas.height);
}
function getMinMax(arr){ let mi=Number.POSITIVE_INFINITY, ma=Number.NEGATIVE_INFINITY; for(let v of arr){ if(v<mi)mi=v; if(v>ma)ma=v; } return {min:mi,max:ma}; }
/* simple viridis-like map */
function viridisColor(t){
  t = clamp(t,0,1);
  const r = Math.round(68 + 187*t); const g = Math.round(1 + 185*t); const b = Math.round(84 + 40*(1-t));
  return [r,g,b];
}

/* Playback & frames handling */
let framesArr = [], playTimer=null, currentFrame=0;
function setupPlayback(frames, meta){
  framesArr = frames;
  currentFrame=0;
  $('frameSlider').max = framesArr.length-1;
  $('frameSlider').value = 0;
  // render first
  renderFrameToCanvas(framesArr[0], meta.Nx, meta.Ny, mask);
}
$('frameSlider').oninput = (e)=>{ const i=parseInt(e.target.value); if(framesArr.length) { currentFrame=i; renderFrameToCanvas(framesArr[i], globalResult.Nx, globalResult.Ny, mask); } };
$('playBtn').onclick = ()=>{ if(!framesArr.length) return; if(playTimer) return; playTimer = setInterval(()=>{ currentFrame = (currentFrame+1) % framesArr.length; $('frameSlider').value = currentFrame; renderFrameToCanvas(framesArr[currentFrame], globalResult.Nx, globalResult.Ny, mask); }, 100); };
$('pauseBtn').onclick = ()=>{ if(playTimer){ clearInterval(playTimer); playTimer=null; } };
$('prevBtn').onclick = ()=>{ if(!framesArr.length) return; currentFrame = Math.max(0,currentFrame-1); $('frameSlider').value=currentFrame; renderFrameToCanvas(framesArr[currentFrame], globalResult.Nx, globalResult.Ny, mask); };
$('nextBtn').onclick = ()=>{ if(!framesArr.length) return; currentFrame = Math.min(framesArr.length-1,currentFrame+1); $('frameSlider').value=currentFrame; renderFrameToCanvas(framesArr[currentFrame], globalResult.Nx, globalResult.Ny, mask); };

/* Snapshot */
$('snapshotBtn').onclick = ()=>{ heatCanvas.toBlob(blob=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='snapshot.png'; a.click(); }); };

/* Recording via MediaRecorder capturing heatCanvas */
let mediaRecorder=null, recordedBlobs=[];
$('startRec').onclick = ()=>{
  if(!framesArr.length) return alert('まずRunでフレームを生成してください');
  recordedBlobs=[];
  const stream = heatCanvas.captureStream(25);
  mediaRecorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'});
  mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) recordedBlobs.push(e.data); };
  mediaRecorder.onstop = ()=>{ const blob = new Blob(recordedBlobs, {type:'video/webm'}); const url = URL.createObjectURL(blob); const a=$('recDownload'); a.href=url; a.download='record.webm'; a.textContent='Download video'; };
  mediaRecorder.start();
  // auto play frames into canvas during recording
  let k=0;
  const recInterval = setInterval(()=>{ if(k>=framesArr.length){ clearInterval(recInterval); mediaRecorder.stop(); return; } renderFrameToCanvas(framesArr[k], globalResult.Nx, globalResult.Ny, mask); k++; }, 100);
};
$('stopRec').onclick = ()=>{ if(mediaRecorder && mediaRecorder.state==='recording') mediaRecorder.stop(); };

/* ========== FFT (probe) ========== */
/* simple DFT for small N */
function dftReal(x){
  const N = x.length; const re = new Float64Array(N/2), mag = new Float64Array(N/2);
  for(let k=0;k<N/2;k++){
    let r=0,i=0;
    for(let n=0;n<N;n++){ const a=x[n]; const ang = -2*Math.PI*k*n/N; r+=a*Math.cos(ang); i+=a*Math.sin(ang); }
    re[k]=Math.hypot(r,i); mag[k]=Math.hypot(r,i);
  }
  return {mag};
}
$('analyzeBtn').onclick = ()=>{
  if(!globalResult) return alert('Runしてフレームを保存してください');
  const px = parseFloat($('px').value), py=parseFloat($('py').value);
  // map probe to grid index
  const Nx = globalResult.Nx, Ny = globalResult.Ny, dx = globalResult.dx;
  const ix = clamp(Math.round(px / ( ($('Lx').value || 1) / (Nx-1) )), 0, Nx-1);
  const iy = clamp(Math.round(py / ( ($('Ly').value || 1) / (Ny-1) )), 0, Ny-1);
  // build time series of displacement
  const Nf = framesArr.length;
  const ts = new Float64Array(Nf);
  for(let n=0;n<Nf;n++) ts[n] = framesArr[n][iy*Nx + ix];
  // velocity by central difference
  const dt = globalResult.dt;
  const vts = new Float64Array(Nf-2);
  for(let n=1;n<Nf-1;n++) vts[n-1] = (ts[n+1]-ts[n-1])/(2*dt);
  // choose v/F or F/v; F assumed 1N impulse amplitude
  const choice = $('vfChoice').value;
  // window
  if($('winType').value==='hann'){ for(let n=0;n<vts.length;n++){ vts[n] *= 0.5*(1-Math.cos(2*Math.PI*n/(vts.length-1))); } }
  const dft = dftReal(vts);
  const mags = dft.mag;
  // freqs
  const freqs = new Array(mags.length); for(let k=0;k<mags.length;k++) freqs[k] = k / (vts.length*dt);
  // compute display (v/F) magnitude; F=1 => v/F = |V|; F/v = 1/|V|
  const vals = new Array(mags.length);
  for(let k=0;k<mags.length;k++){
    const v = mags[k];
    vals[k] = (choice==='v_over_F') ? v : (v>0 ? 1.0/v : 0);
  }
  // convert to dB (20 log10)
  const db = vals.map(v=>20*Math.log10(Math.max(v,1e-20)));
  // plot semilogx via Plotly
  const trace = {x: freqs, y: db, type:'scatter', mode:'lines', name:'spectrum', line:{width:2}};
  const layout = {xaxis:{type:'log', title:'Hz'}, yaxis:{title:'20 log10 (ref=1)'}, margin:{t:20}};
  Plotly.newPlot('plotFFT',[trace],layout,{responsive:true,displaylogo:false});
  // peaks: simple local maxima on db
  const peaks=[];
  for(let k=2;k<db.length-2;k++){ if(db[k]>db[k-1] && db[k]>db[k+1]) peaks.push({k,f:freqs[k],mag:db[k]}); }
  peaks.sort((a,b)=>b.mag-a.mag);
  const sel = $('peakSelect'); sel.innerHTML=''; for(let i=0;i<Math.min(8,peaks.length);i++){ const o=document.createElement('option'); o.value=peaks[i].k; o.textContent=\`#\${i+1}: f=\${peaks[i].f.toFixed(3)}Hz (dB=\${peaks[i].mag.toFixed(1)})\`; sel.appendChild(o); }
};

/* Show Mode Map by computing complex DFT at chosen bin across cells */
$('showMode').onclick = async ()=>{
  if(!globalResult) return alert('Run first');
  const sel = $('peakSelect').value; if(!sel) return alert('まずピークを選択');
  const k = parseInt(sel);
  const Nx = globalResult.Nx, Ny = globalResult.Ny, Nf = framesArr.length, dt = globalResult.dt;
  const magMap = new Float32Array(Nx*Ny);
  for(let j=0;j<Ny;j++){
    for(let i=0;i<Nx;i++){
      let re=0, im=0;
      for(let n=0;n<Nf;n++){
        const a = framesArr[n][j*Nx + i];
        const ang = -2*Math.PI*k*n/Nf;
        re += a*Math.cos(ang); im += a*Math.sin(ang);
      }
      magMap[j*Nx + i] = Math.hypot(re,im);
    }
    if(j%8===0){ // progress render
      const img = hctx.createImageData(Nx,Ny);
      for(let jj=0;jj<Ny;jj++){ for(let ii=0;ii<Nx;ii++){ const v=magMap[jj*Nx+ii]; const c=viridisColor((v)/1.0); const p=(jj*Nx+ii)*4; img.data[p]=c[0]; img.data[p+1]=c[1]; img.data[p+2]=c[2]; img.data[p+3]=255; } }
      const tmp=document.createElement('canvas'); tmp.width=Nx; tmp.height=Ny; tmp.getContext('2d').putImageData(img,0,0);
      hctx.drawImage(tmp,0,0,heatCanvas.width,heatCanvas.height);
      await sleep(10);
    }
  }
  // final render
  const img = hctx.createImageData(Nx,Ny);
  const mm = Math.max(...magMap), mn = Math.min(...magMap);
  for(let j=0;j<Ny;j++){ for(let i=0;i<Nx;i++){ const v=magMap[j*Nx+i]; const norm=(v-mn)/(mm-mn+1e-15); const c=viridisColor(norm); const p=(j*Nx+i)*4; img.data[p]=c[0]; img.data[p+1]=c[1]; img.data[p+2]=c[2]; img.data[p+3]=255; } }
  const tmp=document.createElement('canvas'); tmp.width=Nx; tmp.height=Ny; tmp.getContext('2d').putImageData(img,0,0);
  hctx.drawImage(tmp,0,0,heatCanvas.width,heatCanvas.height);
  alert('Mode map done');
};

/* helper: map probe input px py (m) to grid index based on Lx Ly */
function probeToIndex(px,py,Nx,Ny){
  const Lx = parseFloat($('Lx').value), Ly=parseFloat($('Ly').value);
  const ix = clamp(Math.round(px / Lx * (Nx-1)), 0, Nx-1);
  const iy = clamp(Math.round(py / Ly * (Ny-1)), 0, Ny-1);
  return {ix,iy};
}

/* initial draw */
redrawCanvas(); showMaskPreview();

</script>
</body>
</html>
