<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>SlabFDTD — 四角板プロトタイプ（iPad向け修正版）</title>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
:root{--bg:#f7f8fb;--card:#fff;--ink:#0f172a;--muted:#475569;--accent:#2563eb}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,"Noto Sans JP",system-ui,Roboto}
.wrap{max-width:1200px;margin:14px auto;padding:12px}
.grid{display:grid;grid-template-columns:360px 1fr;gap:12px;align-items:start}
.card{background:var(--card);padding:12px;border-radius:10px;border:1px solid #e6edf3}
label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
input,select,button{width:100%;padding:8px;border-radius:8px;border:1px solid #e6edf3;margin-bottom:8px;box-sizing:border-box}
.row{margin-bottom:8px}
.btn{background:var(--accent);color:#fff;border:none;cursor:pointer;padding:8px;border-radius:8px}
.small{font-size:13px;color:var(--muted)}
#plot{height:36vh;min-height:220px}
.inline{display:flex;gap:8px;align-items:center}
.mode-list{max-height:180px;overflow:auto;padding:6px;border-radius:8px;background:#fbfcfe;border:1px solid #eef3fb}
.footer{font-size:13px;color:var(--muted);margin-top:8px;padding:8px;border-radius:8px;background:#fbfcfe}
.controls-row{display:flex;gap:8px}
canvas.heat{border-radius:6px;border:1px solid #eef3fb; touch-action: none; display:block; width:100%;}
canvas.modeCanvas{border-radius:6px;border:1px solid #eef3fb; display:block; width:100%;}
.progress{height:10px;background:#eef3fb;border-radius:6px;overflow:hidden}
.progress > div{height:100%;background:#60a5fa;width:0%}
.tabbar{display:flex;gap:8px;margin-bottom:8px}
.tab{padding:8px;border-radius:8px;background:#fff;border:1px solid #eef3fb;cursor:pointer}
.tab.active{background:var(--accent);color:#fff}
.small-btn{padding:6px;border-radius:6px;font-size:13px}
.probe-list{max-height:140px;overflow:auto;border:1px solid #eef3fb;padding:6px;border-radius:6px;background:#fbfcfe}
.kv{font-size:13px;color:var(--muted)}
#errorBox{color:#b91c1c;background:#fff1f2;border:1px solid #fecaca;padding:8px;border-radius:6px;margin-top:8px;display:none}
.overlayText{position:absolute;left:12px;top:12px;background:rgba(255,255,255,0.6);padding:6px;border-radius:6px;font-family:ui-sans-serif,system-ui;pointer-events:none}
</style>
</head>
<body>
<div class="wrap">
  <h2>SlabFDTD — 四角板プロトタイプ（iPad向け修正版）</h2>
  <div class="grid">
    <div class="card" id="controlsPanel">
      <div class="preset-grid" style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px">
        <div style="background:#fbfcfe;padding:8px;border-radius:8px;border:1px solid #eef3fb">
          <strong>材料プリセット</strong>
          <select id="material_preset" style="margin-top:6px">
            <option value="concrete">Concrete (E=3e10, ν=0.2, ρ=2400)</option>
            <option value="steel">Steel (E=2.1e11, ν=0.3, ρ=7850)</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div style="background:#fbfcfe;padding:8px;border-radius:8px;border:1px solid #eef3fb">
          <strong>加振点プリセット</strong>
          <select id="sourcePreset_preset" style="margin-top:6px">
            <option value="center">中心 (Lx/2, Ly/2)</option>
            <option value="diag_1_3">対角 1/3 (Lx/3, Ly/3)</option>
            <option value="diag_2_3">対角 2/3 (2Lx/3, 2Ly/3)</option>
            <option value="custom">カスタム</option>
          </select>
        </div>
      </div>

      <div id="paramsArea">
        <div class="row controls-row">
          <div style="flex:1">
            <label>E [Pa]</label><input id="E" type="number" value="30000000000">
          </div>
          <div style="flex:1">
            <label>ν</label><input id="nu" type="number" step="0.01" value="0.20">
          </div>
        </div>

        <div class="row controls-row">
          <div style="flex:1">
            <label>ρ [kg/m³]</label><input id="rho" type="number" value="2400">
          </div>
          <div style="flex:1">
            <label>h [m]</label><input id="h" type="number" step="0.01" value="0.15">
          </div>
        </div>

        <div class="row controls-row">
          <div style="flex:1"><label>Lx [m]</label><input id="Lx" type="number" step="0.01" value="5.00"></div>
          <div style="flex:1"><label>Ly [m]</label><input id="Ly" type="number" step="0.01" value="4.00"></div>
        </div>

        <div class="row controls-row">
          <div style="flex:1"><label>Ngrid</label><input id="Ngrid" type="number" step="1" min="16" value="80"></div>
          <div style="flex:1"><label>dx (m) — overrides Ngrid if >0</label><input id="dx" type="number" step="0.01" value="0.00"></div>
        </div>

        <div class="row controls-row">
          <div style="flex:1"><label>frames</label><input id="framesCount" type="number" min="8" max="1024" value="128"></div>
          <div style="flex:1"><label>samplesPerCycle</label><input id="samplesPerCycle" type="number" min="4" max="64" value="16"></div>
        </div>

        <div class="row controls-row">
          <div style="flex:1"><label>m_max</label><input id="mmax" type="number" min="1" max="20" value="5"></div>
          <div style="flex:1"><label>n_max</label><input id="nmax" type="number" min="1" max="20" value="5"></div>
        </div>

        <div class="row">
          <label>周波数 f [Hz]（空欄で第1モード）</label>
          <input id="freq" type="number" step="0.01" value="">
        </div>

        <div class="row">
          <label>加振点（プリセットかCanvasクリックで設定）</label>
          <div class="controls-row">
            <div style="flex:1"><input id="x0" type="number" step="0.01" value="2.50"></div>
            <div style="flex:1"><input id="y0" type="number" step="0.01" value="2.00"></div>
          </div>
        </div>

        <div class="row inline">
          <label><input type="checkbox" id="useDbStatic"> 静解析 dB 表示（10·log10）</label>
          <label style="margin-left:8px"><input type="checkbox" id="show2d" checked> 2D</label>
        </div>

        <div class="row">
          <button id="computeBtn" class="btn">計算開始</button>
          <button id="abortBtn" class="btn" style="background:#9ca3af">中断</button>
          <button id="resetBtn" class="btn" style="background:#94a3b8">リセット</button>
        </div>

        <div class="row">
          <label>Progress</label>
          <div class="progress"><div id="progressFill" style="width:0%"></div></div>
          <div id="progressText" class="small"></div>
          <div id="errorBox"></div>
        </div>
      </div>

      <hr>
      <div class="row"><strong>Mode list</strong></div>
      <div class="mode-list" id="modeList"></div>

      <div class="footer">
        <div><strong>式（参照）</strong></div>
        <div>D = E h³ / [12(1-ν²)], ω_mn = √(D/(ρ h)) · [ (mπ/Lx)² + (nπ/Ly)² ], φ_mn = sin(mπx/Lx)·sin(nπy/Ly)</div>
      </div>
    </div>

    <div class="card" style="position:relative">
      <div class="tabbar" role="tablist">
        <div class="tab active" data-tab="time">Time</div>
        <div class="tab" data-tab="mode">Mode</div>
        <div class="tab" data-tab="freq">Frequency</div>
      </div>

      <div id="timePanel" class="panel">
        <div id="plot"></div>
        <canvas id="heatCanvas" class="heat"></canvas>
        <div id="heatOverlay" class="overlayText" style="display:none"></div>
        <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
          <button id="timePlay" class="small-btn btn">Start</button>
          <button id="timeStop" class="small-btn">Stop</button>
          <button id="timePrev" class="small-btn">◀︎</button>
          <button id="timeNext" class="small-btn">▶︎</button>
          <label style="margin-left:8px" class="kv">FPS</label>
          <input id="fps" type="range" min="1" max="60" value="25" style="width:140px">
          <button id="recordBtn" class="small-btn btn" style="margin-left:auto">録画</button>
          <div id="recordStatus" class="kv" style="margin-left:8px"></div>
        </div>
        <input id="frameSlider" type="range" min="0" max="127" value="0" style="width:100%;margin-top:8px">
      </div>

      <div id="modePanel" class="panel" style="display:none">
        <div style="display:flex;gap:8px;margin-bottom:8px">
          <button id="modeStart" class="btn">Start</button>
          <button id="modeStop" class="btn" style="background:#9ca3af">Stop</button>
          <label style="margin-left:8px" class="kv">アニメフレーム</label>
          <input id="modeFrames" type="number" value="64" min="8" max="512" style="width:80px">
        </div>
        <canvas id="modeCanvas" class="modeCanvas"></canvas>
        <div id="modeOverlay" class="overlayText" style="display:none"></div>
        <div style="margin-top:8px" class="kv">解析モードと FDTD由来モードを比較できます（Frequency タブでピーク選択）。</div>
      </div>

      <div id="freqPanel" class="panel" style="display:none">
        <div style="display:flex;gap:8px">
          <div style="flex:1">
            <div style="display:flex;gap:8px;align-items:center">
              <button id="addProbeBtn" class="small-btn btn">プローブを追加(クリックで設置)</button>
              <button id="clearProbeBtn" class="small-btn">クリア</button>
              <label class="kv" style="margin-left:8px">平均</label><input type="checkbox" id="avgProbe">
              <label class="kv" style="margin-left:8px">upsample</label><input id="upsample" type="number" min="1" value="1" style="width:64px">
              <button id="doFFT" class="small-btn btn" style="margin-left:auto">FFT 実行</button>
            </div>
            <div class="probe-list" id="probeList" style="margin-top:8px"></div>
          </div>
          <div style="flex:1">
            <div id="fftPlot" style="height:260px"></div>
            <div id="peakList" class="kv" style="margin-top:8px"></div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
  function D_of(E,h,nu){ return E * Math.pow(h,3) / (12*(1 - nu*nu)); }
  function modalMass(rho,h,Lx,Ly){ return rho * h * (Lx*Ly) / 4.0; }
  function phi(m,n,x,y,Lx,Ly){ return Math.sin(m*Math.PI*x/Lx) * Math.sin(n*Math.PI*y/Ly); }
  function nextPow2(n){ let p=1; while(p<n) p*=2; return p; }
  const eps = 1e-20;

  function showError(msg){
    const el = $('errorBox');
    el.style.display = 'block';
    el.textContent = 'Error: ' + msg;
    console.error(msg);
  }
  window.addEventListener('error', function(e){ showError(e.message + ' (' + e.filename + ':' + e.lineno + ')'); });
  window.addEventListener('unhandledrejection', function(e){ showError('UnhandledRejection: ' + (e.reason && e.reason.message ? e.reason.message : String(e.reason))); });

  function to2D(arr,Nx,Ny){
    const z = new Array(Ny);
    for(let j=0;j<Ny;j++){
      const row = new Array(Nx);
      for(let i=0;i<Nx;i++) row[i] = arr[j*Nx + i];
      z[j]=row;
    }
    return z;
  }

  // DPR-aware resize for canvases
  function resizeCanvasForDisplay(canvas, displayW, displayH){
    const ratio = window.devicePixelRatio || 1;
    canvas.style.width = displayW + 'px';
    canvas.style.height = displayH + 'px';
    canvas.width = Math.max(1, Math.round(displayW * ratio));
    canvas.height = Math.max(1, Math.round(displayH * ratio));
    const ctx = canvas.getContext('2d');
    ctx.setTransform(ratio,0,0,ratio,0,0);
    // use crisp font sizes after transform
    ctx.font = '14px ui-sans-serif,system-ui';
    ctx.textBaseline = 'top';
    return ctx;
  }

  // draw grid array to canvas (ctx already DPR-transformed)
  function drawArrayToCanvas(arr,Nx,Ny,ctx,manualMin,manualMax){
    const dispW = parseFloat(ctx.canvas.style.width) || ctx.canvas.width;
    const dispH = parseFloat(ctx.canvas.style.height) || ctx.canvas.height;
    let mn = manualMin, mx = manualMax;
    if(mn===undefined || mx===undefined || !isFinite(mn) || !isFinite(mx)){
      mn = Infinity; mx = -Infinity; for(const v of arr){ if(v<mn) mn=v; if(v>mx) mx=v; } if(!isFinite(mn)){ mn=0; mx=1; }
    }
    const img = new ImageData(Nx,Ny);
    const span = (mx-mn)||1e-12;
    for(let j=0;j<Ny;j++){
      for(let i=0;i<Nx;i++){
        const v = arr[j*Nx + i]; const t = Math.max(0, Math.min(1, (v-mn)/span));
        const r = Math.round(68 + 187*t), g = Math.round(1 + 185*t), b = Math.round(84 + 40*(1-t));
        const p = (j*Nx + i)*4;
        img.data[p]=r; img.data[p+1]=g; img.data[p+2]=b; img.data[p+3]=255;
      }
    }
    const tmp = document.createElement('canvas');
    tmp.width = Nx; tmp.height = Ny;
    tmp.getContext('2d').putImageData(img,0,0);
    ctx.clearRect(0,0,dispW,dispH);
    ctx.drawImage(tmp, 0, 0, dispW, dispH);
  }

  // overlay draw (x,y,frame,time)
  function drawOverlayOnCanvas(ctx, xs, ys, ix, iy, frameIndex, dt){
    const dispW = parseFloat(ctx.canvas.style.width) || ctx.canvas.width;
    const dispH = parseFloat(ctx.canvas.style.height) || ctx.canvas.height;
    // draw semi-transparent box at top-left
    const padding = 6;
    const lines = [];
    if(frameIndex !== null && dt !== null) lines.push(`frame:${frameIndex} t:${(frameIndex*dt).toFixed(4)} s`);
    if(ix != null && iy != null){
      const x = xs[clamp(ix,0,xs.length-1)].toFixed(3);
      const y = ys[clamp(iy,0,ys.length-1)].toFixed(3);
      lines.push(`x:${x} m  y:${y} m`);
    }
    if(lines.length===0) return;
    const txt = lines.join('\n');
    // compute size
    const lineHeight = 16;
    const boxW = 200, boxH = lineHeight * lines.length + padding*2;
    ctx.fillStyle = 'rgba(255,255,255,0.75)';
    ctx.fillRect(8,8,boxW,boxH);
    ctx.fillStyle = '#000';
    ctx.font = '14px ui-sans-serif,system-ui';
    for(let i=0;i<lines.length;i++){
      ctx.fillText(lines[i], 12, 12 + i*lineHeight);
    }
  }

  // state
  let frames = null, lastResult = null, playInterval=null;
  let probes = [];
  let addingProbe=false;
  let recorder=null, recordedChunks=[];
  let lastHeatPointer = {ix:null,iy:null};
  let lastModePointer = {ix:null,iy:null};

  // tabs
  document.querySelectorAll('.tab').forEach(t=>{
    t.addEventListener('click', ()=> {
      document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
      t.classList.add('active');
      const tab = t.dataset.tab;
      $('timePanel').style.display = tab==='time' ? '' : 'none';
      $('modePanel').style.display = tab==='mode' ? '' : 'none';
      $('freqPanel').style.display = tab==='freq' ? '' : 'none';
    });
  });

  function buildModes(Lx,Ly,E,nu,rho,h,mmax,nmax){
    const D = D_of(E,h,nu);
    const modes=[];
    for(let m=1;m<=mmax;m++) for(let n=1;n<=nmax;n++){
      const k2 = Math.pow(m*Math.PI/Lx,2) + Math.pow(n*Math.PI/Ly,2);
      const omega = Math.sqrt(D/(rho*h)) * k2;
      modes.push({m,n,omega,f:omega/(2*Math.PI)});
    }
    modes.sort((a,b)=>a.f-b.f);
    return modes;
  }

  function populateModeList(modes){
    const div = $('modeList'); div.innerHTML='';
    modes.forEach((md,idx)=>{
      const el = document.createElement('div'); el.style.padding='6px'; el.style.borderBottom='1px solid #f1f5f9'; el.style.cursor='pointer';
      el.textContent = `#${idx+1} (m,n)=(${md.m},${md.n}) f=${md.f.toFixed(2)} Hz`;
      el.onclick = ()=> {
        Array.from(div.children).forEach(x=>x.style.background='');
        el.style.background='#eef6ff';
        $('freq').value = md.f.toFixed(6);
        startModeAnimation(md);
      };
      div.appendChild(el);
    });
  }

  function computeStaticField(opts){
    const {Lx,Ly,E,nu,rho,h,modes,mmax,nmax,freq,x0,y0,Ngrid,displayChoice,useDbStatic} = opts;
    const omega = 2*Math.PI*(freq||0);
    const Mmn = modalMass(rho,h,Lx,Ly);
    const Nx = Ngrid, Ny = Ngrid;
    const xs = new Array(Nx); const ys = new Array(Ny);
    for(let i=0;i<Nx;i++) xs[i] = Lx * i/(Nx-1);
    for(let j=0;j<Ny;j++) ys[j] = Ly * j/(Ny-1);
    const W = new Array(Ny*Nx).fill(0).map(()=>({re:0,im:0}));
    const F = 1.0;
    const Q = 1e8;
    for(const md of modes){
      if(md.m>mmax || md.n>nmax) continue;
      const omega_m = md.omega;
      const phi0 = phi(md.m,md.n,x0,y0,Lx,Ly);
      const num = {re: F * phi0, im: 0};
      const real = Mmn * (omega_m*omega_m - omega*omega);
      const imag = Mmn * (omega * omega_m / Q);
      const d = real*real + imag*imag || 1e-30;
      const eta = { re: (num.re*real + num.im*imag)/d, im: (num.im*real - num.re*imag)/d };
      for(let j=0;j<Ny;j++){
        const cy = Math.sin(md.n * Math.PI * ys[j] / Ly);
        for(let i=0;i<Nx;i++){
          const cx = Math.sin(md.m * Math.PI * xs[i] / Lx);
          const idx = j*Nx + i;
          const ph = cx * cy;
          W[idx].re += eta.re * ph;
          W[idx].im += eta.im * ph;
        }
      }
    }
    const V = new Float64Array(Ny*Nx);
    for(let k=0;k<W.length;k++) V[k] = (omega===0 ? Math.hypot(W[k].re, W[k].im) : omega * Math.hypot(W[k].re, W[k].im));
    const out = new Float64Array(Ny*Nx);
    if(displayChoice === 'v_over_F') for(let k=0;k<out.length;k++) out[k] = V[k]; else for(let k=0;k<out.length;k++) out[k] = (V[k]>0?1.0/V[k]:0);
    if(useDbStatic){
      for(let k=0;k<out.length;k++) out[k] = 10 * Math.log10(Math.max(out[k], eps));
    }
    return {xs,ys,Z:out,rawV:V};
  }

  // FDTD transient (chunked)
  let abortFlag=false;
  function computeTransient(cfg, onProgress, onDone){
    abortFlag=false;
    const Lx = cfg.Lx, Ly=cfg.Ly;
    let Nx = cfg.Ngrid, Ny = cfg.Ngrid;
    if(cfg.dx && cfg.dx>0){ Nx = Math.ceil(Math.max(Lx,Ly)/cfg.dx)+1; Ny = Math.ceil(Math.max(Lx,Ly)/cfg.dx)+1; }
    Nx = Math.max(16, Nx); Ny = Nx;
    const size = Nx*Ny;
    const E=cfg.E, nu=cfg.nu, rho=cfg.rho, h=cfg.h;
    const D = D_of(E,h,nu);
    const marea = rho*h;
    const dx = Math.min(Lx/(Nx-1), Ly/(Ny-1));
    const Cstab=0.25;
    const dt_stab = Cstab * dx*dx * Math.sqrt(marea / (D||1e-30));
    const fmax = Math.min(cfg.fmax||250, 250);
    const dt_res = 1.0 / (cfg.samplesPerCycle * Math.max(1,fmax));
    const dt = Math.min(dt_stab, dt_res);
    const coeff = (dt*dt)/marea;
    const framesCount = cfg.frames;
    const framesBuf = new Array(framesCount);
    let w = new Float32Array(size), wprev = new Float32Array(size), wnext = new Float32Array(size);
    const sx = clamp(Math.round(cfg.x0 / Lx * (Nx-1)), 1, Nx-2);
    const sy = clamp(Math.round(cfg.y0 / Ly * (Ny-1)), 1, Ny-2);
    const src = sy*Nx + sx;
    const forceSteps = Math.max(1, Math.floor(0.002 / Math.max(dt,1e-12)));
    const idx = (i,j)=> j*Nx + i;

    function lap(arr){
      const out = new Float32Array(size);
      for(let j=1;j<Ny-1;j++){
        for(let i=1;i<Nx-1;i++){
          const id = idx(i,j);
          out[id] = (arr[id-1] + arr[id+1] + arr[id-Nx] + arr[id+Nx] - 4*arr[id])/(dx*dx);
        }
      }
      return out;
    }
    function bih(arr){
      const lap1 = lap(arr); const out = new Float32Array(size);
      for(let j=2;j<Ny-2;j++){
        for(let i=2;i<Nx-2;i++){
          const id = idx(i,j);
          out[id] = (lap1[id-1] + lap1[id+1] + lap1[id-Nx] + lap1[id+Nx] - 4*lap1[id])/(dx*dx);
        }
      }
      return out;
    }
    function enforceSS(a){
      for(let i=0;i<Nx;i++){ a[idx(i,0)]=0; a[idx(i,Ny-1)]=0; }
      for(let j=0;j<Ny;j++){ a[idx(0,j)]=0; a[idx(Nx-1,j)]=0; }
    }

    let step=0; const chunk=4;
    function runChunk(){
      if(abortFlag){ onProgress(0,'中断'); return; }
      const end = Math.min(framesCount, step + chunk);
      for(; step<end; step++){
        const F = new Float32Array(size);
        if(step < forceSteps) F[src]=1.0;
        const bihf = bih(w);
        for(let id=0; id<size; id++){
          wnext[id] = 2*w[id] - wprev[id] + coeff * (F[id] - D * bihf[id]);
        }
        enforceSS(wnext);
        wprev.set(w); w.set(wnext);
        framesBuf[step] = w.slice(0);
      }
      onProgress(Math.round(100*step/framesCount), `step ${step}/${framesCount}`);
      if(step < framesCount) setTimeout(runChunk, 8); else onDone({frames:framesBuf,Nx,Ny,dt,Fs:1/Math.max(dt,1e-12)});
    }
    runChunk();
    return { cancel: ()=>{ abortFlag=true; } };
  }

  // compute button
  $('computeBtn').addEventListener('click', ()=>{
    try{
      if($('material_preset').value==='concrete'){ $('E').value=30000000000; $('nu').value=0.2; $('rho').value=2400; }
      else if($('material_preset').value==='steel'){ $('E').value=210000000000; $('nu').value=0.3; $('rho').value=7850; }
      const E=parseFloat($('E').value), nu=parseFloat($('nu').value), rho=parseFloat($('rho').value), h=parseFloat($('h').value);
      const Lx=parseFloat($('Lx').value), Ly=parseFloat($('Ly').value);
      let Ngrid=parseInt($('Ngrid').value); const dx_in=parseFloat($('dx').value)||0;
      if(dx_in>0){ Ngrid = Math.ceil(Math.max(Lx,Ly)/dx_in)+1; Ngrid=Math.max(16,Ngrid); }
      const framesCount = parseInt($('framesCount').value);
      const samplesPerCycle = parseInt($('samplesPerCycle').value);
      const mmax=parseInt($('mmax').value), nmax=parseInt($('nmax').value);
      const preset = $('sourcePreset_preset').value;
      if(preset==='center'){ $('x0').value=(Lx/2).toFixed(3); $('y0').value=(Ly/2).toFixed(3); }
      else if(preset==='diag_1_3'){ $('x0').value=(Lx/3).toFixed(3); $('y0').value=(Ly/3).toFixed(3); }
      else if(preset==='diag_2_3'){ $('x0').value=(2*Lx/3).toFixed(3); $('y0').value=(2*Ly/3).toFixed(3); }
      const x0=clamp(parseFloat($('x0').value),0,Lx), y0=clamp(parseFloat($('y0').value),0,Ly);
      const modes = buildModes(Lx,Ly,E,nu,rho,h,mmax,nmax); populateModeList(modes);
      $('progressFill').style.width='0%'; $('progressText').textContent='計算中...';

      const workerHandle = computeTransient({E,nu,rho,h,Lx,Ly,Ngrid,frames:framesCount,samplesPerCycle,fmax:250,x0,y0}, (p,msg)=>{
        $('progressFill').style.width = p+'%'; $('progressText').textContent = msg|| (p+'%');
      }, (res)=>{
        frames = res.frames;
        lastResult = {frames, Nx:res.Nx, Ny:res.Ny, dt:res.dt, Fs:res.Fs, xs: Array.from({length:res.Nx},(_,i)=>i/(res.Nx-1)*Lx), ys: Array.from({length:res.Ny},(_,j)=>j/(res.Ny-1)*Ly)};
        $('progressText').textContent = `完了 frames=${frames.length} Nx=${res.Nx} dt=${res.dt.toExponential(2)}s`;
        // static field
        const freqVal = $('freq').value ? parseFloat($('freq').value) : modes[0].f;
        const displayEl = document.getElementById('displayPreset');
        const displayChoiceVal = displayEl ? displayEl.value : 'v_over_F';
        const useDbStaticChecked = document.getElementById('useDbStatic') ? document.getElementById('useDbStatic').checked : false;
        const staticField = computeStaticField({Lx,Ly,E,nu,rho,h,modes,mmax,nmax,freq:freqVal,x0,y0,Ngrid:res.Nx,displayChoice:displayChoiceVal,useDbStatic:useDbStaticChecked});
        const z2d = to2D(staticField.Z, res.Nx, res.Ny);

        // compute display sizes using physical aspect ratio Lx:Ly
        const displayW = Math.min(1200, window.innerWidth - 420);
        const displayH = Math.max(160, Math.min(900, Math.round(displayW * (Ly / Lx)))); // keep reasonable caps

        try{
          Plotly.newPlot('plot', [{ z: z2d, x: lastResult.xs, y: lastResult.ys, type: 'heatmap', colorscale: 'Viridis' }], {
            margin:{t:10,b:40,l:60,r:10}, xaxis:{title:'x [m]'}, yaxis:{title:'y [m]'},
            height: displayH
          }, {responsive:true,displaylogo:false});
        }catch(e){
          showError('Plotly plot failed: '+ (e && e.message ? e.message : String(e)));
        }

        // heatCanvas sizing and first-frame draw (DPR-aware) using Lx/Ly aspect
        const heatCanvas = $('heatCanvas');
        const ctx = resizeCanvasForDisplay(heatCanvas, displayW, displayH);
        drawArrayToCanvas(frames[0], res.Nx, res.Ny, ctx);
        // set overlay visible and initialize
        $('heatOverlay').style.display = '';
        $('heatOverlay').style.left = (heatCanvas.getBoundingClientRect().left + 8) + 'px';
        $('heatOverlay').style.top = (heatCanvas.getBoundingClientRect().top + 8) + 'px';
        // ensure frame slider sync
        $('frameSlider').max = frames.length-1; $('frameSlider').value = 0;
        // draw overlay info
        renderFrame(0);
      });

      $('abortBtn').onclick = ()=>{ if(workerHandle && workerHandle.cancel) workerHandle.cancel(); $('progressText').textContent='キャンセル済み'; };
    }catch(err){
      showError('compute start failed: ' + (err && err.message ? err.message : String(err)));
    }
  });

  // frame playback controls
  let currentFrame=0;
  function renderFrame(i){
    if(!lastResult) return;
    const heatCanvas = $('heatCanvas');
    const ctx = heatCanvas.getContext('2d');
    const Nx = lastResult.Nx, Ny = lastResult.Ny;
    if(i<0) i=0; if(i>=lastResult.frames.length) i=lastResult.frames.length-1;
    drawArrayToCanvas(lastResult.frames[i], Nx, Ny, ctx);
    // overlay: use lastHeatPointer if available, else center
    let ix = lastHeatPointer.ix, iy = lastHeatPointer.iy;
    if(ix==null || iy==null){ ix = Math.floor(Nx/2); iy = Math.floor(Ny/2); }
    drawOverlayOnCanvas(ctx, lastResult.xs, lastResult.ys, ix, iy, i, lastResult.dt);
    $('frameSlider').value = i;
  }

  $('frameSlider').addEventListener('input', (e)=> { const v = parseInt(e.target.value); currentFrame=v; renderFrame(v); });
  $('timePlay').addEventListener('click', ()=> {
    if(!lastResult){ alert('まず計算してください'); return; }
    if(playInterval) clearInterval(playInterval);
    const fps = parseInt($('fps').value) || 25;
    playInterval = setInterval(()=> {
      currentFrame = (currentFrame + 1) % lastResult.frames.length;
      renderFrame(currentFrame);
    }, 1000/Math.max(1,fps));
  });
  $('timeStop').addEventListener('click', ()=> { if(playInterval) clearInterval(playInterval); playInterval=null; });
  $('timePrev').addEventListener('click', ()=> { if(!lastResult) return; currentFrame = Math.max(0, currentFrame-1); renderFrame(currentFrame); });
  $('timeNext').addEventListener('click', ()=> { if(!lastResult) return; currentFrame = Math.min(lastResult.frames.length-1, currentFrame+1); renderFrame(currentFrame); });

  // recording
  $('recordBtn').addEventListener('click', async ()=>{
    const canvas = $('heatCanvas');
    if(!canvas) return;
    try{
      const stream = canvas.captureStream(25);
      recordedChunks = [];
      if(typeof MediaRecorder === 'undefined'){ alert('このブラウザは MediaRecorder をサポートしていません'); return; }
      recorder = new MediaRecorder(stream,{mimeType:'video/webm;codecs=vp9'});
      recorder.ondataavailable = e=>{ if(e.data.size) recordedChunks.push(e.data); };
      recorder.onstop = ()=> {
        const blob = new Blob(recordedChunks,{type:'video/webm'});
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `slab_${Date.now()}.webm`; a.click();
        $('recordStatus').textContent = '保存済';
      };
      recorder.start();
      $('recordStatus').textContent = '録画中...';
      setTimeout(()=>{ if(recorder && recorder.state==='recording') { recorder.stop(); $('recordStatus').textContent='終了'; } }, 10000);
    }catch(err){ showError('録画に失敗しました: '+ (err && err.message ? err.message : String(err))); }
  });

  // Mode animation (looping) — DPR-aware sizing and overlay
  let modeAnimId=null, currentMode=null, modeStopFlag=false;
  function startModeAnimation(mode){
    stopModeAnimation();
    currentMode = mode;
    const canvas = $('modeCanvas');
    const displayW = canvas.clientWidth || Math.min(800, window.innerWidth - 420);
    // keep mode canvas aspect same as Lx/Ly
    const Lx = parseFloat($('Lx').value), Ly = parseFloat($('Ly').value);
    const displayH = Math.max(160, Math.min(900, Math.round(displayW * (Ly / Lx))));
    const ctx = resizeCanvasForDisplay(canvas, displayW, displayH);
    $('modeOverlay').style.display = '';
    const Ngrid = parseInt($('Ngrid').value);
    const Nx = Ngrid, Ny = Ngrid;
    const xs = new Array(Nx), ys = new Array(Ny);
    for(let i=0;i<Nx;i++) xs[i]=Lx*i/(Nx-1);
    for(let j=0;j<Ny;j++) ys[j]=Ly*j/(Ny-1);
    const phiArr = new Float64Array(Nx*Ny); let maxabs=0;
    for(let j=0;j<Ny;j++) for(let i=0;i<Nx;i++){ const v = Math.sin(mode.m*Math.PI*xs[i]/Lx) * Math.sin(mode.n*Math.PI*ys[j]/Ly); phiArr[j*Nx+i]=v; if(Math.abs(v)>maxabs) maxabs=Math.abs(v); }
    if(maxabs===0) maxabs=1; for(let k=0;k<phiArr.length;k++) phiArr[k]/=maxabs;
    const framesLocal = parseInt($('modeFrames').value) || 64;
    let f=0; modeStopFlag=false;
    function step(){
      if(modeStopFlag) return;
      const t = f/framesLocal;
      const cosv = Math.cos(2*Math.PI * t);
      const arr = new Float32Array(Nx*Ny);
      let mn=Infinity,mx=-Infinity;
      for(let k=0;k<phiArr.length;k++){ arr[k]=phiArr[k]*cosv; if(arr[k]<mn) mn=arr[k]; if(arr[k]>mx) mx=arr[k]; }
      drawArrayToCanvas(arr,Nx,Ny,ctx,mn,mx);
      // overlay: pointer if exists
      let ix = lastModePointer.ix, iy = lastModePointer.iy;
      if(ix==null || iy==null){ ix = Math.floor(Nx/2); iy = Math.floor(Ny/2); }
      drawOverlayOnCanvas(ctx, xs, ys, ix, iy, f, 1.0/ (mode.omega ? mode.omega/(2*Math.PI) : 1.0));
      f = (f+1) % framesLocal;
      modeAnimId = requestAnimationFrame(step);
    }
    modeAnimId = requestAnimationFrame(step);
  }
  function stopModeAnimation(){ modeStopFlag=true; if(modeAnimId) cancelAnimationFrame(modeAnimId); modeAnimId=null; }

  $('modeStart').addEventListener('click', ()=> { if(currentMode) startModeAnimation(currentMode); else {
    const modes = buildModes(parseFloat($('Lx').value),parseFloat($('Ly').value),parseFloat($('E').value),parseFloat($('nu').value),parseFloat($('rho').value),parseFloat($('h').value),parseInt($('mmax').value),parseInt($('nmax').value));
    startModeAnimation(modes[0]);
  }});
  $('modeStop').addEventListener('click', ()=> stopModeAnimation());

  // Probe handling on heatCanvas - tap to add (iPad pointer events)
  const heatCanvas = $('heatCanvas');
  heatCanvas.addEventListener('pointermove', (ev)=> {
    if(!lastResult) return;
    const rect = heatCanvas.getBoundingClientRect();
    const cx = ev.clientX - rect.left, cy = ev.clientY - rect.top;
    const ix = Math.floor(cx / rect.width * lastResult.Nx);
    const iy = Math.floor(cy / rect.height * lastResult.Ny);
    lastHeatPointer.ix = clamp(ix,0,lastResult.Nx-1);
    lastHeatPointer.iy = clamp(iy,0,lastResult.Ny-1);
    renderFrame(currentFrame); // redraw overlay
  });
  heatCanvas.addEventListener('pointerdown',(ev)=> {
    if(addingProbe){
      if(!lastResult){ alert('まず計算してください'); addingProbe=false; $('addProbeBtn').textContent='プローブを追加(クリックで設置)'; return; }
      const rect = heatCanvas.getBoundingClientRect();
      const cx = ev.clientX - rect.left, cy = ev.clientY - rect.top;
      const ix = Math.floor(cx / rect.width * lastResult.Nx);
      const iy = Math.floor(cy / rect.height * lastResult.Ny);
      const x = lastResult.xs[clamp(ix,0,lastResult.Nx-1)] || 0, y = lastResult.ys[clamp(iy,0,lastResult.Ny-1)] || 0;
      probes.push({ix:clamp(ix,0,lastResult.Nx-1),iy:clamp(iy,0,lastResult.Ny-1),x,y,vals:null});
      renderProbeList();
      addingProbe=false; $('addProbeBtn').textContent='プローブを追加(クリックで設置)';
    }
  });

  $('addProbeBtn').addEventListener('click', ()=> {
    if(!lastResult){ alert('まず計算してください'); return; }
    addingProbe = true; $('addProbeBtn').textContent='タップで設置中...';
  });
  $('clearProbeBtn').addEventListener('click', ()=> { probes=[]; renderProbeList(); $('fftPlot').innerHTML=''; $('peakList').innerHTML=''; });

  function renderProbeList(){
    const div = $('probeList'); div.innerHTML='';
    probes.forEach((p,i)=>{
      const el = document.createElement('div'); el.style.display='flex'; el.style.justifyContent='space-between'; el.style.padding='6px';
      el.innerHTML = `<div>p${i+1}: (${p.x.toFixed(2)},${p.y.toFixed(2)})</div><div><button data-i="${i}" class="small-btn">削除</button></div>`;
      div.appendChild(el);
    });
    div.querySelectorAll('button').forEach(b=> b.addEventListener('click', (e)=> {
      const i = parseInt(b.dataset.i); probes.splice(i,1); renderProbeList();
    }));
  }

  // FFT pipeline (simple DFT) - ensure Nfft used in angle, freqs consistent
  function hann(winN){ const w = new Float64Array(winN); for(let n=0;n<winN;n++) w[n]=0.5*(1-Math.cos(2*Math.PI*n/(winN-1))); return w;}
  function doFFT(){
    try{
      if(!lastResult){ alert('まず計算して frames を取得してください'); return; }
      if(probes.length===0){ alert('プローブを追加してください'); return; }
      const Fs = lastResult.Fs, dt = lastResult.dt;
      const T = lastResult.frames.length;
      const win = hann(T);
      const up = Math.max(1, parseInt($('upsample').value)||1);
      const Nfft = nextPow2(Math.max(64, up*T));
      const freqs = new Float64Array(Nfft/2);
      for(let k=0;k<freqs.length;k++) freqs[k] = k * (Fs / Nfft);
      const vmat = [];
      for(const p of probes){
        const vals = new Float64Array(T);
        for(let t=0;t<T;t++) vals[t]=lastResult.frames[t][p.iy*lastResult.Nx + p.ix];
        const v = new Float64Array(T);
        for(let t=0;t<T;t++){
          if(t===0) v[t] = (vals[1]-vals[0]) / dt;
          else if(t===T-1) v[t] = (vals[T-1]-vals[T-2]) / dt;
          else v[t] = (vals[t+1]-vals[t-1]) / (2*dt);
        }
        for(let t=0;t<T;t++) v[t] *= win[t];
        vmat.push(v);
      }
      let vavg = new Float64Array(T);
      if($('avgProbe').checked){
        for(let t=0;t<T;t++){ let s=0; for(let i=0;i<vmat.length;i++) s+=vmat[i][t]; vavg[t]=s/vmat.length; }
      }
      const series = $('avgProbe').checked ? [vavg] : vmat;
      const spectra = [];
      for(const s of series){
        const outRe = new Float64Array(Nfft/2);
        const outIm = new Float64Array(Nfft/2);
        // DFT: sum over n=0..T-1 but angles use Nfft for correct freq sampling (zero-padding implied)
        for(let k=0;k<Nfft/2;k++){
          let re=0,im=0;
          for(let n=0;n<T;n++){
            const angle = -2*Math.PI * k * n / Nfft;
            re += s[n] * Math.cos(angle);
            im += s[n] * Math.sin(angle);
          }
          outRe[k]=re; outIm[k]=im;
        }
        const mag = new Float64Array(Nfft/2);
        for(let k=0;k<Nfft/2;k++) mag[k] = Math.sqrt(outRe[k]*outRe[k] + outIm[k]*outIm[k]) / T;
        spectra.push({re:outRe,im:outIm,mag});
      }
      const freqArr = Array.from(freqs);
      const magDb = Array.from(spectra[0].mag).map(v => 20*Math.log10(Math.max(v, eps)));
      const trace = { x: freqArr, y: magDb, mode:'lines', type:'scatter' };
      const layout = { xaxis:{type:'log',title:'Hz'}, yaxis:{title:'dB (20·log10)', autorange:true}, margin:{t:10,b:40} };
      Plotly.newPlot('fftPlot',[trace],layout,{responsive:true,displaylogo:false});
      // peak detection simple local maxima + threshold
      const peaks = [];
      const mvals = spectra[0].mag;
      const maxv = Math.max.apply(null, mvals);
      const thresh = maxv * 0.15;
      for(let k=2;k<mvals.length-2;k++){
        if(mvals[k] > mvals[k-1] && mvals[k] > mvals[k+1] && mvals[k] > thresh){
          peaks.push({f:freqs[k], ampDb:20*Math.log10(Math.max(mvals[k],eps)), idx:k});
        }
      }
      const peakDiv = $('peakList'); peakDiv.innerHTML = '<strong>Peaks</strong><br>';
      peaks.slice(0,10).forEach(p=>{
        const btn = document.createElement('button'); btn.textContent = `${p.f.toFixed(2)} Hz (${p.ampDb.toFixed(1)} dB)`; btn.className='small-btn';
        btn.addEventListener('click', ()=> { showModeMapFromFFT(p.idx, spectra[0], freqs, Nfft); });
        peakDiv.appendChild(btn);
        peakDiv.appendChild(document.createTextNode(' '));
      });
    }catch(err){
      showError('FFT failed: ' + (err && err.message ? err.message : String(err)));
    }
  }

  function showModeMapFromFFT(idx, spectrum, freqs, Nfft){
    if(!lastResult) return;
    const T = lastResult.frames.length;
    const Nx = lastResult.Nx, Ny = lastResult.Ny;
    const reMap = new Float64Array(Nx*Ny);
    const imMap = new Float64Array(Nx*Ny);
    // Use same angle convention as FFT (Nfft)
    for(let j=0;j<Ny;j++){
      for(let i=0;i<Nx;i++){
        let re=0,im=0;
        for(let t=0;t<T;t++){
          const wv = lastResult.frames[t][j*Nx + i];
          const angle = -2*Math.PI * idx * t / Nfft;
          re += wv * Math.cos(angle);
          im += wv * Math.sin(angle);
        }
        const id=j*Nx+i; reMap[id]=re; imMap[id]=im;
      }
    }
    const amp = new Float64Array(Nx*Ny);
    let mx=0;
    for(let k=0;k<amp.length;k++){ amp[k]=Math.hypot(reMap[k],imMap[k]); if(amp[k]>mx) mx=amp[k]; }
    if(mx===0) mx=1;
    const norm = new Float64Array(amp.length);
    for(let k=0;k<amp.length;k++) norm[k]=amp[k]/mx;
    // switch to mode tab and plot normalized map with proper aspect
    document.querySelectorAll('.tab').forEach(x=>x.classList.remove('active'));
    document.querySelector('.tab[data-tab="mode"]').classList.add('active');
    $('timePanel').style.display='none'; $('freqPanel').style.display='none'; $('modePanel').style.display='';
    const z2d = to2D(norm, Nx, Ny);
    // determine display size using physical aspect
    const Lx = parseFloat($('Lx').value), Ly = parseFloat($('Ly').value);
    const displayW = Math.min(1200, window.innerWidth - 420);
    const displayH = Math.max(160, Math.min(900, Math.round(displayW * (Ly / Lx))));
    Plotly.newPlot('plot', [{ z: z2d, x: lastResult.xs, y: lastResult.ys, type: 'heatmap', colorscale: 'Viridis' }], {
      margin:{t:10,b:40,l:60,r:10}, xaxis:{title:'x [m]'}, yaxis:{title:'y [m]'}, height: displayH
    }, {responsive:true,displaylogo:false});
  }

  $('doFFT').addEventListener('click', ()=> doFFT());

  // render initial static field on load
  (function initial(){
    try{
      const E=parseFloat($('E').value), nu=parseFloat($('nu').value), rho=parseFloat($('rho').value), h=parseFloat($('h').value);
      const Lx=parseFloat($('Lx').value), Ly=parseFloat($('Ly').value);
      const mmax=parseInt($('mmax').value), nmax=parseInt($('nmax').value), Ngrid=parseInt($('Ngrid').value);
      const modes = buildModes(Lx,Ly,E,nu,rho,h,mmax,nmax);
      populateModeList(modes);
      const freq = modes[0].f;
      const useDbStaticChecked = document.getElementById('useDbStatic') ? document.getElementById('useDbStatic').checked : false;
      const staticField = computeStaticField({Lx,Ly,E,nu,rho,h,modes,mmax,nmax,freq,x0:Lx/2,y0:Ly/2,Ngrid,displayChoice:'v_over_F',useDbStatic:useDbStaticChecked});
      const displayW = Math.min(1200, window.innerWidth - 420);
      const displayH = Math.max(160, Math.min(900, Math.round(displayW * (Ly / Lx))));
      Plotly.newPlot('plot', [{z:to2D(staticField.Z,Ngrid,Ngrid), x:staticField.xs, y:staticField.ys, type:'heatmap', colorscale:'Viridis'}], {margin:{t:10,b:40,l:60,r:10}, height: displayH}, {responsive:true,displaylogo:false});
      const heatCanvas = $('heatCanvas');
      const ctx = resizeCanvasForDisplay(heatCanvas, displayW, displayH);
      drawArrayToCanvas(staticField.Z, Ngrid, Ngrid, ctx);
      $('heatOverlay').style.display = '';
      // pointer handlers for mode canvas overlay
      const modeCanvas = $('modeCanvas');
      modeCanvas.addEventListener('pointermove',(ev)=>{
        const rect = modeCanvas.getBoundingClientRect();
        const cx = ev.clientX - rect.left, cy = ev.clientY - rect.top;
        const NgridLocal = parseInt($('Ngrid').value);
        const ix = Math.floor(cx / rect.width * NgridLocal);
        const iy = Math.floor(cy / rect.height * NgridLocal);
        lastModePointer.ix = clamp(ix,0,NgridLocal-1);
        lastModePointer.iy = clamp(iy,0,NgridLocal-1);
      });
    }catch(err){
      showError('initial render failed: ' + (err && err.message ? err.message : String(err)));
    }
  })();

  // window resize handling: update Plotly height and canvas sizes, then redraw current frame/mode
  window.addEventListener('resize', ()=> {
    try{
      const Lx = parseFloat($('Lx').value), Ly = parseFloat($('Ly').value);
      const displayW = Math.min(1200, window.innerWidth - 420);
      const displayH = Math.max(160, Math.min(900, Math.round(displayW * (Ly / Lx))));
      // update Plotly height
      try{ Plotly.relayout('plot', {height: displayH}); }catch(e){}
      // resize heatCanvas and redraw
      if(lastResult){
        const heatCanvas = $('heatCanvas');
        const ctx = resizeCanvasForDisplay(heatCanvas, displayW, displayH);
        drawArrayToCanvas(lastResult.frames[currentFrame], lastResult.Nx, lastResult.Ny, ctx);
        drawOverlayOnCanvas(ctx, lastResult.xs, lastResult.ys, lastHeatPointer.ix, lastHeatPointer.iy, currentFrame, lastResult.dt);
      } else {
        // initial static
        const heatCanvas = $('heatCanvas');
        const ctx = resizeCanvasForDisplay(heatCanvas, displayW, displayH);
      }
      // resize mode canvas
      const modeCanvas = $('modeCanvas');
      const mctx = resizeCanvasForDisplay(modeCanvas, Math.min(1200, window.innerWidth - 420), Math.max(160, Math.min(900, Math.round(displayW * (Ly / Lx)))));
    }catch(e){
      // swallow
    }
  });

})();
</script>
</body>
</html>
