<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Slab FDTD — Preset Polygons (3–8 sides)</title>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
:root{--bg:#f7f8fb;--card:#fff;--ink:#0f172a;--muted:#475569;--accent:#2563eb}
body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,system-ui,Segoe UI,Roboto,"Noto Sans JP"}
.wrap{max-width:1200px;margin:12px auto;padding:12px}
.grid{display:grid;grid-template-columns:380px 1fr;gap:12px}
.card{background:var(--card);padding:12px;border-radius:10px;border:1px solid #e6edf3}
label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
input,select,button{width:100%;padding:8px;border-radius:8px;border:1px solid #e6edf3;margin-bottom:8px;box-sizing:border-box}
.modeToggle{display:flex;gap:8px;margin-bottom:8px}
.modeToggle button{flex:1;padding:8px;border-radius:8px;border:1px solid #cbd5e1;background:#fff;cursor:pointer}
.modeToggle button.active{background:#eef6ff;border-color:var(--accent)}
#drawCanvas{width:100%;height:220px;border-radius:6px;background:#fff;touch-action:none}
#heatCanvas{width:100%;height:480px;background:#fff;display:block;border-radius:6px}
.small{font-size:13px;color:var(--muted)}
.inline{display:flex;gap:8px}
.controls-row{display:flex;gap:8px;align-items:center}
.playbar{display:flex;gap:8px;align-items:center}
</style>
</head>
<body>
<div class="wrap">
  <h2>Slab FDTD — 描画プリセット：三角形〜八角形</h2>
  <div class="grid">
    <div class="card">
      <div><strong>描画モード</strong></div>
      <div class="modeToggle">
        <button id="modeVertex">Vertex</button>
        <button id="modeFree" class="active">Freehand</button>
      </div>

      <canvas id="drawCanvas" width=800 height=360></canvas>

      <div class="inline">
        <button id="clearBtn">Clear</button>
        <button id="closeBtn">Close (vertex)</button>
        <button id="smoothFillBtn">Smooth & Fill</button>
        <button id="rectBtn">Full Rect</button>
      </div>

      <div style="margin-top:8px">
        <label>プリセット多角形（中心・回転0）</label>
        <div style="display:flex;gap:8px">
          <select id="presetPolygon">
            <option value="3">Triangle (3)</option>
            <option value="4">Square (4)</option>
            <option value="5">Pentagon (5)</option>
            <option value="6">Hexagon (6)</option>
            <option value="7">Heptagon (7)</option>
            <option value="8" selected>Octagon (8)</option>
          </select>
          <button id="applyPreset">Apply</button>
        </div>
        <div class="small">プリセットはキャンバス中央に正多角形を生成します。サイズはキャンバスに合わせ自動調整。</div>
      </div>

      <hr/>
      <div><strong>（省略）その他 UI — 解析 / Run / Playback / FFT は既存実装と同等</strong></div>
      <div style="height:8px"></div>

      <div class="controls-row">
        <div style="flex:1"><label>Lx [m]</label><input id="Lx" type="number" step="0.01" value="5.00"></div>
        <div style="flex:1"><label>Ly [m]</label><input id="Ly" type="number" step="0.01" value="4.00"></div>
      </div>
      <div class="controls-row">
        <div style="flex:1"><label>Material</label>
          <select id="material">
            <option value="concrete">Concrete</option>
            <option value="light">Light</option>
            <option value="custom">Custom</option>
          </select>
        </div>
        <div style="flex:1"><label>h [m]</label><input id="h" type="number" step="0.01" value="0.15"></div>
      </div>

      <div class="controls-row">
        <div style="flex:1"><label>Ngrid</label><input id="Ngrid" type="number" value="64" min="24" max="160"></div>
        <div style="flex:1"><label>Frames (saved)</label><input id="Nframes" type="number" value="96" min="8" max="512"></div>
      </div>

      <div class="inline">
        <button id="runBtn">Run</button>
        <button id="stopBtn">Stop</button>
        <button id="snapshotBtn">Snapshot PNG</button>
      </div>

      <div style="margin-top:10px" class="small">Freehandで描いてSmooth & FillでもOK。プリセットは迅速に形を作るためのボタンです。</div>
    </div>

    <div class="card">
      <canvas id="heatCanvas" width=800 height=480></canvas>
      <div id="plotFFT" style="height:200px;margin-top:10px"></div>
    </div>
  </div>
</div>

<script>
/* --- utilities --- */
const $ = id => document.getElementById(id);
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

/* --- canvas drawing (freehand + vertex) --- */
const canvas = $('drawCanvas'), dctx = canvas.getContext('2d');
let mode = 'free';
$('modeVertex').onclick = ()=>{ mode='vertex'; $('modeVertex').classList.add('active'); $('modeFree').classList.remove('active'); };
$('modeFree').onclick = ()=>{ mode='free'; $('modeFree').classList.add('active'); $('modeVertex').classList.remove('active'); };

let vertices = [], closed=false, freePath=[] , isDrawing=false, mask=null;
function redraw(){
  dctx.clearRect(0,0,canvas.width,canvas.height);
  dctx.fillStyle='#fff'; dctx.fillRect(0,0,canvas.width,canvas.height);
  if(freePath.length>0){
    dctx.strokeStyle='#e11'; dctx.lineWidth=2; dctx.beginPath();
    dctx.moveTo(freePath[0][0], freePath[0][1]);
    for(let i=1;i<freePath.length;i++) dctx.lineTo(freePath[i][0], freePath[i][1]);
    dctx.stroke();
  }
  if(vertices.length>0){
    dctx.strokeStyle='#2563eb'; dctx.lineWidth=2; dctx.beginPath();
    dctx.moveTo(vertices[0][0], vertices[0][1]);
    for(let i=1;i<vertices.length;i++) dctx.lineTo(vertices[i][0], vertices[i][1]);
    if(closed) dctx.closePath();
    dctx.stroke();
    for(const p of vertices){ dctx.fillStyle='#2563eb'; dctx.beginPath(); dctx.arc(p[0],p[1],3,0,Math.PI*2); dctx.fill(); }
  }
}
canvas.addEventListener('pointerdown', (ev)=>{
  const r = canvas.getBoundingClientRect();
  const x = ev.clientX - r.left, y = ev.clientY - r.top;
  if(mode==='free'){ isDrawing=true; freePath.push([x,y]); canvas.setPointerCapture(ev.pointerId); }
  else { if(!closed) { vertices.push([x,y]); } }
  redraw();
});
canvas.addEventListener('pointermove', (ev)=>{
  if(mode!=='free' || !isDrawing) return;
  const r = canvas.getBoundingClientRect();
  const x = ev.clientX - r.left, y = ev.clientY - r.top;
  freePath.push([x,y]);
  const L = freePath.length;
  if(L>1){ dctx.strokeStyle='#e11'; dctx.lineWidth=2; dctx.beginPath(); dctx.moveTo(freePath[L-2][0], freePath[L-2][1]); dctx.lineTo(freePath[L-1][0], freePath[L-1][1]); dctx.stroke(); }
});
canvas.addEventListener('pointerup', (ev)=>{
  if(mode!=='free') return;
  isDrawing=false; canvas.releasePointerCapture(ev.pointerId);
});

/* controls */
$('clearBtn').onclick = ()=>{ vertices=[]; closed=false; freePath=[]; mask=null; redraw(); showMaskPreview(); };
$('closeBtn').onclick = ()=>{ if(vertices.length>2){ closed=true; redraw(); } };
$('rectBtn').onclick = ()=>{ vertices=[[10,10],[canvas.width-10,10],[canvas.width-10,canvas.height-10],[10,canvas.height-10]]; closed=true; freePath=[]; createMaskFromVertices(vertices); redraw(); showMaskPreview(); };

/* RDP */
function rdp(points, eps){
  if(points.length < 3) return points.slice();
  const distToSeg = (p,a,b)=>{
    const px=p[0], py=p[1], ax=a[0], ay=a[1], bx=b[0], by=b[1];
    const dx=bx-ax, dy=by-ay;
    if(dx===0 && dy===0) return Math.hypot(px-ax,py-ay);
    const t = ((px-ax)*dx + (py-ay)*dy) / (dx*dx+dy*dy);
    if(t<0) return Math.hypot(px-ax,py-ay);
    if(t>1) return Math.hypot(px-bx,py-by);
    const projx = ax+t*dx, projy = ay+t*dy;
    return Math.hypot(px-projx,py-projy);
  };
  let maxd=0, idx=0;
  for(let i=1;i<points.length-1;i++){
    const d = distToSeg(points[i], points[0], points[points.length-1]);
    if(d>maxd){ maxd=d; idx=i; }
  }
  if(maxd > eps){
    const l = rdp(points.slice(0, idx+1), eps);
    const r = rdp(points.slice(idx), eps);
    return l.slice(0,-1).concat(r);
  } else return [points[0], points[points.length-1]];
}

/* create mask from vertices */
function createMaskFromVertices(verts){
  const Ngrid = Math.max(24, Math.min(160, parseInt($('Ngrid').value||64)));
  const W = Ngrid, H = Math.max(8, Math.round(Ngrid * canvas.height / canvas.width));
  const arr = new Uint8Array(W*H);
  for(let j=0;j<H;j++){
    for(let i=0;i<W;i++){
      const cx = i*(canvas.width/W) + canvas.width/(2*W);
      const cy = j*(canvas.height/H) + canvas.height/(2*H);
      if(pointInPoly(cx,cy,verts)) arr[j*W+i]=1;
    }
  }
  mask = {w:W,h:H,arr};
}

/* point-in-poly */
function pointInPoly(x,y,poly){
  let inside=false;
  for(let i=0,j=poly.length-1;i<poly.length;j=i++){
    const xi=poly[i][0], yi=poly[i][1], xj=poly[j][0], yj=poly[j][1];
    const intersect = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/(yj-yi)+xi);
    if(intersect) inside=!inside;
  }
  return inside;
}

/* Smooth & Fill (from freePath) */
$('smoothFillBtn').onclick = ()=>{
  const pts = freePath.length>10 ? freePath.slice() : vertices.slice();
  if(pts.length<6) return alert('もっとしっかり描いてください');
  pts.push(pts[0]);
  const simp = rdp(pts, 2.0);
  vertices = simp.map(p=>[p[0],p[1]]); closed=true; freePath=[];
  createMaskFromVertices(vertices);
  redraw(); showMaskPreview();
};

/* show mask preview in heat canvas */
const heatCanvas = $('heatCanvas'), hctx = heatCanvas.getContext('2d');
function showMaskPreview(){
  const Nx = mask?mask.w:Math.max(24,parseInt($('Ngrid').value||64));
  const Ny = mask?mask.h:Math.max(8,Math.round(Nx*canvas.height/canvas.width));
  const img = hctx.createImageData(Nx,Ny);
  for(let j=0;j<Ny;j++){
    for(let i=0;i<Nx;i++){
      const v = mask ? (mask.arr[j*Nx+i]?200:255) : 255;
      const p = (j*Nx + i)*4;
      img.data[p]=v; img.data[p+1]=v; img.data[p+2]=v; img.data[p+3]=255;
    }
  }
  const tmp = document.createElement('canvas'); tmp.width=Nx; tmp.height=Ny; tmp.getContext('2d').putImageData(img,0,0);
  hctx.clearRect(0,0,heatCanvas.width,heatCanvas.height);
  hctx.drawImage(tmp,0,0,heatCanvas.width,heatCanvas.height);
}

/* --- Preset regular polygon generator --- */
function regularPolygonVertices(sides, padding=20){
  const cx = canvas.width/2, cy = canvas.height/2;
  const maxR = Math.min(canvas.width, canvas.height)/2 - padding;
  const verts = [];
  for(let k=0;k<sides;k++){
    const ang = -Math.PI/2 + 2*Math.PI*k/sides; // start at top
    const x = cx + maxR * Math.cos(ang);
    const y = cy + maxR * Math.sin(ang);
    verts.push([x,y]);
  }
  return verts;
}
$('applyPreset').onclick = ()=>{
  const n = parseInt($('presetPolygon').value);
  const verts = regularPolygonVertices(n, 28);
  vertices = verts; closed=true; freePath=[];
  createMaskFromVertices(vertices);
  redraw(); showMaskPreview();
};

/* initial draw */
redraw(); showMaskPreview();

/* Note: Other FDTD/worker/plot/FFT functionality from prior prototype
   should be integrated as needed. This file focuses on adding presets
   (3..8) and hooking them into mask creation. */
</script>
</body>
</html>
