<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Slab FDTD — Fs=2^k dt, FDTD transient (SS)</title>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
:root{--bg:#f7f8fb;--card:#fff;--ink:#0f172a;--muted:#475569;--accent:#2563eb}
body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter, "Noto Sans JP", system-ui, Roboto}
.wrap{max-width:1200px;margin:14px auto;padding:12px}
.grid{display:grid;grid-template-columns:360px 1fr;gap:12px}
.card{background:var(--card);padding:12px;border-radius:10px;border:1px solid #e6edf3}
label{display:block;color:var(--muted);font-size:13px;margin-bottom:6px}
input,select,button{width:100%;padding:8px;border-radius:8px;border:1px solid #e6edf3;margin-bottom:8px;box-sizing:border-box}
.row{margin-bottom:8px}
.btn{background:var(--accent);color:#fff;border:none;cursor:pointer;padding:8px;border-radius:8px}
.small{font-size:13px;color:var(--muted)}
#plotlyDiv{width:100%;height:48vh}
canvas{border-radius:6px}
.tabs{display:flex;gap:8px;margin-bottom:8px}
.tab{padding:8px 12px;border-radius:8px;background:#fff;border:1px solid #e6edf3;cursor:pointer}
.tab.active{background:#eef6ff;border-color:var(--accent)}
.inline{display:flex;gap:8px;align-items:center}
.mode-list{max-height:180px;overflow:auto;padding:6px;border-radius:8px;background:#fbfcfe;border:1px solid #eef3fb}
</style>
</head>
<body>
<div class="wrap">
  <h2>Slab FDTD (SS) — dt chosen by Fs = 2^k</h2>
  <div class="grid">
    <div class="card">
      <div class="row">
        <label>Material</label>
        <select id="material"><option value="concrete">Concrete (E=3e10, ν=0.2, ρ=2400)</option><option value="custom">Custom</option></select>
      </div>

      <div class="row inline">
        <div style="flex:1"><label>E [Pa]</label><input id="E" type="number" value="30000000000"></div>
        <div style="flex:1"><label>ν</label><input id="nu" type="number" step="0.01" value="0.20"></div>
      </div>

      <div class="row inline">
        <div style="flex:1"><label>ρ [kg/m³]</label><input id="rho" type="number" value="2400"></div>
        <div style="flex:1"><label>h [m]</label><input id="h" type="number" step="0.01" value="0.15"></div>
      </div>

      <div class="row inline">
        <div style="flex:1"><label>Lx [m]</label><input id="Lx" type="number" step="0.01" value="5.00"></div>
        <div style="flex:1"><label>Ly [m]</label><input id="Ly" type="number" step="0.01" value="4.00"></div>
      </div>

      <div class="row inline">
        <div style="flex:1"><label>m_max</label><input id="mmax" type="number" min="1" max="20" value="5"></div>
        <div style="flex:1"><label>n_max</label><input id="nmax" type="number" min="1" max="20" value="5"></div>
      </div>

      <div class="row">
        <label>Frames (保存フレーム数)</label>
        <input id="framesCount" type="number" value="128" min="8" max="1024">
      </div>

      <div class="row inline">
        <div style="flex:1"><label>Ngrid</label><input id="Ngrid" type="number" value="120" min="32" step="4"></div>
        <div style="flex:1"><label>samplesPerCycle</label><input id="samplesPerCycle" type="number" value="16" min="4" max="64"></div>
      </div>

      <div class="row">
        <label>Source preset</label>
        <select id="sourcePreset">
          <option value="center">center (Lx/2,Ly/2)</option>
          <option value="diag_1_3">diag 1/3 (Lx/3,Ly/3)</option>
          <option value="diag_2_3">diag 2/3 (2Lx/3,2Ly/3)</option>
        </select>
      </div>

      <div class="row inline">
        <div style="flex:1"><label>x0 [m]</label><input id="x0" type="number" step="0.01" value="2.50"></div>
        <div style="flex:1"><label>y0 [m]</label><input id="y0" type="number" step="0.01" value="2.00"></div>
      </div>

      <div class="row">
        <label>Probe (click plot to set)</label>
        <div class="inline">
          <div style="flex:1"><label>px [m]</label><input id="px" type="number" step="0.01" value="2.50"></div>
          <div style="flex:1"><label>py [m]</label><input id="py" type="number" step="0.01" value="2.00"></div>
        </div>
      </div>

      <div class="row inline">
        <label><input type="checkbox" id="useDb"> dB (20·log10, ref=1)</label>
        <label style="margin-left:8px"><input type="checkbox" id="autoFFT" checked> FFT auto after compute</label>
      </div>

      <div class="row inline">
        <button id="computeBtn" class="btn">計算開始 (FDTD transient)</button>
        <button id="cancelBtn" class="btn" style="background:#ef4444">Cancel</button>
      </div>

      <div class="row">
        <label>Progress</label>
        <progress id="progressBar" value="0" max="100" style="width:100%"></progress>
        <div id="progressText" class="small"></div>
      </div>

      <div style="margin-top:6px">
        <div class="small">Fs選定: 安定条件 dt_stab と 周波数解像 dt_res を比較し、dt_target=min(dt_stab,dt_res) を満たす最小の 2^k を選択します。（k_max=22）</div>
      </div>

      <hr/>
      <div class="row"><strong>Playback / Recording</strong></div>
      <div class="row inline">
        <button id="playBtn" class="btn">Play</button>
        <button id="pauseBtn" class="btn" style="background:#e6e6e6;color:#111">Pause</button>
        <button id="prevBtn" class="btn" style="background:#e6e6e6;color:#111">◀</button>
        <button id="nextBtn" class="btn" style="background:#e6e6e6;color:#111">▶</button>
      </div>
      <div class="row inline">
        <input id="frameSlider" type="range" min="0" value="0" style="flex:1">
      </div>

      <div class="row inline">
        <button id="startRec" class="btn">Start Recording</button>
        <button id="stopRec" class="btn" style="background:#e6e6e6;color:#111">Stop</button>
        <a id="recDownload" style="margin-left:8px"></a>
      </div>

      <hr/>
      <div class="row"><strong>Mode list</strong></div>
      <div class="mode-list" id="modeList"></div>
    </div>

    <div class="card">
      <div class="tabs">
        <div id="tabTime" class="tab active">Time</div>
        <div id="tabMode" class="tab">Mode</div>
        <div id="tabFreq" class="tab">Frequency</div>
      </div>

      <div id="panelTime">
        <div id="plotlyDiv"></div>
        <canvas id="heatCanvas" width=900 height=300 style="width:100%;height:300px;margin-top:8px;border:1px solid #eef3fb"></canvas>
      </div>

      <div id="panelMode" style="display:none">
        <div id="modePlotly" style="height:40vh"></div>
        <canvas id="modeCanvas" width=900 height=300 style="width:100%;height:300px;margin-top:8px;border:1px solid #eef3fb"></canvas>
      </div>

      <div id="panelFreq" style="display:none">
        <div id="fftPlot" style="height:40vh"></div>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = id => document.getElementById(id);

  // UI tabs
  function setTab(name){
    ['Time','Mode','Freq'].forEach(n=>{ $('tab'+n).classList.remove('active'); $('panel'+n).style.display='none'; });
    $('tab'+name).classList.add('active'); $('panel'+name).style.display='block';
  }
  $('tabTime').onclick = ()=>setTab('Time');
  $('tabMode').onclick = ()=>setTab('Mode');
  $('tabFreq').onclick = ()=>setTab('Freq');

  // helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  function D_of(E,h,nu){ return E * Math.pow(h,3) / (12*(1 - nu*nu)); }
  function modalMass(rho,h,Lx,Ly){ return rho * h * (Lx*Ly) / 4.0; }
  function phi(m,n,x,y,Lx,Ly){ return Math.sin(m*Math.PI*x/Lx) * Math.sin(n*Math.PI*y/Ly); }
  function buildModes(Lx,Ly,E,nu,rho,h,mmax,nmax){
    const D = D_of(E,h,nu);
    const modes=[];
    for(let m=1;m<=mmax;m++) for(let n=1;n<=nmax;n++){
      const k2 = Math.pow(m*Math.PI/Lx,2) + Math.pow(n*Math.PI/Ly,2);
      const omega = Math.sqrt(D/(rho*h)) * k2;
      modes.push({m,n,omega,f:omega/(2*Math.PI)});
    }
    modes.sort((a,b)=>a.f-b.f); return modes;
  }

  // global state
  let worker = null;
  let lastResult = null; // {frames:Array(Float32Array), Nx, Ny, dt, Fs, framesCount, modes, staticZ, xs, ys, probe}
  let playTimer = null;
  let currentFrame = 0;
  let recordedBlobs = [], mediaRecorder = null;

  // UI wiring: compute/cancel
  $('computeBtn').onclick = async ()=>{
    if(worker){ alert('既に計算中'); return; }
    // read params
    if($('material').value==='concrete'){ $('E').value=30000000000; $('nu').value=0.2; $('rho').value=2400; }
    const E = parseFloat($('E').value), nu = parseFloat($('nu').value), rho = parseFloat($('rho').value), h = parseFloat($('h').value);
    const Lx = parseFloat($('Lx').value), Ly = parseFloat($('Ly').value);
    const mmax = parseInt($('mmax').value), nmax = parseInt($('nmax').value);
    const Ngrid = parseInt($('Ngrid').value);
    const framesCount = Math.max(8, parseInt($('framesCount').value));
    const samplesPerCycle = Math.max(4, parseInt($('samplesPerCycle').value));
    const preset = $('sourcePreset').value;
    if(preset==='center'){ $('x0').value=(Lx/2).toFixed(3); $('y0').value=(Ly/2).toFixed(3); }
    else if(preset==='diag_1_3'){ $('x0').value=(Lx/3).toFixed(3); $('y0').value=(Ly/3).toFixed(3); }
    else if(preset==='diag_2_3'){ $('x0').value=(2*Lx/3).toFixed(3); $('y0').value=(2*Ly/3).toFixed(3); }
    const x0 = clamp(parseFloat($('x0').value),0,Lx), y0 = clamp(parseFloat($('y0').value),0,Ly);

    // compute modes to get f_max
    const modes = buildModes(Lx,Ly,E,nu,rho,h,mmax,nmax);
    const fmax = modes[modes.length-1].f || 1.0;

    // compute dx
    const dx = Math.min(Lx/(Ngrid-1), Ly/(Ngrid-1));
    const D = D_of(E,h,nu);
    const marea = rho*h;
    // dt_stab
    const Cstab = 0.25; // safe factor
    const dt_stab = Cstab * dx*dx * Math.sqrt(marea / D);
    const dt_res = 1.0 / (samplesPerCycle * fmax);
    const dt_target = Math.min(dt_stab, dt_res);
    // choose Fs = 2^k >= 1/dt_target
    const inv = 1.0 / dt_target;
    const k = Math.ceil(Math.log2(inv));
    const kmax = 22;
    let ksel = Math.min(k, kmax);
    if(k > kmax){
      if(!confirm('必要 Fs が高く k > k_max です。k_max='+kmax+' を使います。続行しますか?')) return;
    }
    const Fs = Math.pow(2, ksel);
    const dt = 1.0 / Fs;

    // prepare cfg
    const cfg = {E,nu,rho,h,Lx,Ly,Ngrid,framesCount,dx,dt,Fs,samplesPerCycle,modesLight:modes.map(m=>({m:m.m,n:m.n,f:m.f,omega:m.omega})),x0,y0,framesToSave:framesCount};
    // start worker
    $('progressText').textContent = `Preparing worker (Fs=2^${ksel}=${Fs.toLocaleString()} dt=${dt.toExponential(2)}s)`;
    $('progressBar').value = 0;
    worker = new Worker(URL.createObjectURL(new Blob([workerCode],{type:'application/javascript'})));
    worker.onmessage = (ev)=>{
      const data = ev.data;
      if(data.type === 'progress'){ $('progressBar').value = data.progress; $('progressText').textContent = data.msg||('progress '+data.progress+'%'); }
      if(data.type === 'done'){
        lastResult = data.result;
        worker.terminate(); worker = null;
        $('progressBar').value = 100;
        $('progressText').textContent = 'Done';
        // display static and set up frames
        showStaticAndFrames(lastResult);
        if($('autoFFT').checked) computeFFTFromProbe();
        populateModeList(lastResult.modes);
      }
    };
    worker.postMessage({type:'start', cfg});
  };

  $('cancelBtn').onclick = ()=>{ if(worker){ worker.terminate(); worker=null; $('progressText').textContent='Cancelled'; $('progressBar').value=0;} };

  // worker code as string
  const workerCode = `
  self.onmessage = function(ev){
    const msg = ev.data;
    if(msg.type!=='start') return;
    const cfg = msg.cfg;
    const E = cfg.E, nu = cfg.nu, rho = cfg.rho, h = cfg.h;
    const Lx = cfg.Lx, Ly = cfg.Ly, Ngrid = cfg.Ngrid;
    const dx = cfg.dx, dt = cfg.dt;
    const framesCount = cfg.framesToSave;
    const Fs = cfg.Fs;
    const marea = rho*h;
    const D = E * Math.pow(h,3) / (12*(1-nu*nu));
    const Nx = Ngrid, Ny = Ngrid;
    const size = Nx*Ny;
    // arrays
    let w = new Float32Array(size), wprev = new Float32Array(size), wnext = new Float32Array(size);
    // mask: full rectangle; simply-supported: w=0 at boundaries (we'll enforce)
    function idx(i,j){ return j*Nx + i; }
    // map source
    const x0 = cfg.x0, y0 = cfg.y0;
    const sx = Math.max(1, Math.min(Nx-2, Math.round(x0 / cfg.Lx * (Nx-1))));
    const sy = Math.max(1, Math.min(Ny-2, Math.round(y0 / cfg.Ly * (Ny-1))));
    const srcIdx = idx(sx, sy);
    // forcing: short impulse for first few steps
    const forceSteps = Math.max(1, Math.floor(Fs * 0.002)); // 2 ms impulse approx
    const totalSteps = framesCount;
    // finite-difference Laplacian / biharmonic
    function lap(arr){
      const out = new Float32Array(size);
      for(let j=1;j<Ny-1;j++){
        for(let i=1;i<Nx-1;i++){
          const id = idx(i,j);
          out[id] = (arr[id-1] + arr[id+1] + arr[id-Nx] + arr[id+Nx] - 4*arr[id])/(dx*dx);
        }
      }
      return out;
    }
    // enforce SS boundaries: w=0 at edges each step
    function enforceSS(a){
      for(let i=0;i<Nx;i++){ a[idx(i,0)] = 0; a[idx(i,Ny-1)]=0; }
      for(let j=0;j<Ny;j++){ a[idx(0,j)] = 0; a[idx(Nx-1,j)] = 0; }
    }
    // precompute coefficient
    const coeff = (dt*dt)/marea;
    const frames = [];
    // time stepping: explicit biharmonic: wtt = -D/m * ∇^4 w + F/m
    for(let step=0; step<totalSteps; step++){
      // forcing small impulse
      const F = new Float32Array(size);
      if(step < forceSteps) F[srcIdx] = 1.0;
      // compute lap and biharmonic
      const lap1 = lap(w);
      const bih = lap(lap1);
      for(let id=0; id<size; id++){
        // interior only; boundaries remain zero by enforceSS
        wnext[id] = 2*w[id] - wprev[id] + coeff * (F[id] - D * bih[id]);
      }
      enforceSS(wnext);
      // rotate
      wprev.set(w);
      w.set(wnext);
      // save scaled frame (displacement)
      frames.push(w.slice(0));
      if(step % Math.max(1, Math.floor(totalSteps/40)) === 0){
        self.postMessage({type:'progress', progress: Math.round(100*step/totalSteps), msg: 'step '+step+'/'+totalSteps});
      }
    }
    // compute static forced map via modal synthesis (light)
    const modes = cfg.modesLight;
    const Mmn = rho*h * (cfg.Lx * cfg.Ly) / 4.0;
    const omegaForced = 2*Math.PI * (modes[0].f || 1.0);
    const W = new Float32Array(size);
    for(const md of modes){
      if(md.m>cfg.modesLight.length || md.n>cfg.modesLight.length){} // keep light
      const omega_m = md.omega;
      // evaluate phi at source
      const phi0 = Math.sin(md.m*Math.PI*cfg.x0/cfg.Lx) * Math.sin(md.n*Math.PI*cfg.y0/cfg.Ly);
      const real = Mmn*(omega_m*omega_m - omegaForced*omegaForced);
      const imag = Mmn*(omegaForced * omega_m / 1e8);
      // eta = (F*phi0)/(real + i imag)
      const denom = real*real + imag*imag;
      const er = (1.0*phi0*real)/denom;
      const ei = (-1.0*phi0*imag)/denom;
      for(let j=0;j<Ny;j++){
        const cy = Math.sin(md.n * Math.PI * j/(Ny-1));
        for(let i=0;i<Nx;i++){
          const cx = Math.sin(md.m * Math.PI * i/(Nx-1));
          const idx0 = idx(i,j);
          W[idx0] += Math.hypot(er*cx*cy, ei*cx*cy);
        }
      }
    }
    // package result (transfer frames as ArrayBuffers)
    const transferable = [];
    const framesBuf = frames.map(f=>{ transferable.push(f.buffer); return f.buffer; });
    const result = {framesCount: frames.length, Nx: Nx, Ny: Ny, dt: dt, Fs: cfg.Fs, framesBuf: framesBuf, staticZ: Array.from(W), modes: modes, xs: Array.from({length:Nx}, (_,i)=>cfg.Lx*i/(Nx-1)), ys: Array.from({length:Ny}, (_,j)=>cfg.Ly*j/(Ny-1))};
    self.postMessage({type:'done', result: result}, transferable);
  };
  `;

  // show static and frames after worker done
  function showStaticAndFrames(res){
    // unpack frames from buffers to Float32Array
    const frames = res.framesBuf.map(buf => new Float32Array(buf));
    lastResult = Object.assign({}, res, {frames: frames});
    // show static heatmap
    const z = res.staticZ;
    const Nx = res.Nx, Ny = res.Ny;
    const zmin = Math.min(...z), zmax = Math.max(...z);
    const z2d = [];
    for(let j=0;j<Ny;j++){
      const row = [];
      for(let i=0;i<Nx;i++) row.push(z[j*Nx + i]);
      z2d.push(row);
    }
    Plotly.newPlot('plotlyDiv', [{z: z2d, type:'heatmap', colorscale:'Viridis'}], {margin:{t:30,b:60,l:60,r:10},xaxis:{title:'x'},yaxis:{title:'y'}}, {responsive:true});
    // draw first frame in heatCanvas
    drawFrameToCanvas(frames[0], Nx, Ny);
    // set slider
    $('frameSlider').max = frames.length - 1;
    currentFrame = 0;
    framesArrLocal = frames;
    // populate mode list
    populateModeList(res.modes);
  }

  function populateModeList(modes){
    const div = $('modeList'); div.innerHTML='';
    modes.forEach((m,idx)=>{
      const el = document.createElement('div'); el.style.padding='6px'; el.style.borderBottom='1px solid #f1f5f9'; el.style.cursor='pointer';
      el.textContent = `#${idx+1} (m,n)=(${m.m},${m.n}) f=${m.f.toFixed(2)}Hz`;
      el.onclick = ()=>{
        // highlight
        Array.from(div.children).forEach(x=>x.style.background='');
        el.style.background='#eef6ff';
        // generate frames for this mode only (sine one period)
        generateModeFrames(m);
        setTab('Mode');
      };
      div.appendChild(el);
    });
  }

  // draw frame to heatCanvas
  let framesArrLocal = [];
  function drawFrameToCanvas(arr, Nx, Ny){
    const ctx = document.getElementById('heatCanvas').getContext('2d');
    // normalize using global min/max across frames if available
    let minV = Infinity, maxV = -Infinity;
    for(const f of framesArrLocal){ for(const v of f){ if(v<minV) minV=v; if(v>maxV) maxV=v; } }
    if(minV===Infinity){ minV = Math.min(...arr); maxV = Math.max(...arr); }
    const W=Nx, H=Ny;
    const img = ctx.createImageData(W,H);
    const span = (maxV - minV) || 1e-12;
    for(let j=0;j<H;j++){
      for(let i=0;i<W;i++){
        const v = arr[j*Nx + i];
        const t = Math.max(0, Math.min(1, (v-minV)/span));
        const r = Math.round(68 + 187*t), g = Math.round(1 + 185*t), b = Math.round(84 + 40*(1-t));
        const p = (j*W + i)*4;
        img.data[p]=r; img.data[p+1]=g; img.data[p+2]=b; img.data[p+3]=255;
      }
    }
    const tmp = document.createElement('canvas'); tmp.width=W; tmp.height=H; tmp.getContext('2d').putImageData(img,0,0);
    ctx.clearRect(0,0,heatCanvas.width,heatCanvas.height);
    ctx.drawImage(tmp,0,0,heatCanvas.width,heatCanvas.height);
  }

  // playback controls
  $('playBtn').onclick = ()=>{
    if(!lastResult || !lastResult.framesBuf) return alert('先に計算してください');
    if(playTimer) return;
    playTimer = setInterval(()=>{
      currentFrame = (currentFrame + 1) % lastResult.framesCount;
      drawFrameToCanvas(lastResult.frames[currentFrame], lastResult.Nx, lastResult.Ny);
      $('frameSlider').value = currentFrame;
    }, Math.max(20, Math.floor(1000/25)));
  };
  $('pauseBtn').onclick = ()=>{ if(playTimer){ clearInterval(playTimer); playTimer=null; } };
  $('prevBtn').onclick = ()=>{ $('pauseBtn').click(); currentFrame = Math.max(0, currentFrame-1); drawFrameToCanvas(lastResult.frames[currentFrame], lastResult.Nx, lastResult.Ny); $('frameSlider').value=currentFrame; };
  $('nextBtn').onclick = ()=>{ $('pauseBtn').click(); currentFrame = Math.min(lastResult.framesCount-1, currentFrame+1); drawFrameToCanvas(lastResult.frames[currentFrame], lastResult.Nx, lastResult.Ny); $('frameSlider').value=currentFrame; };
  $('frameSlider').oninput = (e)=>{ $('pauseBtn').click(); currentFrame = parseInt(e.target.value); drawFrameToCanvas(lastResult.frames[currentFrame], lastResult.Nx, lastResult.Ny); };

  // recording
  $('startRec').onclick = ()=>{
    if(!lastResult) return alert('先に計算してください');
    recordedBlobs = [];
    const stream = document.getElementById('heatCanvas').captureStream(25);
    try{ mediaRecorder = new MediaRecorder(stream, {mimeType:'video/webm;codecs=vp9'}); }catch(e){ mediaRecorder = new MediaRecorder(stream); }
    mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) recordedBlobs.push(e.data); };
    mediaRecorder.onstop = ()=>{ const blob = new Blob(recordedBlobs, {type:'video/webm'}); const url = URL.createObjectURL(blob); const a = $('recDownload'); a.href=url; a.download=`slab_${Date.now()}.webm`; a.textContent='Download video'; };
    mediaRecorder.start();
    // drive frames for whole sequence then stop
    let k=0;
    const ii = setInterval(()=>{
      if(k >= lastResult.framesCount){ clearInterval(ii); if(mediaRecorder && mediaRecorder.state==='recording') mediaRecorder.stop(); return; }
      drawFrameToCanvas(lastResult.frames[k], lastResult.Nx, lastResult.Ny);
      k++;
    }, Math.max(20, Math.floor(1000/25)));
  };
  $('stopRec').onclick = ()=>{ if(mediaRecorder && mediaRecorder.state==='recording') mediaRecorder.stop(); };

  // generate mode frames (1 period) and show in Mode panel
  function generateModeFrames(mode){
    if(!lastResult) return;
    const Ngrid = lastResult.Nx;
    const Lx = lastResult.xs.length>1 ? lastResult.xs[lastResult.xs.length-1] : parseFloat($('Lx').value);
    const Ly = lastResult.ys.length>1 ? lastResult.ys[lastResult.ys.length-1] : parseFloat($('Ly').value);
    const Nx = lastResult.Nx, Ny = lastResult.Ny;
    const framesCount = parseInt($('framesCount').value);
    const omega = mode.omega;
    const phiArr = new Float64Array(Nx*Ny);
    let maxabs=0;
    for(let j=0;j<Ny;j++){
      const y = j/(Ny-1)*Ly;
      for(let i=0;i<Nx;i++){
        const x = i/(Nx-1)*Lx;
        const v = Math.sin(mode.m*Math.PI*x/Lx)*Math.sin(mode.n*Math.PI*y/Ly);
        phiArr[j*Nx+i]=v; if(Math.abs(v)>maxabs) maxabs=Math.abs(v);
      }
    }
    if(maxabs===0) maxabs=1;
    for(let k=0;k<phiArr.length;k++) phiArr[k]/=maxabs;
    const frames = [];
    for(let f=0; f<framesCount; f++){
      const t = f/framesCount * (2*Math.PI/omega);
      const cosv = Math.cos(omega * t);
      const frame = new Float32Array(Nx*Ny);
      for(let k=0;k<phiArr.length;k++) frame[k] = phiArr[k]*cosv;
      frames.push(frame);
    }
    lastResult.modeFrames = frames;
    // draw first
    const ctx = document.getElementById('modeCanvas').getContext('2d');
    // draw frame 0
    const arr = frames[0];
    // compute min/max
    let mn=Infinity, mx=-Infinity; for(const v of arr){ if(v<mn) mn=v; if(v>mx) mx=v; }
    // draw
    const tmp = document.createElement('canvas'); tmp.width=Nx; tmp.height=Ny;
    const img = tmp.getContext('2d').createImageData(Nx,Ny);
    const span = mx-mn||1;
    for(let j=0;j<Ny;j++) for(let i=0;i<Nx;i++){
      const v = arr[j*Nx+i]; const t=(v-mn)/span;
      const r=Math.round(68+187*t), g=Math.round(1+185*t), b=Math.round(84+40*(1-t));
      const p=(j*Nx+i)*4; img.data[p]=r; img.data[p+1]=g; img.data[p+2]=b; img.data[p+3]=255;
    }
    tmp.getContext('2d').putImageData(img,0,0);
    ctx.clearRect(0,0,document.getElementById('modeCanvas').width, document.getElementById('modeCanvas').height);
    ctx.drawImage(tmp,0,0,document.getElementById('modeCanvas').width, document.getElementById('modeCanvas').height);
    // play mode frames loop when clicked play on Mode tab
    // hook play
    $('modePlotly').innerHTML = '<div class="small">Mode frames ready ('+framesCount+' frames)</div>';
  }

  // compute FFT from probe time series
  function computeFFTFromProbe(){
    if(!lastResult) return;
    const px = parseFloat($('px').value), py = parseFloat($('py').value);
    const Lx = parseFloat($('Lx').value), Ly = parseFloat($('Ly').value);
    const Nx = lastResult.Nx;
    const ix = clamp(Math.round(px / Lx * (Nx-1)), 0, Nx-1);
    const iy = clamp(Math.round(py / Ly * (Nx-1)), 0, Nx-1);
    const pr = 0; // radius not provided here
    const Nf = lastResult.framesCount;
    const disp = new Float64Array(Nf);
    for(let f=0; f<Nf; f++) disp[f] = lastResult.frames[f][iy*Nx + ix];
    // central diff to get velocity
    const vts = new Float64Array(Nf-2);
    const dt = lastResult.dt;
    for(let n=1;n<Nf-1;n++) vts[n-1] = (disp[n+1] - disp[n-1])/(2*dt);
    // window?
    // zero-pad factor 1
    const Nout = Math.max(64, vts.length);
    // simple DFT (real)
    const mags = new Float64Array(Math.floor(Nout/2));
    for(let k=0;k<mags.length;k++){
      let re=0, im=0;
      for(let n=0;n<vts.length;n++){ const ang = -2*Math.PI*k*n/Nout; re+=vts[n]*Math.cos(ang); im+=vts[n]*Math.sin(ang); }
      mags[k] = Math.hypot(re,im);
    }
    const freqs = new Array(mags.length);
    for(let k=0;k<mags.length;k++) freqs[k] = k/(Nout*dt);
    const vals = mags.map(v=>20*Math.log10(Math.max(v,1e-20)));
    Plotly.newPlot('fftPlot', [{x:freqs, y:vals, type:'scatter', mode:'lines'}], {xaxis:{type:'log', title:'Hz'}, yaxis:{title:'20·log10(ref=1)'}}, {responsive:true});
  }

  // plot click sets probe
  document.getElementById('plotlyDiv').on('plotly_click', (ev)=>{
    if(!ev.points || !ev.points[0]) return;
    const p = ev.points[0];
    $('px').value = p.x.toFixed(3);
    $('py').value = p.y.toFixed(3);
  });

})();
</script>
</body>
</html>
