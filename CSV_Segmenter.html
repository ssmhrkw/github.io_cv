<!DOCTYPE html>
<html lang="ja">
<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HFR5WYG42Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-HFR5WYG42Q'); // ページビュー自動送信
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSV Segmenter (Web) v4.0</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root {
      --bg: #faf6ed;
      --card: #ffffff;
      --muted: #5b6b7a;
      --text: #1e293b;
      --accent: #0b6bcb;
      --warn: #c77d00;
      --danger: #c92a2a;
      --ok: #13795b;
      --border: #e2e8f0;
      --soft: #f6f8fb;
      --ok-bg: #e6f7ef;
      --ok-br: #86e1b5;
      --ng-bg: #fdecec;
      --ng-br: #f5a3a3;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 0;
      font-family: "Hiragino Kaku Gothic ProN", "Meiryo", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: var(--bg);
      min-height: 100vh;
    }
    header {
      padding: 18px 20px 10px;
      border-bottom: 1px solid var(--border);
      position: sticky; top: 0; background: rgba(255,255,255,0.85); backdrop-filter: blur(8px);
      z-index: 10;
    }
    header h1 { margin: 0 0 6px; font-size: 18px; font-weight: 700; letter-spacing: 0.2px; color: #0f2e54; }
    header p { margin: 0; font-size: 12px; color: var(--muted); }
    main { padding: 16px; max-width: 1200px; margin: 0 auto; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 1024px) { .grid-2 { grid-template-columns: 1.2fr 1fr; } }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px; padding: 14px;
      box-shadow: 0 6px 16px rgba(148,163,184,0.15);
    }
    .card h2 { margin: 0 0 10px; font-size: 16px; color: #0f2e54; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    label { font-size: 12px; color: var(--text); }
    input[type="text"], input[type="number"], select {
      background: #fff; color: var(--text); border: 1px solid var(--border);
      border-radius: 10px; padding: 8px 10px; font-size: 13px; outline: none;
      transition: box-shadow .2s ease, border-color .2s ease, background .2s ease;
    }
    input[type="number"] { width: 100px; }
    input.ok-state { background: var(--ok-bg); border-color: var(--ok-br); box-shadow: 0 0 0 3px rgba(19,121,91,0.12); }
    input.ng-state { background: var(--ng-bg); border-color: var(--ng-br); box-shadow: 0 0 0 3px rgba(201,42,42,0.12); }
    .file-wrap { padding: 6px 10px; border: 1px dashed var(--border); border-radius: 10px; background: #fff; }
    .file-wrap.ok-state { background: var(--ok-bg); border-color: var(--ok-br); }
    .file-wrap.ng-state { background: var(--ng-bg); border-color: var(--ng-br); }
    button {
      appearance: none; border: 1px solid var(--border); color: var(--text);
      background: #fff;
      padding: 8px 12px; font-size: 13px; border-radius: 12px; cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    button:hover { border-color: #b6c3d2; box-shadow: 0 2px 8px rgba(15,46,84,0.06); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #0b6bcb; color: #fff; border-color: #0b6bcb; }
    .btn-green { background: #0b8f6b; color: #fff; border-color: #0b8f6b; }
    .btn-outline { background: transparent; }
    .muted { color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; color: #334155; }
    .danger { color: var(--danger); }
    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
    .mapping-table { width: 100%; border-collapse: collapse; }
    .mapping-table th, .mapping-table td { border-bottom: 1px dashed var(--border); padding: 6px 8px; font-size: 12px; }
    .mapping-table th { text-align: left; color: #0f2e54; }
    .plots { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .plot-card { background: var(--soft); border: 1px solid var(--border); border-radius: 12px; padding: 8px; }
    .plot-title { margin: 0 0 6px; font-size: 13px; color: #0f2e54; }
    .kpi-row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
    @media (min-width: 1200px) { .kpi-row { grid-template-columns: repeat(4, 1fr); } }
    .kpi { background: #fff; border: 1px solid var(--border); border-radius: 12px; padding: 10px; }
    table.metrics { width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed; }
    table.metrics th, table.metrics td { border-bottom: 1px solid var(--border); padding: 6px 8px; }
    table.metrics th { text-align: left; color: #0f2e54; position: sticky; top: 0; background: #fff; z-index: 1; }
    table.metrics td, table.metrics th { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .pill { display: inline-block; font-size: 11px; padding: 2px 8px; border-radius: 999px; background: #eef2f7; border: 1px solid #d8e0ea; }
    .footer-note { font-size: 11px; color: var(--muted); }
    .help { font-size: 12px; color: var(--muted); }
    .vspacer { height: 6px; }
    .hr { border: none; border-top: 1px dashed var(--border); margin: 10px 0; }
    .right { text-align: right; }
    .nowrap { white-space: nowrap; }
    #infoPanel { margin-top: 8px; background: #fff; border: 1px solid var(--border); border-radius: 10px; padding: 8px; }
    #infoPanel h3 { margin: 0 0 8px; font-size: 14px; color: #0f2e54; }
    #infoPanel table { width: 100%; border-collapse: collapse; font-size: 12px; }
    #infoPanel th, #infoPanel td { border-bottom: 1px solid var(--border); padding: 6px 8px; }
    #infoPanel th { text-align: left; color: #0f2e54; }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: middle; }
    .status-ok { background: #22c55e; }
    .status-ng { background: #ef4444; }
    
    /* ★★★ v4.0 追加スタイル ★★★ */
    #autoSegmentControls {
      background: var(--soft); border: 1px solid var(--border);
      border-radius: 12px; padding: 12px;
      display: none; /* 初期状態は非表示 */
      margin-top: 10px;
    }
    #autoSegmentControls .row { justify-content: space-between; }
    #autoSegmentControls input[type="number"] { width: 120px; font-size: 14px; }
    #autoSegmentControls h4 { margin: 0 0 10px; color: #0f2e54; }
    #autoSegmentNav { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
    #autoSegmentNav span { font-size: 16px; font-weight: bold; color: var(--accent); }
    #autoSegmentEdit { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    #autoSegmentEdit label { font-size: 13px; }
    /* ★★★ v4.0 スタイルここまで ★★★ */
  </style>
</head>
<body>
  <header>
    <h1>CSV Segmenter (Web) — v4.0 (Auto-Segment)</h1>
    <p class="muted"></p>
  </header>

  <main class="grid grid-2">
    <section class="card">
      <h2>1) データ入力</h2>
      <div class="row" id="urlRow">
        <label>CSV URL:</label>
        <input id="csvUrl" type="text" placeholder="/data/sample.csv または https://raw.githubusercontent.com/USER/REPO/BRANCH/path/to.csv" style="flex:1" />
        <button id="btnLoadUrl" class="btn-primary">URLから読み込む</button>
        <span id="urlStatus" class="muted"></span>
      </div>
      <div class="vspacer"></div>
      <div class="row file-wrap" id="fileRow">
        <label>ローカルCSV:</label>
        <input id="csvFile" type="file" accept=".csv" />
        <button id="btnLoadFile">ファイル読み込み</button>
        <span id="fileStatus" class="muted">（UTF-8推奨）</span>
      </div>

      <hr class="hr" />
      <h2>2) チャンネル・マッピング</h2>
      <p class="help">Mic 選択時は距離(m)を指定。Timeが無い場合 <span class="mono">Time (s)=index/Fs</span> を自動生成。</p>
      <div id="mappingArea" class="mono muted">CSV読み込み後に自動生成します。</div>
      <div class="vspacer"></div>
      <div class="row">
        <button id="btnApplyMapping" class="btn-green">マッピング適用 / 反映</button>
        <button id="btnResetMapping" class="btn-outline">リセット</button>
        <button id="btnPreset1" class="btn-outline">プリセット1（Time, FH, Acc, Acc, Mic×5）</button>
        <span id="mapStatus" class="muted"></span>
      </div>

      <hr class="hr" />
      <h2>3) ツール</h2>
      <div class="kpi-row">
        <div class="kpi">
          <div class="muted">サンプリング周波数 (Hz)</div>
          <input id="samplingRate" type="number" value="51200" step="100" />
        </div>
        <div class="kpi">
          <div class="muted">セグメント番号</div>
          <div class="row">
            <input id="segmentNo" type="number" value="1" min="1" step="1" />
            <button id="btnClearSelections" class="btn-outline">全選択クリア</button>
          </div>
        </div>
        <div class="kpi">
          <div class="muted">計算</div>
          <div class="row">
            <button id="btnCompute" class="btn-primary">メトリクス計算</button>
          </div>
        </div>
        <div class="kpi">
          <div class="muted">エクスポート</div>
          <div class="row">
            <button id="btnExportSegment" class="btn-outline">combined_segment_#.csv</button>
            <button id="btnExportSummary" class="btn-outline">calculation_summary.csv</button>
          </div>
        </div>
      </div>
      <p class="help"><b>推奨ワークフロー:</b> 4) 自動セグメント → 「1. インパルス自動検出」 → 「2. このセグメントを適用」 → 「メトリクス計算」。</p>

      <hr class="hr" />
      <h2>4) 自動セグメント (Auto-Segment)</h2>
      <p class="help">FHチャネルに基づき、インパルス（ピーク）を自動検出します。検出されたセグメントは「プレビュー（詳細）」に拡大表示され、手動で微調整できます。</p>
      <div class="row" style="gap: 12px;">
        <label>検出閾値 (x * Noise SD):</label>
        <input id="autoThreshold" type="number" value="5" step="0.5" style="width:80px;" />
        <label>静音期間 (ms):</label>
        <input id="autoQuietMS" type="number" value="5" step="1" style="width:80px;" />
        <button id="btnAutoDetect" class="btn-primary" style="flex:1;">1. インパルス自動検出</button>
      </div>
      
      <div id="autoSegmentControls">
        <h4>検出されたインパルス: <span id="autoSegmentTotal" class="ok">0</span> 件</h4>
        <div id="autoSegmentNav" class="row">
          <button id="btnPrevSegment" class="btn-outline" disabled>&lt; 前 (Prev)</button>
          <span class="mono">Impulse #<span id="autoSegmentCurrent">0</span></span>
          <button id="btnNextSegment" class="btn-outline" disabled>次 (Next) &gt;</button>
        </div>
        <div id="autoSegmentEdit" class="row">
          <label>Start (s):</label>
          <input id="autoStartTime" type="number" step="0.0001" />
          <label>End (s):</label>
          <input id="autoEndTime" type="number" step="0.0001" />
          <button id="btnApplyManualSegment" class="btn-green" style="flex:1;">2. このセグメントを適用</button>
        </div>
        <div id="autoSegmentStatus" class="muted" style="margin-top: 8px;"></div>
      </div>
      <div id="infoPanel">
        <h3>Information（Max / Min / Duration）</h3>
        <div id="fhInfo" class="muted" style="margin-bottom:6px;"></div>
        <div id="infoTableWrap"></div>
      </div>

      <div class="vspacer"></div>
      <h3 class="muted">Metrics（ご提案形式）</h3>
      <div style="overflow:auto; max-height: 260px;">
        <table class="metrics" id="metricsTable">
          <thead>
            <tr>
              <th style="width:120px">Channel</th>
              <th>Sum Abs</th>
              <th>Max_abs</th>
              <th>F/v_Sum</th>
              <th>F/v_dB_Sum</th>
              <th>F/v_Max</th>
              <th>F/v_dB_Max</th>
            </tr>
          </thead>
          <tbody id="metricsBody"></tbody>
        </table>
      </div>
      <p class="footer-note">Micは v = p/(ρc) に変換（ρ≈1.21kg/m³, c=343m/s）。Accはそのままvとして扱います。</p>
    </section>

    <section class="card">
      <h2>プレビュー (全体)</h2>
      <div id="plots_overview" class="plots"></div>
      
      <hr class="hr" style="margin: 16px 0;" />
      
      <h2>プレビュー (詳細セグメント)</h2>
      <p class="help">「自動セグメント」セクションで選択中のインパルスが、ここに拡大表示されます。</p>
      <div id="plots_detail" class="plots"></div>
      </section>
  </main>

  <script>
    // =============================
    // Constants & Global State
    // =============================
    // const FS = 51200; // v4.0: 動的に取得
    const rho = 1.21, c = 343;
    let rawRows = [];
    let headers = [];
    let mapping = [];
    let mapped = null;
    let selections = {};
    
    // ★★★ v4.0 変更: プロットDivsを分割 ★★★
    let plotDivs_Overview = {};
    let plotDivs_Detail = {};
    
    // ★★★ v4.0 追加: 自動セグメント用グローバル変数 ★★★
    let autoSegments = [];
    let currentSegmentIdx = -1;
    
    let summaryRows = []; // export用

    // =============================
    // Helpers
    // =============================
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    
    // ★★★ v4.0 追加: Fs取得ヘルパー ★★★
    const getFS = () => Number($("#samplingRate").value) || 51200;

    function showStatus(el, msg, ok=true) {
      el.innerHTML = (ok ? '<span class="status-dot status-ok"></span>' : '<span class="status-dot status-ng"></span>') + msg;
      el.className = ok ? "muted ok" : "muted danger";
    }
    function markInputState(el, ok=true) {
      el.classList.remove("ok-state","ng-state");
      el.classList.add(ok ? "ok-state" : "ng-state");
    }
    function markRowState(row, ok=true) {
      row.classList.remove("ok-state","ng-state");
      row.classList.add(ok ? "ok-state" : "ng-state");
    }
    function downloadText(filename, text) {
      const blob = new Blob([text], {type: "text/csv;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    }
    function ensureUniqueName(base, existing) {
      if (!existing.has(base)) return base;
      let idx = 2;
      while (existing.has(`${base}_${idx}`)) idx++;
      return `${base}_${idx}`;
    }
    function autoTimeIfMissing(rows) {
      const timeKey = headers.find(h => h.toLowerCase().trim() === "time (s)");
      if (timeKey) return rows.map((r,i)=> Number(r[timeKey]));
      // ★★★ v4.0 変更: Fsを動的に使用 ★★★
      const FS = getFS();
      return rows.map((_,i) => i / FS);
    }
    function toFloatArray(rows, key) {
      const arr = new Float64Array(rows.length);
      for (let i = 0; i < rows.length; i++) {
        const v = rows[i][key];
        arr[i] = (v === null || v === undefined || v === "" || isNaN(Number(v))) ? 0 : Number(v);
      }
      return arr;
    }
    function idxBetween(time, t0, t1) {
      const lo = Math.min(t0, t1), hi = Math.max(t0, t1);
      const idxs = [];
      for (let i = 0; i < time.length; i++) {
        const t = time[i];
        if (t >= lo && t <= hi) idxs.push(i);
      }
      return idxs;
    }
    function absSum(arr, idxs) { let s = 0; for (const i of idxs) s += Math.abs(arr[i]); return s; }
    function absMax(arr, idxs) { let m = 0; for (const i of idxs) { const v = Math.abs(arr[i]); if (v > m) m = v; } return m; }
    function absMin(arr, idxs) { let m = Infinity; for (const i of idxs) { const v = arr[i]; if (v < m) m = v; } return m; }
    function fmt(v, d=2) { return (v===null || v===undefined || !isFinite(v)) ? "" : Number(v).toFixed(d); }

    // FH helpers
    function getFH() { return mapped ? (mapped.channels.find(c => c.role === "FH") || null) : null; }
    function fhSel() { const fh = getFH(); if (!fh) return null; const s = selections[fh.name]; return (s && s.clicks.length>=2) ? s : null; }
    function fhClicks() { const s = fhSel(); return s ? s.clicks.slice(0,2) : null; }
    function fhDuration() { const cks = fhClicks(); return cks ? Math.abs(cks[1]-cks[0]) : null; }

    // =============================
    // CSV Loading
    // =============================
    async function loadCSVFromURL(url) {
      const res = await fetch(url, {mode: "cors"});
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      const text = await res.text();
      return parseCSVText(text);
    }
    function parseCSVText(text) {
      const out = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
      if (out.errors && out.errors.length) console.warn("Papa parse errors:", out.errors);
      
      // ★★★ v4.0 変更: 列名からスペースを除去 ★★★
      rawRows = out.data;
      headers = (out.meta.fields || Object.keys(rawRows[0] || {})).map(h => h.trim());
      // 元の行データもキーをトリムする
      if (out.meta.fields) {
          rawRows = rawRows.map(row => {
              const newRow = {};
              for (const key in row) {
                  newRow[key.trim()] = row[key];
              }
              return newRow;
          });
      }
      // ★★★ v4.0 変更ここまで ★★★

      buildMappingUI();
      // ★★★ v4.0 変更: プロットエリアをリセット ★★★
      $("#plots_overview").innerHTML = "";
      $("#plots_detail").innerHTML = "";
      $("#infoTableWrap").innerHTML = "";
      $("#fhInfo").textContent = "";
      $("#metricsBody").innerHTML = "";
      selections = {};
      plotDivs_Overview = {};
      plotDivs_Detail = {};
      summaryRows = [];
      resetAutoSegmentUI(); // ★★★ v4.0 追加
      return true;
    }
    function loadCSVFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => { try { parseCSVText(reader.result); resolve(true); } catch (e) { reject(e); } };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file, "utf-8");
      });
    }

    // =============================
    // Mapping UI
    // =============================
    function buildMappingUI() {
      mapping = headers.map(h => ({ src: h, role: "Ignore", distance: "" }));
      const container = document.getElementById("mappingArea");
      const rowsHtml = headers.map((h, i) => {
        return `
          <tr>
            <td class="mono nowrap">${i+1}</td>
            <td class="mono">${h}</td>
            <td>
              <select data-idx="${i}" class="role">
                <option value="Ignore">Ignore</option>
                <option value="FH">FH</option>
                <option value="Acc">Acc</option>
                <option value="Mic">Mic</option>
                <option value="Time">Time (s)</option>
              </select>
            </td>
            <td>
              <input type="number" step="0.1" min="0" placeholder="Mic距離(m)" class="dist" data-idx="${i}" />
            </td>
          </tr>
        `;
      }).join("");
      container.innerHTML = `
        <table class="mapping-table">
          <thead><tr><th>#</th><th>CSV列名</th><th>役割</th><th>Mic距離(m)</th></tr></thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      `;
    }

    function applyMapping() {
      $$("#mappingArea select.role").forEach(sel => { const i = Number(sel.dataset.idx); mapping[i].role = sel.value; });
      $$("#mappingArea input.dist").forEach(inp => { const i = Number(inp.dataset.idx); mapping[i].distance = inp.value ? Number(inp.value) : ""; });

      const usedNames = new Set();
      const timeAuto = autoTimeIfMissing(rawRows);
      const channels = [];
      mapping.forEach((m, i) => {
        if (m.role === "Ignore" || m.role === "Time") return;
        let base = m.role;
        if (m.role === "Mic") {
          const d = (typeof m.distance === "number" && !isNaN(m.distance)) ? m.distance : null;
          base = d !== null ? `Mic(${d.toFixed(1)}m)` : "Mic";
        }
        const name = ensureUniqueName(base, usedNames);
        usedNames.add(name);
        channels.push({ name, role: m.role, src: mapping[i].src, data: toFloatArray(rawRows, mapping[i].src), distance: m.distance });
      });
      const timeIdx = mapping.findIndex(m => m.role === "Time");
      const timeFinal = (timeIdx >= 0) ? toFloatArray(rawRows, mapping[timeIdx].src) : Float64Array.from(timeAuto);
      if (channels.length === 0) throw new Error("データチャンネルがありません。");
      mapped = { time: timeFinal, channels };
      showStatus($("#mapStatus"), `OK: ${channels.length}ch 反映 (FH:${channels.filter(c=>c.role==='FH').length}, Acc:${channels.filter(c=>c.role==='Acc').length}, Mic:${channels.filter(c=>c.role==='Mic').length})`, true);
      renderPlots();
      updateInfoPanel();
      resetAutoSegmentUI(); // マッピング変更時もリセット
    }

    // プリセット1：Time, FH, Acc, Acc, Mic×5
    function applyPreset1() {
      const seq = ["Time","FH","Acc","Acc","Mic","Mic","Mic","Mic","Mic"];
      const selects = $$("#mappingArea select.role");
      for (let i = 0; i < selects.length; i++) {
        const role = (i < seq.length) ? seq[i] : "Ignore";
        selects[i].value = role;
        mapping[i].role = role;
      }
      showStatus($("#mapStatus"), "プリセット1を適用しました。必要に応じて距離(m)を入力してください。", true);
      try { applyMapping(); } catch (e) { console.error(e); showStatus($("#mapStatus"), `エラー: ${e.message}`, false); }
    }

    // =============================
    // Plotting & Selection
    // =============================
    function renderPlots() {
      // ★★★ v4.0 変更: 2つのエリアに描画 ★★★
      const wrap_overview = $("#plots_overview"); wrap_overview.innerHTML = "";
      const wrap_detail = $("#plots_detail"); wrap_detail.innerHTML = "";
      
      plotDivs_Overview = {};
      plotDivs_Detail = {};
      selections = {};
      
      for (const ch of mapped.channels) {
        // --- 1. 全体(Overview)プロット ---
        const div_ov = document.createElement("div");
        div_ov.className = "plot-card";
        const title_ov = document.createElement("div");
        title_ov.className = "plot-title";
        title_ov.textContent = `Channel: ${ch.name} (${ch.role})`;
        const plot_ov = document.createElement("div");
        plot_ov.style.height = "200px";
        plot_ov.dataset.chan = ch.name;
        div_ov.appendChild(title_ov); div_ov.appendChild(plot_ov); wrap_overview.appendChild(div_ov);
        plotDivs_Overview[ch.name] = plot_ov;

        const trace = { x: Array.from(mapped.time), y: Array.from(ch.data), mode: "lines", line: { width: 1 }, hoverinfo: "x+y", name: ch.name };
        const layout_ov = {
          margin: { l: 40, r: 10, t: 6, b: 22 },
          xaxis: { title: "Time (s)", color: "#1f2937" },
          yaxis: { title: "Amp.", color: "#1f2937" },
          shapes: [], showlegend: false, paper_bgcolor: "#ffffff", plot_bgcolor: "#ffffff", font: { color: "#1f2937" },
        };
        Plotly.newPlot(plot_ov, [trace], layout_ov, { responsive: true });

        // --- 2. 詳細(Detail)プロット ---
        const div_dt = document.createElement("div");
        div_dt.className = "plot-card";
        const title_dt = document.createElement("div");
        title_dt.className = "plot-title";
        title_dt.textContent = `Channel: ${ch.name} (${ch.role})`;
        const plot_dt = document.createElement("div");
        plot_dt.style.height = "200px";
        plot_dt.dataset.chan = ch.name;
        div_dt.appendChild(title_dt); div_dt.appendChild(plot_dt); wrap_detail.appendChild(div_dt);
        plotDivs_Detail[ch.name] = plot_dt;
        
        // レイアウトをディープコピーして個別管理
        const layout_dt = JSON.parse(JSON.stringify(layout_ov));
        // 詳細プロットには初期ズーム（最初の0.1秒など）を設定
        layout_dt.xaxis.range = [mapped.time[0], mapped.time[0] + 0.1];
        Plotly.newPlot(plot_dt, [trace], layout_dt, { responsive: true });
        
        // --- 3. セレクション管理 ---
        selections[ch.name] = { clicks: [], guide: null };

        // ★★★ v4.0 変更: クリックイベントは全体プロットにのみ残す ★★★
        plot_ov.on("plotly_click", (ev) => {
          if (!ev || !ev.points || !ev.points.length) return;
          const x = ev.points[0].x;
          handleClickOnChannel(ch.name, x);
        });
      }
    }
    
    // ★★★ v4.S.0 変更: 描画関数を分割 ★★★
    function drawSelectionOnPlot(name) {
      const sel = selections[name];
      const shapes = [];
      const dt = fhDuration();
      
      // ... (既存のshapeロジックは変更なし) ...
      if (sel.clicks.length === 1 && dt && isFinite(dt)) {
        const x0 = sel.clicks[0]; const x1 = x0 + dt;
        shapes.push(
          { type: "rect", x0, x1, y0: 0, y1: 1, xref: "x", yref: "paper",
            fillcolor: "rgba(255,170,0,0.18)", line: { color: "rgba(199,125,0,0.8)", width: 1, dash: "dot" } },
          { type: "line", x0, x1: x0, y0: 0, y1: 1, xref: "x", yref: "paper",
            line: { color: "#c77d00", width: 2, dash: "dot" } }
        );
        sel.guide = { x0, x1, dt };
      } else { sel.guide = null; }
      if (sel.clicks.length === 1 && !dt) {
        const x0 = sel.clicks[0];
        shapes.push({ type: "line", x0, x1: x0, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } });
      } else if (sel.clicks.length >= 2) {
        const [a,b] = sel.clicks.slice(0,2); const x0 = Math.min(a,b), x1 = Math.max(a,b);
        shapes.push(
          { type: "line", x0: a, x1: a, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } },
          { type: "line", x0: b, x1: b, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } },
          { type: "rect", x0, x1, y0: 0, y1: 1, xref: "x", yref: "paper", fillcolor: "rgba(11,107,203,0.12)", line: { width: 0 } }
        );
      }

      // ★★★ v4.0 変更: 両方のプロットに形状を描画 ★★★
      const plot_ov = plotDivs_Overview[name];
      if (plot_ov) {
        plot_ov.layout.shapes = shapes;
        Plotly.redraw(plot_ov);
      }
      const plot_dt = plotDivs_Detail[name];
      if (plot_dt) {
        plot_dt.layout.shapes = shapes;
        Plotly.redraw(plot_dt);
      }
    }

    function handleClickOnChannel(name, x) {
      // v4.0: この手動クリックは自動セグメント適用によって上書きされる
      const sel = selections[name]; if (!sel) return;
      if (sel.clicks.length >= 2) sel.clicks = [];
      sel.clicks.push(x);
      drawSelectionOnPlot(name);
      const FH = getFH();
      if (FH && name === FH.name) { for (const ch of mapped.channels) { if (ch.name !== FH.name) drawSelectionOnPlot(ch.name); } }
      updateInfoPanel();
    }

    // =============================
    // ★★★ v4.0 追加: 自動セグメントロジック ★★★
    // =============================
    
    function resetAutoSegmentUI() {
      $("#autoSegmentControls").style.display = "none";
      $("#autoSegmentTotal").textContent = "0";
      $("#autoSegmentCurrent").textContent = "0";
      $("#btnPrevSegment").disabled = true;
      $("#btnNextSegment").disabled = true;
      $("#autoStartTime").value = "";
      $("#autoEndTime").value = "";
      $("#autoSegmentStatus").textContent = "";
      autoSegments = [];
      currentSegmentIdx = -1;
    }

    function autoDetectSegments() {
      const FH = getFH();
      if (!FH) {
        alert("エラー: FH (加振力) チャンネルがマッピングされていません。");
        return;
      }
      
      const FS = getFS();
      const fh_signal = FH.data;
      const time_data = mapped.time;
      
      const THRESHOLD_FACTOR = Number($("#autoThreshold").value) || 5;
      const QUIET_MS = Number($("#autoQuietMS").value) || 5;
      const QUIET_SAMPLES = Math.max(1, Math.round((QUIET_MS / 1000) * FS));
      
      // 1. 閾値の決定
      // (簡略化のため、numpy.stdの代わりに全体の平均絶対偏差の定数倍を使用)
      let sum_abs_dev = 0;
      let mean = 0;
      for (const v of fh_signal) mean += v;
      mean /= fh_signal.length;
      for (const v of fh_signal) sum_abs_dev += Math.abs(v - mean);
      const NOISE_FLOOR_ESTIMATE = (sum_abs_dev / fh_signal.length) * 1.25; // MAD -> SD
      
      const DETECTION_THRESHOLD = THRESHOLD_FACTOR * NOISE_FLOOR_ESTIMATE;
      const DECAY_THRESHOLD = 2 * NOISE_FLOOR_ESTIMATE;
      
      const abs_fh = fh_signal.map(v => Math.abs(v));
      
      // 2. インパルスイベントの開始インデックスを特定
      const over_threshold_indices = [];
      for (let i = 0; i < abs_fh.length; i++) {
        if (abs_fh[i] > DETECTION_THRESHOLD) {
          over_threshold_indices.push(i);
        }
      }
      
      if (over_threshold_indices.length === 0) {
        showStatus($("#autoSegmentStatus"), "インパルスが検出されませんでした (閾値が高すぎる可能性があります)。", false);
        resetAutoSegmentUI();
        $("#autoSegmentControls").style.display = "block";
        return;
      }
      
      // 3. インパルスをグループ化 (100ms以上空いたら別)
      const MIN_GAP_SAMPLES = Math.round(0.1 * FS);
      const start_indices = [over_threshold_indices[0]];
      for (let i = 1; i < over_threshold_indices.length; i++) {
        if (over_threshold_indices[i] - over_threshold_indices[i-1] > MIN_GAP_SAMPLES) {
          start_indices.push(over_threshold_indices[i]);
        }
      }
      
      autoSegments = []; // グローバル変数をリセット
      
      for (let i = 0; i < start_indices.length; i++) {
        const start_idx = start_indices[i];
        
        // 4. セグメント開始点 (プリトリガー 10ms)
        const PRE_TRIGGER_SAMPLES = Math.round(0.01 * FS);
        const segment_start_idx = Math.max(0, start_idx - PRE_TRIGGER_SAMPLES);
        
        // 5. ピーク探索 (開始から100ms)
        const peak_search_end = Math.min(fh_signal.length, start_idx + Math.round(0.1 * FS));
        let peak_idx = start_idx;
        let peak_max_val = abs_fh[start_idx];
        
        for (let j = start_idx + 1; j < peak_search_end; j++) {
          if (abs_fh[j] > peak_max_val) {
            peak_max_val = abs_fh[j];
            peak_idx = j;
          }
        }
        
        // 6. 終了インデックスの探索 (減衰基準)
        let segment_end_idx = peak_idx;
        for (let j = peak_idx; j < fh_signal.length - QUIET_SAMPLES; j++) {
          if (abs_fh[j] < DECAY_THRESHOLD) {
            let is_quiet = true;
            for (let k = 1; k < QUIET_SAMPLES; k++) {
              if (abs_fh[j+k] >= DECAY_THRESHOLD) {
                is_quiet = false;
                j += k; // 静かでない点までジャンプ
                break;
              }
            }
            if (is_quiet) {
              segment_end_idx = j + QUIET_SAMPLES;
              break;
            }
          }
        }
        
        // 減衰終了点が見つからない場合のフォールバック (ピーク後 100ms)
        if (segment_end_idx === peak_idx) {
          segment_end_idx = Math.min(fh_signal.length - 1, peak_idx + Math.round(0.1 * FS));
        }

        autoSegments.push({
          Impulse_No: i + 1,
          Start_Time: time_data[segment_start_idx],
          End_Time: time_data[segment_end_idx],
          Peak_Time: time_data[peak_idx],
          FH_Max: peak_max_val,
        });
      }
      
      // 7. UIを更新
      $("#autoSegmentControls").style.display = "block";
      $("#autoSegmentTotal").textContent = autoSegments.length;
      showStatus($("#autoSegmentStatus"), `検出完了: ${autoSegments.length} 件のインパルスが見つかりました。`, true);
      
      if (autoSegments.length > 0) {
        showSegmentDetail(0); // 最初のセグメントを表示
      }
    }
    
    function showSegmentDetail(index) {
      if (index < 0 || index >= autoSegments.length) return;
      
      currentSegmentIdx = index;
      const segment = autoSegments[index];
      
      // 1. ナビゲーションUIを更新
      $("#autoSegmentCurrent").textContent = segment.Impulse_No;
      $("#btnPrevSegment").disabled = (index === 0);
      $("#btnNextSegment").disabled = (index === autoSegments.length - 1);
      
      // 2. 編集UIを更新
      $("#autoStartTime").value = segment.Start_Time.toFixed(6);
      $("#autoEndTime").value = segment.End_Time.toFixed(6);
      
      // 3. 詳細プロットをズーム
      // セグメントの前後にパディングを追加
      const duration = segment.End_Time - segment.Start_Time;
      const PADDING = Math.max(0.02, duration * 0.2); // 20msか20%のどちらか大きい方
      const zoom_start = Math.max(0, segment.Start_Time - PADDING);
      const zoom_end = Math.min(mapped.time[mapped.time.length - 1], segment.End_Time + PADDING);

      const peak_marker = {
        type: 'line',
        x0: segment.Peak_Time, x1: segment.Peak_Time,
        y0: 0, y1: 1, yref: 'paper',
        line: { color: 'red', width: 2, dash: 'dash' }
      };

      for (const ch of mapped.channels) {
        const plot_dt = plotDivs_Detail[ch.name];
        if (plot_dt) {
          // ★★★ v4.0 変更: セレクションとマーカーを両方描画 ★★★
          const current_selection = selections[ch.name];
          const shapes = [];
          if (current_selection && current_selection.clicks.length >= 2) {
             const [a,b] = current_selection.clicks.slice(0,2);
             const x0=Math.min(a,b), x1=Math.max(a,b);
             shapes.push({ type: "rect", x0, x1, y0: 0, y1: 1, xref: "x", yref: "paper", fillcolor: "rgba(11,107,203,0.12)", line: { width: 0 } });
          }
          shapes.push(peak_marker); // ピークマーカーを追加
          
          Plotly.relayout(plot_dt, {
            'xaxis.range': [zoom_start, zoom_end],
            'shapes': shapes
          });
        }
      }
    }
    
    function applyManualSegment() {
      if (currentSegmentIdx < 0) {
        alert("適用するセグメントが選択されていません。");
        return;
      }
      
      const t_start = Number($("#autoStartTime").value);
      const t_end = Number($("#autoEndTime").value);
      
      if (isNaN(t_start) || isNaN(t_end) || t_end <= t_start) {
        alert("エラー: Start/End の値が無効です。");
        return;
      }
      
      // 1. グローバルセレクションを更新
      for (const ch of mapped.channels) {
        selections[ch.name].clicks = [t_start, t_end];
        drawSelectionOnPlot(ch.name); // 両方のプロットの矩形を更新
      }
      
      // 2. Infoパネルを更新
      updateInfoPanel();
      
      // 3. セグメント番号を自動インクリメント
      const segNoInput = $("#segmentNo");
      segNoInput.value = Number(segNoInput.value) + 1;
      
      // 4. ステータス表示
      const seg = autoSegments[currentSegmentIdx];
      showStatus($("#autoSegmentStatus"), `OK: Impulse #${seg.Impulse_No} のセグメント (t=${t_start.toFixed(3)}s - ${t_end.toFixed(3)}s) を適用しました。\nセグメント番号を ${segNoInput.value} に更新。`, true);
      
      // 5. 詳細プロットのズームを維持しつつ、セレクションを更新
      showSegmentDetail(currentSegmentIdx);
    }
    
    // =============================
    // Info Panel
    // =============================
    function selectionStatsFor(ch) {
      const sel = selections[ch.name]; if (!sel || sel.clicks.length < 2) return null;
      const [a,b] = sel.clicks; const x0 = Math.min(a,b), x1 = Math.max(a,b);
      const idxs = idxBetween(mapped.time, x0, x1); if (idxs.length===0) return null;
      const maxv = absMax(ch.data, idxs);
      const minv = (function(){ let m=Infinity; for(const i of idxs){ const v=ch.data[i]; if(v<m) m=v; } return m; })();
      const dur = x1 - x0;
      return { start:x0, end:x1, duration:dur, max:maxv, min:minv };
    }
    function updateInfoPanel() {
      const dt = fhDuration();
      $("#fhInfo").innerHTML = dt ? `<span class="pill">FH Duration = ${fmt(dt)}</span>` : `<span class="muted">FH Duration = 未決定</span>`;
      const rows = [];
      if (mapped) {
        for (const ch of mapped.channels) {
          const st = selectionStatsFor(ch);
          rows.push(`
            <tr>
              <td class="mono nowrap">${ch.name}</td>
              <td>${ch.role}</td>
              <td class="mono right">${st ? fmt(st.start) : ""}</td>
              <td class="mono right">${st ? fmt(st.end) : ""}</td>
              <td class="mono right">${st ? fmt(st.duration) : ""}</td>
              <td class="mono right">${st ? fmt(st.max) : ""}</td>
              <td class="mono right">${st ? fmt(st.min) : ""}</td>
            </tr>`);
        }
      }
      $("#infoTableWrap").innerHTML = `
        <table>
          <thead>
            <tr><th>Channel</th><th>Role</th><th class="right">Start (s)</th><th class="right">End (s)</th><th class="right">Duration (s)</th><th class="right">Max</th><th class="right">Min</th></tr>
          </thead>
          <tbody>${rows.join("")}</tbody>
        </table>`;
    }

    // =============================
    // Metrics（ご提案形式）
    // =============================
    function computeAndRenderMetrics() {
      if (!mapped) throw new Error("データがありません。");
      const fh = mapped.channels.find(c => c.role === "FH");
      const resChs = mapped.channels.filter(c => c.role !== "FH");
      if (!fh) throw new Error("FH チャンネルが必要です。");
      if (resChs.length === 0) throw new Error("FH以外のチャンネルが必要です。");

      const fhSelObj = fhSel(); if (!fhSelObj) throw new Error("FH の範囲が未選択です。");
      const fhIdxs = idxBetween(mapped.time, fhSelObj.clicks[0], fhSelObj.clicks[1]);
      if (fhIdxs.length === 0) throw new Error("FH 範囲にデータ点がありません。");

      const sumAbsS = absSum(fh.data, fhIdxs);
      const maxAbsS = absMax(fh.data, fhIdxs);

      const tbody = $("#metricsBody");
      tbody.innerHTML = "";

      // FH行
      const trFH = document.createElement("tr");
      trFH.innerHTML = `
        <td class="mono nowrap">FH</td>
        <td class="mono right">${fmt(sumAbsS)}</td>
        <td class="mono right">${fmt(maxAbsS)}</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>`;
      tbody.appendChild(trFH);

      const segNo = Number($("#segmentNo").value || 1);
      const sourceFile = ($("#csvUrl").value || ($("#csvFile").files[0]?.name ?? ""));
      summaryRows = []; // reset each compute

      // 応答チャンネル行
      for (const ch of resChs) {
        const sel = selections[ch.name];
        // ★★★ v4.0 変更: FHと同じセレクションを使うように強制 ★★★
        const idxs = idxBetween(mapped.time, fhSelObj.clicks[0], fhSelObj.clicks[1]);
        if (idxs.length === 0) continue; // FHにデータがなければ応答もスキップ

        const sumAbsR_raw = absSum(ch.data, idxs);
        const maxAbsR_raw = absMax(ch.data, idxs);
        const vSum = (ch.role === "Mic") ? (sumAbsR_raw / (rho*c)) : sumAbsR_raw;
        const vMax = (ch.role === "Mic") ? (maxAbsR_raw / (rho*c)) : maxAbsR_raw;
        const F_over_v_Sum = (vSum === 0) ? NaN : (sumAbsS / vSum);
        const F_over_v_Max = (vMax === 0) ? NaN : (maxAbsS / vMax);
        const F_over_v_dB_Sum = (!isFinite(F_over_v_Sum) || F_over_v_Sum<=0) ? NaN : (20*Math.log10(F_over_v_Sum));
        const F_over_v_dB_Max = (!isFinite(F_over_v_Max) || F_over_v_Max<=0) ? NaN : (20*Math.log10(F_over_v_Max));

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="mono nowrap">${ch.name}</td>
          <td class="mono right">${fmt(sumAbsR_raw)}</td>
          <td class="mono right">${fmt(maxAbsR_raw)}</td>
          <td class="mono right">${isFinite(F_over_v_Sum) ? fmt(F_over_v_Sum) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_dB_Sum) ? fmt(F_over_v_dB_Sum) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_Max) ? fmt(F_over_v_Max) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_dB_Max) ? fmt(F_over_v_dB_Max) : ""}</td>`;
        tbody.appendChild(tr);

        // export用
        summaryRows.push({
          SourceFile: sourceFile,
          SegmentFile: `combined_segment_${segNo}.csv`,
          Channel: ch.name,
          "Sum Abs(S)": sumAbsS,
          "Max_abs(S)": maxAbsS,
          "Sum Abs(R)": sumAbsR_raw,
          "Max_abs(R)": maxAbsR_raw,
          "F/v_Sum": F_over_v_Sum,
          "F/v_dB_Sum": F_over_v_dB_Sum,
          "F/v_Max": F_over_v_Max,
          "F/v_dB_Max": F_over_v_dB_Max
        });
      }
    }

    // =============================
    // Exporters
    // =============================
    function exportCombinedSegment() {
      if (!mapped) throw new Error("データがありません。");
      // ★★★ v4.0 変更: 全チャネルがFHと同じセレクションを持つことを前提とする ★★★
      const fhSelObj = fhSel();
      if (!fhSelObj) throw new Error("FH の範囲が未選択です。");
      
      const [t0_fh, t1_fh] = fhSelObj.clicks;
      const t0 = Math.min(t0_fh, t1_fh);
      const t1 = Math.max(t0_fh, t1_fh);

      const slices = {};
      let minLen = Infinity;

      // FHと同じ時間範囲で全チャネルをスライス
      const tIdxs = idxBetween(mapped.time, t0, t1);
      const tSlice = tIdxs.map(i => mapped.time[i]);
      minLen = tIdxs.length;

      if (minLen === 0) throw new Error("選択範囲にデータ点がありません。");

      for (const ch of mapped.channels) {
        slices[ch.name] = tIdxs.map(i => ch.data[i]);
      }

      const segNo = Number($("#segmentNo").value || 1);
      const cols = ["Time (s)", ...mapped.channels.map(ch => ch.name)];
      let csv = cols.join(",") + "\n";
      for (let i = 0; i < minLen; i++) {
        const vals = mapped.channels.map(ch => slices[ch.name][i]);
        csv += [tSlice[i].toFixed(10), ...vals].join(",") + "\n";
      }
      downloadText(`combined_segment_${segNo}.csv`, csv);
      // ★★★ v4.0 変更: セグメント番号は自動適用時にインクリメントされるため、ここではしない ★★★
      // $("#segmentNo").value = String(segNo + 1); 
      showStatus($("#autoSegmentStatus"), `combined_segment_${segNo}.csv をエクスポートしました。`, true);
    }
    
    function exportSummaryCSV() {
      if (summaryRows.length === 0) { alert("先に「メトリクス計算」を実行してください。"); return; }
      const cols = ["SourceFile","SegmentFile","Channel","Sum Abs(S)","Max_abs(S)","Sum Abs(R)","Max_abs(R)","F/v_Sum","F/v_dB_Sum","F/v_Max","F/v_dB_Max"];
      let csv = cols.join(",") + "\n";
      for (const r of summaryRows) {
        csv += cols.map(k => {
          const v = r[k];
          if (typeof v === "number") return Number.isFinite(v) ? v.toFixed(6) : "";
          return (v ?? "");
        }).join(",") + "\n";
      }
      downloadText("calculation_summary.csv", csv);
    }

    // =============================
    // Event Wiring
    // =============================
    $("#btnLoadUrl").addEventListener("click", async () => {
      try {
        const url = $("#csvUrl").value.trim();
        if (!url) return alert("CSV URL を入力してください。");
        await loadCSVFromURL(url);
        showStatus($("#urlStatus"), "URL読み込み成功", true);
        markInputState($("#csvUrl"), true);
        markRowState($("#urlRow"), true);
      } catch (e) {
        console.error(e);
        showStatus($("#urlStatus"), `URL読み込み失敗: ${e.message}`, false);
        markInputState($("#csvUrl"), false);
        markRowState($("#urlRow"), false);
      }
    });
    $("#btnLoadFile").addEventListener("click", async () => {
      try {
        const f = $("#csvFile").files[0];
        if (!f) return alert("CSVファイルを選択してください。");
        await loadCSVFromFile(f);
        showStatus($("#fileStatus"), "ファイル読み込み成功", true);
        markRowState($("#fileRow"), true);
      } catch (e) {
        console.error(e);
        showStatus($("#fileStatus"), `ファイル読み込み失敗: ${e.message}`, false);
        markRowState($("#fileRow"), false);
      }
    });
    $("#btnApplyMapping").addEventListener("click", () => { try { applyMapping(); } catch (e) { console.error(e); showStatus($("#mapStatus"), `エラー: ${e.message}`, false); } });
    $("#btnResetMapping").addEventListener("click", () => {
      buildMappingUI();
      $("#plots_overview").innerHTML = ""; $("#plots_detail").innerHTML = "";
      $("#infoTableWrap").innerHTML = ""; $("#fhInfo").textContent = ""; $("#metricsBody").innerHTML = "";
      selections = {}; plotDivs_Overview = {}; plotDivs_Detail = {}; summaryRows = [];
      resetAutoSegmentUI();
      showStatus($("#mapStatus"), "マッピングをリセットしました。", true);
    });
    $("#btnPreset1").addEventListener("click", applyPreset1);
    $("#btnClearSelections").addEventListener("click", () => {
      Object.keys(selections).forEach(name => { selections[name].clicks = []; selections[name].guide = null; });
      $$("#plots_overview .plot-card > div:last-child").forEach(plot => { plot.layout = plot.layout || {}; plot.layout.shapes = []; Plotly.redraw(plot); });
      $$("#plots_detail .plot-card > div:last-child").forEach(plot => { plot.layout = plot.layout || {}; plot.layout.shapes = []; Plotly.redraw(plot); });
      updateInfoPanel();
    });
    $("#btnCompute").addEventListener("click", () => { try { computeAndRenderMetrics(); } catch (e) { alert(e.message); } });
    $("#btnExportSegment").addEventListener("click", () => { try { exportCombinedSegment(); } catch (e) { alert(e.message); } });
    $("#btnExportSummary").addEventListener("click", () => { exportSummaryCSV(); });
    
    // ★★★ v4.0 追加: イベントリスナー ★★★
    $("#btnAutoDetect").addEventListener("click", () => { try { autoDetectSegments(); } catch (e) { alert(e.message); console.error(e); } });
    $("#btnPrevSegment").addEventListener("click", () => { showSegmentDetail(currentSegmentIdx - 1); });
    $("#btnNextSegment").addEventListener("click", () => { showSegmentDetail(currentSegmentIdx + 1); });
    $("#btnApplyManualSegment").addEventListener("click", () => { try { applyManualSegment(); } catch (e) { alert(e.message); } });
    // ★★★ v4.0 追加ここまで ★★★

  </script>
</body>
</html>
