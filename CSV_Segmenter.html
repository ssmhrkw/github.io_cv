<!DOCTYPE html>
<html lang="ja">
<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HFR5WYG42Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-HFR5WYG42Q'); // ページビュー自動送信
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSV Segmenter (Web) v4.3 (Hybrid+Delay)</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root {
      --bg: #faf6ed;
      --card: #ffffff;
      --muted: #5b6b7a;
      --text: #1e293b;
      --accent: #0b6bcb;
      --warn: #c77d00;
      --danger: #c92a2a;
      --ok: #13795b;
      --border: #e2e8f0;
      --soft: #f6f8fb;
      --ok-bg: #e6f7ef;
      --ok-br: #86e1b5;
      --ng-bg: #fdecec;
      --ng-br: #f5a3a3;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 0;
      font-family: "Hiragino Kaku Gothic ProN", "Meiryo", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: var(--bg);
      min-height: 100vh;
    }
    header {
      padding: 18px 20px 10px;
      border-bottom: 1px solid var(--border);
      position: sticky; top: 0; background: rgba(255,255,255,0.85); backdrop-filter: blur(8px);
      z-index: 10;
    }
    header h1 { margin: 0 0 6px; font-size: 18px; font-weight: 700; letter-spacing: 0.2px; color: #0f2e54; }
    header p { margin: 0; font-size: 12px; color: var(--muted); }
    main { padding: 16px; max-width: 1600px; margin: 0 auto; }
    
    /* ★★★ v4.3 変更: メインレイアウトを3列に ★★★ */
    .grid { display: grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 1280px) {
      .grid-3-col {
        grid-template-columns: 1.2fr 1fr 1fr; /* 左:設定 | 中:全体 | 右:詳細 */
      }
    }
    
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px; padding: 14px;
      box-shadow: 0 6px 16px rgba(148,163,184,0.15);
      display: flex; /* v4.3: 内部フレックス */
      flex-direction: column; /* v4.3: 縦積み */
    }
    .card h2 { margin: 0 0 10px; font-size: 16px; color: #0f2e54; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    label { font-size: 12px; color: var(--text); }
    input[type="text"], input[type="number"], select {
      background: #fff; color: var(--text); border: 1px solid var(--border);
      border-radius: 10px; padding: 8px 10px; font-size: 13px; outline: none;
      transition: box-shadow .2s ease, border-color .2s ease, background .2s ease;
    }
    input[type="number"] { width: 100px; }
    input.ok-state { background: var(--ok-bg); border-color: var(--ok-br); box-shadow: 0 0 0 3px rgba(19,121,91,0.12); }
    input.ng-state { background: var(--ng-bg); border-color: var(--ng-br); box-shadow: 0 0 0 3px rgba(201,42,42,0.12); }
    .file-wrap { padding: 6px 10px; border: 1px dashed var(--border); border-radius: 10px; background: #fff; }
    .file-wrap.ok-state { background: var(--ok-bg); border-color: var(--ok-br); }
    .file-wrap.ng-state { background: var(--ng-bg); border-color: var(--ng-br); }
    button {
      appearance: none; border: 1px solid var(--border); color: var(--text);
      background: #fff;
      padding: 8px 12px; font-size: 13px; border-radius: 12px; cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    button:hover { border-color: #b6c3d2; box-shadow: 0 2px 8px rgba(15,46,84,0.06); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #0b6bcb; color: #fff; border-color: #0b6bcb; }
    .btn-green { background: #0b8f6b; color: #fff; border-color: #0b8f6b; }
    .btn-outline { background: transparent; }
    .muted { color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; color: #334155; }
    .danger { color: var(--danger); }
    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
    .mapping-table { width: 100%; border-collapse: collapse; }
    .mapping-table th, .mapping-table td { border-bottom: 1px dashed var(--border); padding: 6px 8px; font-size: 12px; }
    .mapping-table th { text-align: left; color: #0f2e54; }
    
    /* ★★★ v4.3 変更: プロットグリッド ★★★ */
    .plots { 
      display: grid; 
      /* 最小300px、最大1fr(均等)で自動的に列を分割 */
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
      gap: 12px; 
      width: 100%;
    }
    .plot-card { 
      background: var(--soft); border: 1px solid var(--border); 
      border-radius: 12px; padding: 8px; 
      flex-grow: 1; /* v4.3: 領域いっぱいに広がる */
    }
    .plot-title { margin: 0 0 6px; font-size: 13px; color: #0f2e54; }
    
    .kpi-row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
    @media (min-width: 1200px) { .kpi-row { grid-template-columns: repeat(4, 1fr); } }
    .kpi { background: #fff; border: 1px solid var(--border); border-radius: 12px; padding: 10px; }
    table.metrics { width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed; }
    table.metrics th, table.metrics td { border-bottom: 1px solid var(--border); padding: 6px 8px; }
    table.metrics th { text-align: left; color: #0f2e54; position: sticky; top: 0; background: #fff; z-index: 1; }
    table.metrics td, table.metrics th { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .pill { display: inline-block; font-size: 11px; padding: 2px 8px; border-radius: 999px; background: #eef2f7; border: 1px solid #d8e0ea; }
    .footer-note { font-size: 11px; color: var(--muted); }
    .help { font-size: 12px; color: var(--muted); }
    .vspacer { height: 6px; }
    .hr { border: none; border-top: 1px dashed var(--border); margin: 10px 0; }
    .right { text-align: right; }
    .nowrap { white-space: nowrap; }
    
    /* ★★★ v4.3 削除: infoPanel スタイルは不要に ★★★ */
    
    .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: middle; }
    .status-ok { background: #22c55e; }
    .status-ng { background: #ef4444; }
    
    #autoSegmentControls {
      background: var(--soft); border: 1px solid var(--border);
      border-radius: 12px; padding: 12px;
      display: none; /* 初期状態は非表示 */
      margin-top: 10px;
    }
    #autoSegmentControls .row { justify-content: space-between; }
    #autoSegmentControls input[type="number"] { width: 120px; font-size: 14px; }
    #autoSegmentControls h4 { margin: 0 0 10px; color: #0f2e54; }
    #autoSegmentNav { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
    #autoSegmentNav span { font-size: 16px; font-weight: bold; color: var(--accent); }
    #autoSegmentEdit { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    #autoSegmentEdit label { font-size: 13px; }
    
    .help-box {
        background: #f0f4f8; border: 1px solid #d0d8e0; border-radius: 8px;
        padding: 8px 10px; font-size: 11px; color: #334155; margin: 5px 0 0;
    }
  </style>
</head>
<body>
  <header>
    <h1>CSV Segmenter (Web) — v4.3 (Hybrid+Delay)</h1>
    <p class="muted"></p>
  </header>

  <main class="grid grid-3-col">
    <section class="card">
      <h2>1) データ入力</h2>
      <div class="row" id="urlRow">
        <label>CSV URL:</label>
        <input id="csvUrl" type="text" placeholder="/data/sample.csv または https://raw.githubusercontent.com/USER/REPO/BRANCH/path/to.csv" style="flex:1" />
        <button id="btnLoadUrl" class="btn-primary">URLから読み込む</button>
        <span id="urlStatus" class="muted"></span>
      </div>
      <div class="vspacer"></div>
      <div class="row file-wrap" id="fileRow">
        <label>ローカルCSV:</label>
        <input id="csvFile" type="file" accept=".csv" />
        <button id="btnLoadFile">ファイル読み込み</button>
        <span id="fileStatus" class="muted">（UTF-8推奨）</span>
      </div>

      <hr class="hr" />
      <h2>2) チャンネル・マッピング</h2>
      <p class="help">Mic 選択時は距離(m)を指定。Timeが無い場合 <span class="mono">Time (s)=index/Fs</span> を自動生成。</p>
      <div id="mappingArea" class="mono muted">CSV読み込み後に自動生成します。</div>
      <div class="vspacer"></div>
      <div class="row">
        <button id="btnApplyMapping" class="btn-green">マッピング適用 / 反映</button>
        <button id="btnResetMapping" class="btn-outline">リセット</button>
        <button id="btnPreset1" class="btn-outline">プリセット1（Time, FH, Acc, Acc, Mic×5）</button>
        <span id="mapStatus" class="muted"></span>
      </div>

      <hr class="hr" />
      <h2>3) ツール</h2>
      <div class="kpi-row">
        <div class="kpi">
          <div class="muted">サンプリング周波数 (Hz)</div>
          <input id="samplingRate" type="number" value="51200" step="100" />
        </div>
        <div class="kpi">
          <div class="muted">セグメント番号</div>
          <div class="row">
            <input id="segmentNo" type="number" value="1" min="1" step="1" />
            <button id="btnClearSelections" class="btn-outline">全選択クリア</button>
          </div>
        </div>
        <div class="kpi">
          <div class="muted">計算</div>
          <div class="row">
            <button id="btnCompute" class="btn-primary">メトリクス計算</button>
          </div>
        </div>
        <div class="kpi">
          <div class="muted">エクスポート</div>
          <div class="row">
            <button id="btnExportSummary" class="btn-outline">calculation_summary.csv</button>
          </div>
        </div>
      </div>
      <p class="help"><b>推奨ワークフロー:</b> 4) 自動セグメント → 「1. インパルス自動検出」 → 「2. Ch別セグメントを自動適用」 → プレビューで個別にクリックして微調整 → 「メトリクス計算」。</p>

      <hr class="hr" />
      <h2>4) 自動セグメント (Auto-Segment)</h2>
      <p class="help">FHチャネルに基づき、インパルス（ピーク）を自動検出します。</p>
      <div class="row" style="gap: 12px;">
        <label>検出閾値 (x * Noise SD):</label>
        <input id="autoThreshold" type="number" value="5" step="0.5" style="width:80px;" />
        <label>静音期間 (ms):</label>
        <input id="autoQuietMS" type="number" value="10" step="1" style="width:80px;" />
        <button id="btnAutoDetect" class="btn-primary" style="flex:1;">1. インパルス自動検出</button>
      </div>
      <div class="help-box">
        <b>検出閾値:</b> ノイズの標準偏差(SD)の何倍の大きさの信号を「インパルス開始」と見なすか。 <br />
        <b>静音期間:</b> ピーク後、ノイズレベルに戻った状態が何ミリ秒続いたら「インパルス終了」と見なすか。
      </div>
      
      <div id="autoSegmentControls">
        <h4>検出されたインパルス: <span id="autoSegmentTotal" class="ok">0</span> 件</h4>
        <div id="autoSegmentNav" class="row">
          <button id="btnPrevSegment" class="btn-outline" disabled>&lt; 前 (Prev)</button>
          <span class="mono">Impulse #<span id="autoSegmentCurrent">0</span></span>
          <button id="btnNextSegment" class="btn-outline" disabled>次 (Next) &gt;</button>
        </div>
        <div id="autoSegmentEdit" class="row">
          <label>FH Start (s):</label>
          <input id="autoStartTime" type="number" step="0.0001" />
          <label>FH End (s):</label>
          <input id="autoEndTime" type="number" step="0.0001" />
          <button id="btnApplyAutoHybrid" class="btn-green" style="flex:1;">2. Ch別セグメントを自動適用</button>
        </div>
        <div id="autoSegmentStatus" class="muted" style="margin-top: 8px;"></div>
      </div>

      <div class="vspacer"></div>
      <h3 class="muted">Metrics（ご提案形式）</h3>
      <div style="overflow:auto; max-height: 260px;">
        <table class="metrics" id="metricsTable">
          <thead>
            <tr>
              <th style="width:120px">Channel</th>
              <th>Sum Abs</th>
              <th>Max_abs</th>
              <th>F/v_Sum</th>
              <th>F/v_dB_Sum</th>
              <th>F/v_Max</th>
              <th>F/v_dB_Max</th>
            </tr>
          </thead>
          <tbody id="metricsBody"></tbody>
        </table>
      </div>
      <p class="footer-note">Micは v = p/(ρc) に変換（ρ≈1.21kg/m³, c=343m/s）。Accはそのままvとして扱います。</p>
    </section>

    <section class="card">
      <h2>プレビュー (全体)</h2>
      <p class="help">グラフをクリックして、チャネルごとにセグメント範囲（2点）を指定できます。</p>
      <div id="plots_overview" class="plots"></div>
    </section>
    
    <section class="card">
      <h2>プレビュー (詳細セグメント)</h2>
      <p class="help">「自動セグメント」で選択中のインパルスを拡大表示します。ここでもクリックして微調整可能です。</p>
      <div id="plots_detail" class="plots"></div>
      
      <hr class="hr" style="margin-top:auto; padding-top: 10px;"> <div class="row">
          <button id="btnExportSegmentDetail" class="btn-primary" style="flex:1;">
              現在のセグメント (combined_segment_#.csv) を保存
          </button>
      </div>
    </section>
  </main>

  <script>
    // =============================
    // Constants & Global State
    // =============================
    // const FS = 51200; // v4.3: 動的に取得
    const rho = 1.21, c = 343;
    let rawRows = [];
    let headers = [];
    let mapping = [];
    let mapped = null;
    let selections = {};
    
    let plotDivs_Overview = {};
    let plotDivs_Detail = {};
    
    let autoSegments = [];
    let currentSegmentIdx = -1;
    
    let summaryRows = []; // export用

    // =============================
    // Helpers
    // =============================
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    
    const getFS = () => Number($("#samplingRate").value) || 51200;

    function showStatus(el, msg, ok=true) {
      el.innerHTML = (ok ? '<span class="status-dot status-ok"></span>' : '<span class="status-dot status-ng"></span>') + msg;
      el.className = ok ? "muted ok" : "muted danger";
    }
    function markInputState(el, ok=true) {
      el.classList.remove("ok-state","ng-state");
      el.classList.add(ok ? "ok-state" : "ng-state");
    }
    function markRowState(row, ok=true) {
      row.classList.remove("ok-state","ng-state");
      row.classList.add(ok ? "ok-state" : "ng-state");
    }
    function downloadText(filename, text) {
      const blob = new Blob([text], {type: "text/csv;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    }
    function ensureUniqueName(base, existing) {
      if (!existing.has(base)) return base;
      let idx = 2;
      while (existing.has(`${base}_${idx}`)) idx++;
      return `${base}_${idx}`;
    }
    function autoTimeIfMissing(rows) {
      const timeKey = headers.find(h => h.toLowerCase().trim() === "time (s)");
      if (timeKey) return rows.map((r,i)=> Number(r[timeKey]));
      const FS = getFS();
      return rows.map((_,i) => i / FS);
    }
    function toFloatArray(rows, key) {
      const arr = new Float64Array(rows.length);
      for (let i = 0; i < rows.length; i++) {
        const v = rows[i][key];
        arr[i] = (v === null || v === undefined || v === "" || isNaN(Number(v))) ? 0 : Number(v);
      }
      return arr;
    }
    function idxBetween(time, t0, t1) {
      const lo = Math.min(t0, t1), hi = Math.max(t0, t1);
      const idxs = [];
      for (let i = 0; i < time.length; i++) {
        const t = time[i];
        if (t >= lo && t <= hi) idxs.push(i);
      }
      return idxs;
    }
    function absSum(arr, idxs) { let s = 0; for (const i of idxs) s += Math.abs(arr[i]); return s; }
    function absMax(arr, idxs) { let m = 0; for (const i of idxs) { const v = Math.abs(arr[i]); if (v > m) m = v; } return m; }
    function absMin(arr, idxs) { let m = Infinity; for (const i of idxs) { const v = arr[i]; if (v < m) m = v; } return m; }
    function fmt(v, d=2) { return (v===null || v===undefined || !isFinite(v)) ? "" : Number(v).toFixed(d); }

    // FH helpers
    function getFH() { return mapped ? (mapped.channels.find(c => c.role === "FH") || null) : null; }
    function fhSel() { const fh = getFH(); if (!fh) return null; const s = selections[fh.name]; return (s && s.clicks.length>=2) ? s : null; }
    function fhClicks() { const s = fhSel(); return s ? s.clicks.slice(0,2) : null; }
    function fhDuration() { const cks = fhClicks(); return cks ? Math.abs(cks[1]-cks[0]) : null; }
    
    // ★★★ v4.3 変更: selectionStatsForをヘルパーとして復活 (v4.2から) ★★★
    function selectionStatsFor(ch) {
      const sel = selections[ch.name];
      if (!sel) return null;
      
      let t0, t1;
      if (sel.clicks.length === 1 && sel.guide) {
          t0 = sel.guide.x0; t1 = sel.guide.x1;
      } else if (sel.clicks.length >= 2) {
          t0 = sel.clicks[0]; t1 = sel.clicks[1];
      } else {
          return null; // 選択未完了
      }

      const x0 = Math.min(t0, t1), x1 = Math.max(t0, t1);
      const idxs = idxBetween(mapped.time, x0, x1); if (idxs.length===0) return null;
      const maxv = absMax(ch.data, idxs);
      const minv = (function(){ let m=Infinity; for(const i of idxs){ const v=ch.data[i]; if(v<m) m=v; } return m; })();
      const dur = x1 - x0;
      return { start:x0, end:x1, duration:dur, max:maxv, min:minv };
    }


    // =============================
    // CSV Loading
    // =============================
    async function loadCSVFromURL(url) {
      const res = await fetch(url, {mode: "cors"});
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      const text = await res.text();
      return parseCSVText(text);
    }
    function parseCSVText(text) {
      const out = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
      if (out.errors && out.errors.length) console.warn("Papa parse errors:", out.errors);
      
      rawRows = out.data;
      headers = (out.meta.fields || Object.keys(rawRows[0] || {})).map(h => h.trim());
      if (out.meta.fields) {
          rawRows = rawRows.map(row => {
              const newRow = {};
              for (const key in row) {
                  newRow[key.trim()] = row[key];
              }
              return newRow;
          });
      }

      buildMappingUI();
      $("#plots_overview").innerHTML = "";
      $("#plots_detail").innerHTML = "";
      // $("#infoTableWrap").innerHTML = ""; // v4.3: 削除
      // $("#fhInfo").textContent = ""; // v4.3: 削除
      $("#metricsBody").innerHTML = "";
      selections = {};
      plotDivs_Overview = {};
      plotDivs_Detail = {};
      summaryRows = [];
      resetAutoSegmentUI();
      return true;
    }
    function loadCSVFromFile(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => { try { parseCSVText(reader.result); resolve(true); } catch (e) { reject(e); } };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file, "utf-8");
      });
    }

    // =============================
    // Mapping UI
    // =============================
    function buildMappingUI() {
      mapping = headers.map(h => ({ src: h, role: "Ignore", distance: "" }));
      const container = document.getElementById("mappingArea");
      const rowsHtml = headers.map((h, i) => {
        return `
          <tr>
            <td class="mono nowrap">${i+1}</td>
            <td class="mono">${h}</td>
            <td>
              <select data-idx="${i}" class="role">
                <option value="Ignore">Ignore</option>
                <option value="FH">FH</option>
                <option value="Acc">Acc</option>
                <option value="Mic">Mic</option>
                <option value="Time">Time (s)</option>
              </select>
            </td>
            <td>
              <input type="number" step="0.1" min="0" placeholder="Mic距離(m)" class="dist" data-idx="${i}" />
            </td>
          </tr>
        `;
      }).join("");
      container.innerHTML = `
        <table class="mapping-table">
          <thead><tr><th>#</th><th>CSV列名</th><th>役割</th><th>Mic距離(m)</th></tr></thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      `;
    }

    function applyMapping() {
      $$("#mappingArea select.role").forEach(sel => { const i = Number(sel.dataset.idx); mapping[i].role = sel.value; });
      $$("#mappingArea input.dist").forEach(inp => { const i = Number(inp.dataset.idx); mapping[i].distance = inp.value ? Number(inp.value) : ""; });

      const usedNames = new Set();
      const timeAuto = autoTimeIfMissing(rawRows);
      const channels = [];
      mapping.forEach((m, i) => {
        if (m.role === "Ignore" || m.role === "Time") return;
        let base = m.role;
        if (m.role === "Mic") {
          const d = (typeof m.distance === "number" && !isNaN(m.distance)) ? m.distance : null;
          base = d !== null ? `Mic(${d.toFixed(1)}m)` : "Mic";
        }
        const name = ensureUniqueName(base, usedNames);
        usedNames.add(name);
        channels.push({ name, role: m.role, src: mapping[i].src, data: toFloatArray(rawRows, mapping[i].src), distance: m.distance });
      });
      const timeIdx = mapping.findIndex(m => m.role === "Time");
      const timeFinal = (timeIdx >= 0) ? toFloatArray(rawRows, mapping[timeIdx].src) : Float64Array.from(timeAuto);
      if (channels.length === 0) throw new Error("データチャンネルがありません。");
      mapped = { time: timeFinal, channels };
      showStatus($("#mapStatus"), `OK: ${channels.length}ch 反映 (FH:${channels.filter(c=>c.role==='FH').length}, Acc:${channels.filter(c=>c.role==='Acc').length}, Mic:${channels.filter(c=>c.role==='Mic').length})`, true);
      renderPlots();
      // updateInfoPanel(); // v4.3: 削除
      resetAutoSegmentUI();
    }

    // プリセット1：Time, FH, Acc, Acc, Mic×5
    function applyPreset1() {
      const seq = ["Time","FH","Acc","Acc","Mic","Mic","Mic","Mic","Mic"];
      const selects = $$("#mappingArea select.role");
      for (let i = 0; i < selects.length; i++) {
        const role = (i < seq.length) ? seq[i] : "Ignore";
        selects[i].value = role;
        mapping[i].role = role;
      }
      showStatus($("#mapStatus"), "プリセット1を適用しました。必要に応じて距離(m)を入力してください。", true);
      try { applyMapping(); } catch (e) { console.error(e); showStatus($("#mapStatus"), `エラー: ${e.message}`, false); }
    }

    // =============================
    // Plotting & Selection (v4.3)
    // =============================
    function renderPlots() {
      const wrap_overview = $("#plots_overview"); wrap_overview.innerHTML = "";
      const wrap_detail = $("#plots_detail"); wrap_detail.innerHTML = "";
      
      plotDivs_Overview = {};
      plotDivs_Detail = {};
      selections = {};
      
      for (const ch of mapped.channels) {
        // --- 1. 全体(Overview)プロット ---
        const div_ov = document.createElement("div");
        div_ov.className = "plot-card";
        const title_ov = document.createElement("div");
        title_ov.className = "plot-title";
        title_ov.textContent = `Channel: ${ch.name} (${ch.role})`;
        const plot_ov = document.createElement("div");
        plot_ov.style.height = "200px";
        plot_ov.dataset.chan = ch.name;
        div_ov.appendChild(title_ov); div_ov.appendChild(plot_ov); wrap_overview.appendChild(div_ov);
        plotDivs_Overview[ch.name] = plot_ov;

        const trace = { x: Array.from(mapped.time), y: Array.from(ch.data), mode: "lines", line: { width: 1 }, hoverinfo: "x+y", name: ch.name };
        const layout_ov = {
          margin: { l: 40, r: 10, t: 30, b: 22 }, // v4.3: tを30に (Annotateのため)
          xaxis: { title: "Time (s)", color: "#1f2937" },
          yaxis: { title: "Amp.", color: "#1f2937" },
          shapes: [], annotations: [], // v4.3: Annotations追加
          showlegend: false, paper_bgcolor: "#ffffff", plot_bgcolor: "#ffffff", font: { color: "#1f2937" },
        };
        Plotly.newPlot(plot_ov, [trace], layout_ov, { responsive: true });

        // --- 2. 詳細(Detail)プロット ---
        const div_dt = document.createElement("div");
        div_dt.className = "plot-card";
        const title_dt = document.createElement("div");
        title_dt.className = "plot-title";
        title_dt.textContent = `Channel: ${ch.name} (${ch.role})`;
        const plot_dt = document.createElement("div");
        plot_dt.style.height = "200px";
        plot_dt.dataset.chan = ch.name;
        div_dt.appendChild(title_dt); div_dt.appendChild(plot_dt); wrap_detail.appendChild(div_dt);
        plotDivs_Detail[ch.name] = plot_dt;
        
        const layout_dt = JSON.parse(JSON.stringify(layout_ov));
        layout_dt.xaxis.range = [mapped.time[0], mapped.time[0] + 0.1];
        Plotly.newPlot(plot_dt, [trace], layout_dt, { responsive: true });
        
        // --- 3. セレクション管理 (v3.3 準拠) ---
        selections[ch.name] = { clicks: [], guide: null };

        plot_ov.on("plotly_click", (ev) => {
          if (!ev || !ev.points || !ev.points.length) return;
          handleClickOnChannel(ch.name, ev.points[0].x);
        });
        plot_dt.on("plotly_click", (ev) => {
          if (!ev || !ev.points || !ev.points.length) return;
          handleClickOnChannel(ch.name, ev.points[0].x);
        });
      }
    }
    
    // ★★★ v4.3 変更: Annotate機能を追加 ★★★
    function drawSelectionOnPlot(name) {
      const plot_ov = plotDivs_Overview[name];
      const plot_dt = plotDivs_Detail[name];
      if (!plot_ov || !plot_dt) return;
      
      const sel = selections[name];
      const shapes = [];
      const annotations = [];
      const FH = getFH();
      
      let dt_guide = null;
      if (FH && name !== FH.name) {
          const fhSelObj = fhSel();
          if (fhSelObj) dt_guide = Math.abs(fhSelObj.clicks[1] - fhSelObj.clicks[0]);
      }
      
      // v3.3/v4.2のガイドロジックを再利用
      if (sel.clicks.length === 1 && dt_guide && isFinite(dt_guide)) {
        const x0 = sel.clicks[0]; const x1 = x0 + dt_guide;
        shapes.push(
          { type: "rect", x0, x1, y0: 0, y1: 1, xref: "x", yref: "paper",
            fillcolor: "rgba(255,170,0,0.18)", line: { color: "rgba(199,125,0,0.8)", width: 1, dash: "dot" } },
          { type: "line", x0, x1: x0, y0: 0, y1: 1, xref: "x", yref: "paper",
            line: { color: "#c77d00", width: 2, dash: "dot" } }
        );
        sel.guide = { x0, x1, dt: dt_guide };
      } else { 
        sel.guide = null; 
        if (sel.clicks.length === 1) {
          const x0 = sel.clicks[0];
          shapes.push({ type: "line", x0, x1: x0, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } });
        } else if (sel.clicks.length >= 2) {
          const [a,b] = sel.clicks.slice(0,2); const x0 = Math.min(a,b), x1 = Math.max(a,b);
          shapes.push(
            { type: "line", x0: a, x1: a, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } },
            { type: "line", x0: b, x1: b, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } },
            { type: "rect", x0, x1, y0: 0, y1: 1, xref: "x", yref: "paper", fillcolor: "rgba(11,107,203,0.12)", line: { width: 0 } }
          );
        }
      }
      
      // ★★★ v4.3 追加: ここでAnnotateを生成 ★★★
      const st = selectionStatsFor(mapped.channels.find(c => c.name === name));
      if (st) {
          const annot_text = `<b>${fmt(st.start, 4)}s - ${fmt(st.end, 4)}s</b> (Dur: ${fmt(st.duration, 4)}s | Max: ${fmt(st.max, 2)})`;
          annotations.push({
              text: annot_text,
              align: 'left', x: 0.01, y: 1.15, // y=1.15でタイトルの上
              xref: 'paper', yref: 'paper',
              showarrow: false, font: {size: 10, color: '#0f2e54'},
              bgcolor: 'rgba(255,255,255,0.0)'
          });
      }

      // 詳細プロットのPeakマーカーを維持
      if (currentSegmentIdx >= 0) {
          const segment = autoSegments[currentSegmentIdx];
          shapes.push({
            type: 'line',
            x0: segment.Peak_Time, x1: segment.Peak_Time,
            y0: 0, y1: 1, yref: 'paper',
            line: { color: 'red', width: 2, dash: 'dash' }
          });
      }
      
      Plotly.relayout(plot_ov, { shapes: shapes, annotations: annotations });
      Plotly.relayout(plot_dt, { shapes: shapes, annotations: annotations });
    }

    function handleClickOnChannel(name, x) {
      const sel = selections[name]; if (!sel) return;
      
      if (sel.clicks.length >= 2) sel.clicks = []; 
      sel.clicks.push(x);
      
      drawSelectionOnPlot(name); 
      
      const FH = getFH();
      if (FH && name === FH.name) { 
        for (const ch of mapped.channels) {
          if (ch.name !== FH.name && selections[ch.name].clicks.length === 1) {
            drawSelectionOnPlot(ch.name);
          }
        }
      }
      // updateInfoPanel(); // v4.3: 削除 (drawSelectionOnPlotが担当)
    }

    // =============================
    // Auto Segment (v4.3)
    // =============================
    
    function resetAutoSegmentUI() {
      $("#autoSegmentControls").style.display = "none";
      $("#autoSegmentTotal").textContent = "0";
      $("#autoSegmentCurrent").textContent = "0";
      $("#btnPrevSegment").disabled = true;
      $("#btnNextSegment").disabled = true;
      $("#autoStartTime").value = "";
      $("#autoEndTime").value = "";
      $("#autoSegmentStatus").textContent = "";
      autoSegments = [];
      currentSegmentIdx = -1;
    }

    function autoDetectSegments() {
      const FH = getFH();
      if (!FH) {
        alert("エラー: FH (加振力) チャンネルがマッピングされていません。");
        return;
      }
      
      const FS = getFS();
      const fh_signal = FH.data;
      const time_data = mapped.time;
      
      const THRESHOLD_FACTOR = Number($("#autoThreshold").value) || 5;
      const QUIET_MS = Number($("#autoQuietMS").value) || 10;
      const QUIET_SAMPLES = Math.max(1, Math.round((QUIET_MS / 1000) * FS));
      
      let sum = 0;
      for (const v of fh_signal) sum += v;
      const mean = sum / fh_signal.length;
      let sum_abs_dev = 0;
      for (const v of fh_signal) sum_abs_dev += Math.abs(v - mean);
      const NOISE_FLOOR_ESTIMATE = (sum_abs_dev / fh_signal.length) * 1.25; // MAD -> SD
      
      const DETECTION_THRESHOLD = THRESHOLD_FACTOR * NOISE_FLOOR_ESTIMATE;
      const DECAY_THRESHOLD = 2 * NOISE_FLOOR_ESTIMATE;
      
      const abs_fh = fh_signal.map(v => Math.abs(v));
      
      const over_threshold_indices = [];
      for (let i = 0; i < abs_fh.length; i++) {
        if (abs_fh[i] > DETECTION_THRESHOLD) {
          over_threshold_indices.push(i);
        }
      }
      
      if (over_threshold_indices.length === 0) {
        showStatus($("#autoSegmentStatus"), "インパルスが検出されませんでした (閾値が高すぎる可能性があります)。", false);
        resetAutoSegmentUI();
        $("#autoSegmentControls").style.display = "block";
        return;
      }
      
      const MIN_GAP_SAMPLES = Math.round(0.1 * FS);
      const start_indices = [over_threshold_indices[0]];
      for (let i = 1; i < over_threshold_indices.length; i++) {
        if (over_threshold_indices[i] - over_threshold_indices[i-1] > MIN_GAP_SAMPLES) {
          start_indices.push(over_threshold_indices[i]);
        }
      }
      
      autoSegments = [];
      
      for (let i = 0; i < start_indices.length; i++) {
        const start_idx = start_indices[i];
        
        const PRE_TRIGGER_SAMPLES = Math.round(0.01 * FS);
        const segment_start_idx = Math.max(0, start_idx - PRE_TRIGGER_SAMPLES);
        
        const peak_search_end = Math.min(fh_signal.length, start_idx + Math.round(0.1 * FS));
        let peak_idx = start_idx;
        let peak_max_val = abs_fh[start_idx];
        
        for (let j = start_idx + 1; j < peak_search_end; j++) {
          if (abs_fh[j] > peak_max_val) {
            peak_max_val = abs_fh[j];
            peak_idx = j;
          }
        }
        
        let segment_end_idx = peak_idx;
        for (let j = peak_idx; j < fh_signal.length - QUIET_SAMPLES; j++) {
          if (abs_fh[j] < DECAY_THRESHOLD) {
            let is_quiet = true;
            for (let k = 1; k < QUIET_SAMPLES; k++) {
              if (abs_fh[j+k] >= DECAY_THRESHOLD) {
                is_quiet = false;
                j += k; 
                break;
              }
            }
            if (is_quiet) {
              segment_end_idx = j + QUIET_SAMPLES;
              break;
            }
          }
        }
        
        if (segment_end_idx === peak_idx) {
          segment_end_idx = Math.min(fh_signal.length - 1, peak_idx + Math.round(0.1 * FS));
        }

        autoSegments.push({
          Impulse_No: i + 1,
          Start_Time: time_data[segment_start_idx],
          End_Time: time_data[segment_end_idx],
          Peak_Time: time_data[peak_idx],
          FH_Max: peak_max_val,
        });
      }
      
      $("#autoSegmentControls").style.display = "block";
      $("#autoSegmentTotal").textContent = autoSegments.length;
      showStatus($("#autoSegmentStatus"), `検出完了: ${autoSegments.length} 件のインパルスが見つかりました。`, true);
      
      if (autoSegments.length > 0) {
        showSegmentDetail(0);
      }
    }
    
    function showSegmentDetail(index) {
      if (index < 0 || index >= autoSegments.length) return;
      
      currentSegmentIdx = index;
      const segment = autoSegments[index];
      
      $("#autoSegmentCurrent").textContent = segment.Impulse_No;
      $("#btnPrevSegment").disabled = (index === 0);
      $("#btnNextSegment").disabled = (index === autoSegments.length - 1);
      
      $("#autoStartTime").value = segment.Start_Time.toFixed(6);
      $("#autoEndTime").value = segment.End_Time.toFixed(6);
      
      // ★★★ v4.3 変更: ズーム範囲をご要望 (-0.01, +0.01) に変更 ★★★
      const PADDING = 0.01; // 10ms
      const zoom_start = Math.max(0, segment.Start_Time - PADDING);
      const zoom_end = Math.min(mapped.time[mapped.time.length - 1], segment.End_Time + PADDING);

      const peak_marker = {
        type: 'line',
        x0: segment.Peak_Time, x1: segment.Peak_Time,
        y0: 0, y1: 1, yref: 'paper',
        line: { color: 'red', width: 2, dash: 'dash' }
      };

      for (const ch of mapped.channels) {
        const plot_dt = plotDivs_Detail[ch.name];
        if (plot_dt) {
          // v4.3: 各チャネルの既存のセレクション形状を取得
          const shapes = (plot_dt.layout.shapes || []).filter(s => s.type === 'rect' || (s.type === 'line' && s.line.color === '#0b6bcb'));
          shapes.push(peak_marker);
          
          Plotly.relayout(plot_dt, {
            'xaxis.range': [zoom_start, zoom_end],
            'shapes': shapes
          });
        }
      }
    }
    
    // ★★★ v4.3 追加: 遅延検出ロジック ★★★
    function findSignalStart(ch, t_search_start, t_search_end) {
        const time = mapped.time;
        const data = ch.data;
        let start_idx = -1, end_idx = -1;

        // 1. 探索ウィンドウのインデックスを見つける
        for(let i=0; i<time.length; i++) {
            if(time[i] >= t_search_start && start_idx === -1) start_idx = i;
            if(time[i] >= t_search_end) { end_idx = i; break; }
        }
        if(end_idx === -1) end_idx = time.length - 1;
        if(start_idx === -1) return null;

        // 2. 探索ウィンドウ内でピークを見つける
        let peak_val = 0, peak_idx = start_idx;
        for(let i=start_idx; i<=end_idx; i++) {
            const val = Math.abs(data[i]);
            if(val > peak_val) {
                peak_val = val;
                peak_idx = i;
            }
        }
        
        if (peak_val === 0) return null; // 信号なし

        // 3. ピークから逆方向に探索し、開始点(ピークの10%)を見つける
        const START_THRESHOLD = peak_val * 0.10; // ピークの10%
        let signal_start_idx = peak_idx;
        for(let i=peak_idx; i>=start_idx; i--) {
            if(Math.abs(data[i]) < START_THRESHOLD) {
                signal_start_idx = i + 1; // 閾値を下回った点の *次* の点
                break;
            }
        }
        
        return time[signal_start_idx];
    }
    
    // ★★★ v4.3 変更: 「適用」ボタンのロジック ★★★
    function applyAutoSegmentsHybrid() {
      if (currentSegmentIdx < 0) {
        alert("適用するセグメントが選択されていません。");
        return;
      }
      
      const t_fh_start = Number($("#autoStartTime").value);
      const t_fh_end = Number($("#autoEndTime").value);
      
      if (isNaN(t_fh_start) || isNaN(t_fh_end) || t_fh_end <= t_fh_start) {
        alert("エラー: FH Start/End の値が無効です。");
        return;
      }
      
      // 手動変更を autoSegments データに永続化
      autoSegments[currentSegmentIdx].Start_Time = t_fh_start;
      autoSegments[currentSegmentIdx].End_Time = t_fh_end;
      const fh_duration = t_fh_end - t_fh_start;
      
      // 1. 全チャネルのグローバルセレクションを更新
      for (const ch of mapped.channels) {
          let t_start_ch = t_fh_start;
          let t_end_ch = t_fh_end;
          
          // ★★★ v4.3: Micチャネルのみ遅延検出を試行 ★★★
          if (ch.role === 'Mic') {
              const t_search_start = t_fh_start;
              const t_search_end = t_fh_start + 0.1; // FH開始から100ms先までを探索
              const detected_mic_start = findSignalStart(ch, t_search_start, t_search_end);
              
              if (detected_mic_start && detected_mic_start < t_search_end) {
                  t_start_ch = detected_mic_start;
                  t_end_ch = t_start_ch + fh_duration; // FHと同じ時間幅を適用
              }
              // FH/AccはFHの値をそのまま使用
          }
        
        selections[ch.name].clicks = [t_start_ch, t_end_ch];
        drawSelectionOnPlot(ch.name); // Annotate付きで描画
      }
      
      // 2. Infoパネルは不要 (Annotateが描画)
      
      // 3. セグメント番号を自動設定
      const segNoInput = $("#segmentNo");
      segNoInput.value = autoSegments[currentSegmentIdx].Impulse_No;
      
      // 4. ステータス表示
      showStatus($("#autoSegmentStatus"), `OK: Impulse #${currentSegmentIdx+1} のCh別セグメントを適用しました。(Micは遅延検出済)`, true);
      
      // 5. 詳細プロットのズームをFHの範囲で更新
      showSegmentDetail(currentSegmentIdx);
    }
    
    // =============================
    // Metrics (v4.3 - v3.3準拠)
    // =============================
    function computeAndRenderMetrics() {
      if (!mapped) throw new Error("データがありません。");
      const fh = getFH();
      const resChs = mapped.channels.filter(c => c.role !== "FH");
      if (!fh) throw new Error("FH チャンネルが必要です。");
      if (resChs.length === 0) throw new Error("FH以外のチャンネルが必要です。");

      const fhSt = selectionStatsFor(fh);
      if (!fhSt) throw new Error("FH の範囲が未選択です (グラフを2回クリックしてください)。");
      
      const fhIdxs = idxBetween(mapped.time, fhSt.start, fhSt.end);
      if (fhIdxs.length === 0) throw new Error("FH 範囲にデータ点がありません。");

      const sumAbsS = absSum(fh.data, fhIdxs);
      const maxAbsS = absMax(fh.data, fhIdxs);

      const tbody = $("#metricsBody");
      tbody.innerHTML = "";

      const trFH = document.createElement("tr");
      trFH.innerHTML = `
        <td class="mono nowrap">${fh.name}</td>
        <td class="mono right">${fmt(sumAbsS)}</td>
        <td class="mono right">${fmt(maxAbsS)}</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>`;
      tbody.appendChild(trFH);

      const segNo = Number($("#segmentNo").value || 1);
      const sourceFile = ($("#csvUrl").value || ($("#csvFile").files[0]?.name ?? ""));
      summaryRows = []; 

      for (const ch of resChs) {
        const chSt = selectionStatsFor(ch); 
        if (!chSt) continue; 

        const idxs = idxBetween(mapped.time, chSt.start, chSt.end);
        if (idxs.length === 0) continue;

        const sumAbsR_raw = absSum(ch.data, idxs);
        const maxAbsR_raw = absMax(ch.data, idxs);
        const vSum = (ch.role === "Mic") ? (sumAbsR_raw / (rho*c)) : sumAbsR_raw;
        const vMax = (ch.role === "Mic") ? (maxAbsR_raw / (rho*c)) : maxAbsR_raw;
        const F_over_v_Sum = (vSum === 0) ? NaN : (sumAbsS / vSum);
        const F_over_v_Max = (vMax === 0) ? NaN : (maxAbsS / vMax);
        const F_over_v_dB_Sum = (!isFinite(F_over_v_Sum) || F_over_v_Sum<=0) ? NaN : (20*Math.log10(F_over_v_Sum));
        const F_over_v_dB_Max = (!isFinite(F_over_v_Max) || F_over_v_Max<=0) ? NaN : (20*Math.log10(F_over_v_Max));

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="mono nowrap">${ch.name}</td>
          <td class="mono right">${fmt(sumAbsR_raw)}</td>
          <td class="mono right">${fmt(maxAbsR_raw)}</td>
          <td class="mono right">${isFinite(F_over_v_Sum) ? fmt(F_over_v_Sum) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_dB_Sum) ? fmt(F_over_v_dB_Sum) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_Max) ? fmt(F_over_v_Max) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_dB_Max) ? fmt(F_over_v_dB_Max) : ""}</td>`;
        tbody.appendChild(tr);

        summaryRows.push({
          SourceFile: sourceFile,
          SegmentFile: `combined_segment_${segNo}.csv`,
          Channel: ch.name,
          "Sum Abs(S)": sumAbsS,
          "Max_abs(S)": maxAbsS,
          "Sum Abs(R)": sumAbsR_raw,
          "Max_abs(R)": maxAbsR_raw,
          "F/v_Sum": F_over_v_Sum,
          "F/v_dB_Sum": F_over_v_dB_Sum,
          "F/v_Max": F_over_v_Max,
          "F/v_dB_Max": F_over_v_dB_Max
        });
      }
    }

    // =============================
    // Exporters (v4.3 - v3.3準拠)
    // =============================
    function exportCombinedSegment() {
      if (!mapped) throw new Error("データがありません。");
      
      let all_selected = true;
      for (const ch of mapped.channels) {
        const st = selectionStatsFor(ch);
        if (!st) {
          all_selected = false;
          break;
        }
      }
      if (!all_selected) throw new Error("すべてのチャネルの範囲が未選択です (2点クリックまたはガイド(1クリック)が必要です)。");

      const slices = {};
      let minLen = Infinity;

      for (const ch of mapped.channels) {
        const st = selectionStatsFor(ch); 
        const idxs = idxBetween(mapped.time, st.start, st.end);
        slices[ch.name] = idxs.map(i => ch.data[i]);
        if (idxs.length < minLen) minLen = idxs.length;
      }

      const st0 = selectionStatsFor(mapped.channels[0]);
      const tIdxs = idxBetween(mapped.time, st0.start, st0.end).slice(0, minLen);
      const tSlice = tIdxs.map(i => mapped.time[i]);
      
      if (minLen === 0) throw new Error("選択範囲にデータ点がありません。");

      const segNo = Number($("#segmentNo").value || 1);
      const cols = ["Time (s)", ...mapped.channels.map(ch => ch.name)];
      let csv = cols.join(",") + "\n";
      for (let i = 0; i < minLen; i++) {
        const vals = mapped.channels.map(ch => (slices[ch.name][i] !== undefined ? slices[ch.name][i] : ""));
        csv += [tSlice[i].toFixed(10), ...vals].join(",") + "\n";
      }
      downloadText(`combined_segment_${segNo}.csv`, csv);
      
      showStatus($("#autoSegmentStatus"), `combined_segment_${segNo}.csv をエクスポートしました。`, true);
    }
    
    function exportSummaryCSV() {
      if (summaryRows.length === 0) { alert("先に「メトリクス計算」を実行してください。"); return; }
      const cols = ["SourceFile","SegmentFile","Channel","Sum Abs(S)","Max_abs(S)","Sum Abs(R)","Max_abs(R)","F/v_Sum","F/v_dB_Sum","F/v_Max","F/v_dB_Max"];
      let csv = cols.join(",") + "\n";
      for (const r of summaryRows) {
        csv += cols.map(k => {
          const v = r[k];
          if (typeof v === "number") return Number.isFinite(v) ? v.toFixed(6) : "";
          return (v ?? "");
        }).join(",") + "\n";
      }
      downloadText("calculation_summary.csv", csv);
    }

    // =============================
    // Event Wiring
    // =============================
    $("#btnLoadUrl").addEventListener("click", async () => {
      try {
        const url = $("#csvUrl").value.trim();
        if (!url) return alert("CSV URL を入力してください。");
        await loadCSVFromURL(url);
        showStatus($("#urlStatus"), "URL読み込み成功", true);
        markInputState($("#csvUrl"), true);
        markRowState($("#urlRow"), true);
      } catch (e) {
        console.error(e);
        showStatus($("#urlStatus"), `URL読み込み失敗: ${e.message}`, false);
        markInputState($("#csvUrl"), false);
        markRowState($("#urlRow"), false);
      }
    });
    $("#btnLoadFile").addEventListener("click", async () => {
      try {
        const f = $("#csvFile").files[0];
        if (!f) return alert("CSVファイルを選択してください。");
        await loadCSVFromFile(f);
        showStatus($("#fileStatus"), "ファイル読み込み成功", true);
        markRowState($("#fileRow"), true);
      } catch (e) {
        console.error(e);
        showStatus($("#fileStatus"), `ファイル読み込み失敗: ${e.message}`, false);
        markRowState($("#fileRow"), false);
      }
    });
    $("#btnApplyMapping").addEventListener("click", () => { try { applyMapping(); } catch (e) { console.error(e); showStatus($("#mapStatus"), `エラー: ${e.message}`, false); } });
    $("#btnResetMapping").addEventListener("click", () => {
      buildMappingUI();
      $("#plots_overview").innerHTML = ""; $("#plots_detail").innerHTML = "";
      $("#metricsBody").innerHTML = "";
      selections = {}; plotDivs_Overview = {}; plotDivs_Detail = {}; summaryRows = [];
      resetAutoSegmentUI();
      showStatus($("#mapStatus"), "マッピングをリセットしました。", true);
    });
    $("#btnPreset1").addEventListener("click", applyPreset1);
    $("#btnClearSelections").addEventListener("click", () => {
      Object.keys(selections).forEach(name => { selections[name].clicks = []; selections[name].guide = null; });
      $$("#plots_overview .plot-card > div:last-child").forEach(plot => { 
          if(plot.layout) {
              plot.layout.shapes = []; plot.layout.annotations = [];
              Plotly.redraw(plot);
          }
      });
      $$("#plots_detail .plot-card > div:last-child").forEach(plot => { 
          if(plot.layout) {
              plot.layout.shapes = (plot.layout.shapes || []).filter(s => s.line && s.line.color === 'red'); 
              plot.layout.annotations = [];
              Plotly.redraw(plot);
          }
      });
      // updateInfoPanel(); // v4.3: 削除
    });
    $("#btnCompute").addEventListener("click", () => { try { computeAndRenderMetrics(); } catch (e) { alert(e.message); } });
    
    // ★★★ v4.3 変更: イベントリスナー ★★★
    $("#btnExportSegmentDetail").addEventListener("click", () => { try { exportCombinedSegment(); } catch (e) { alert(e.message); } }); // v4.3: 新しい保存ボタン
    
    $("#btnExportSummary").addEventListener("click", () => { exportSummaryCSV(); });
    
    $("#btnAutoDetect").addEventListener("click", () => { try { autoDetectSegments(); } catch (e) { alert(e.message); console.error(e); } });
    $("#btnPrevSegment").addEventListener("click", () => { showSegmentDetail(currentSegmentIdx - 1); });
    $("#btnNextSegment").addEventListener("click", () => { showSegmentDetail(currentSegmentIdx + 1); });
    $("#btnApplyAutoHybrid").addEventListener("click", () => { try { applyAutoSegmentsHybrid(); } catch (e) { alert(e.message); } });
    
  </script>
</body>
</html>
