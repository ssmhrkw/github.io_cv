<!DOCTYPE html>
<html lang="ja">
<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HFR5WYG42Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-HFR5WYG42Q'); // ページビュー自動送信
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSV Segmenter (Web) v4.7 (Auto-Zoom)</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root {
      --bg: #faf6ed;
      --card: #ffffff;
      --muted: #5b6b7a;
      --text: #1e293b;
      --accent: #0b6bcb;
      --warn: #c77d00;
      --danger: #c92a2a;
      --ok: #13795b;
      --border: #e2e8f0;
      --soft: #f6f8fb;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 0;
      font-family: "Hiragino Kaku Gothic ProN", "Meiryo", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: var(--bg);
      min-height: 100vh;
    }
    header {
      padding: 18px 20px 10px;
      border-bottom: 1px solid var(--border);
      position: sticky; top: 0; background: rgba(255,255,255,0.85); backdrop-filter: blur(8px);
      z-index: 10;
    }
    header h1 { margin: 0 0 6px; font-size: 18px; font-weight: 700; letter-spacing: 0.2px; color: #0f2e54; }
    header p { margin: 0; font-size: 12px; color: var(--muted); }
    main { padding: 16px; max-width: 1600px; margin: 0 auto; } 
    
    .grid { display: grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 1280px) {
      .grid-3-col {
        grid-template-columns: 1.2fr 1fr 1fr; /* 左:設定 | 中:全体 | 右:詳細 */
      }
    }
    
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px; padding: 14px;
      box-shadow: 0 6px 16px rgba(148,163,184,0.15);
      display: flex;
      flex-direction: column;
    }
    .card h2 { margin: 0 0 10px; font-size: 16px; color: #0f2e54; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    label { font-size: 12px; color: var(--text); }
    input[type="text"], input[type="number"], select {
      background: #fff; color: var(--text); border: 1px solid var(--border);
      border-radius: 10px; padding: 8px 10px; font-size: 13px; outline: none;
      transition: box-shadow .2s ease, border-color .2s ease, background .2s ease;
    }
    input[type="number"] { width: 100px; }
    button {
      appearance: none; border: 1px solid var(--border); color: var(--text);
      background: #fff;
      padding: 8px 12px; font-size: 13px; border-radius: 12px; cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    button:hover { border-color: #b6c3d2; box-shadow: 0 2px 8px rgba(15,46,84,0.06); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #0b6bcb; color: #fff; border-color: #0b6bcb; }
    .btn-green { background: #0b8f6b; color: #fff; border-color: #0b8f6b; }
    .btn-outline { background: transparent; }
    .muted { color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; color: #334155; }
    .help { font-size: 12px; color: var(--muted); }
    .hr { border: none; border-top: 1px dashed var(--border); margin: 10px 0; }
    
    .mapping-table { width: 100%; border-collapse: collapse; }
    .mapping-table th, .mapping-table td { border-bottom: 1px dashed var(--border); padding: 6px 8px; font-size: 12px; }
    .mapping-table th { text-align: left; color: #0f2e54; }
    
    .plots { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
      gap: 12px; 
      width: 100%;
    }
    .plot-card { 
      background: var(--soft); border: 1px solid var(--border); 
      border-radius: 12px; padding: 8px; 
      flex-grow: 1;
    }
    .plot-title { margin: 0 0 6px; font-size: 13px; color: #0f2e54; }
    
    .kpi-row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
    @media (min-width: 1200px) { .kpi-row { grid-template-columns: repeat(4, 1fr); } }
    .kpi { background: #fff; border: 1px solid var(--border); border-radius: 12px; padding: 10px; }
    table.metrics { width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed; }
    table.metrics th, table.metrics td { border-bottom: 1px solid var(--border); padding: 6px 8px; }
    table.metrics th { text-align: left; color: #0f2e54; position: sticky; top: 0; background: #fff; z-index: 1; }
    table.metrics td, table.metrics th { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    
    .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: middle; }
    .status-ok { background: #22c55e; }
    .status-ng { background: #ef4444; }
    
    #autoSegmentControls {
      background: var(--soft); border: 1px solid var(--border);
      border-radius: 12px; padding: 12px;
      display: none; /* 初期状態は非表示 */
      margin-top: 10px;
    }
    #autoSegmentControls .row { justify-content: space-between; }
    #autoSegmentControls input[type="number"] { width: 120px; font-size: 14px; }
    #autoSegmentControls h4 { margin: 0 0 10px; color: #0f2e54; }
    #autoSegmentNav { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
    #autoSegmentNav span { font-size: 16px; font-weight: bold; color: var(--accent); }
    
    .help-box {
        background: #f0f4f8; border: 1px solid #d0d8e0; border-radius: 8px;
        padding: 8px 10px; font-size: 11px; color: #334155; margin: 5px 0 0;
    }
  </style>
</head>
<body>
  <header>
    <h1>CSV Segmenter (Web) — v4.7 (Auto-Zoom)</h1>
    <p class="muted"></p>
  </header>

  <main class="grid grid-3-col">
    <section class="card">
      <h2>1) データ入力</h2>
      <div class="row" id="urlRow">
        <label>CSV URL:</label>
        <input id="csvUrl" type="text" placeholder="/data/sample.csv または https://raw.githubusercontent.com/USER/REPO/BRANCH/path/to.csv" style="flex:1" />
        <button id="btnLoadUrl" class="btn-primary">URLから読み込む</button>
        <span id="urlStatus" class="muted"></span>
      </div>
      <div class="vspacer"></div>
      <div class="row file-wrap" id="fileRow">
        <label>ローカルCSV:</label>
        <input id="csvFile" type="file" accept=".csv" />
        <button id="btnLoadFile">ファイル読み込み</button>
        <span id="fileStatus" class="muted">（UTF-8推奨）</span>
      </div>

      <hr class="hr" />
      <h2>2) チャンネル・マッピング</h2>
      <p class="help">Mic 選択時は距離(m)を指定。Timeが無い場合 <span class="mono">Time (s)=index/Fs</span> を自動生成。</p>
      <div id="mappingArea" class="mono muted">CSV読み込み後に自動生成します。</div>
      <div class="vspacer"></div>
      <div class="row">
        <button id="btnApplyMapping" class="btn-green">マッピング適用 / 反映</button>
        <button id="btnResetMapping" class="btn-outline">リセット</button>
        <button id="btnPreset1" class="btn-outline">プリセット1（Time, FH, Acc, Acc, Mic×5）</button>
        <span id="mapStatus" class="muted"></span>
      </div>

      <hr class="hr" />
      <h2>3) ツール</h2>
      <div class="kpi-row">
        <div class="kpi">
          <div class="muted">サンプリング周波数 (Hz)</div>
          <input id="samplingRate" type="number" value="51200" step="100" />
        </div>
        <div class="kpi">
          <div class="muted">セグメント番号</div>
          <div class="row">
            <input id="segmentNo" type="number" value="1" min="1" step="1" />
            <button id="btnClearSelections" class="btn-outline">全選択クリア</button>
          </div>
        </div>
        <div class="kpi">
          <div class="muted">計算</div>
          <div class="row">
            <button id="btnCompute" class="btn-primary">メトリクス計算</button>
          </div>
        </div>
        <div class="kpi">
          <div class="muted">エクスポート</div>
          <div class="row">
            <button id="btnExportSummary" class="btn-outline">calculation_summary.csv</button>
          </div>
        </div>
      </div>
      <p class="help"><b>推奨ワークフロー:</b> 4) 自動セグメント → 「1. FHインパルス自動検出」 → リストからインパルスを選択（自動ズーム） → 全Chのグラフをクリックして手動セグメント → 「メトリクス計算」。</p>

      <hr class="hr" />
      <h2>4) 自動セグメント (Auto-Zoom)</h2>
      <p class="help">FHチャネルに基づき、インパルス（ピーク）を自動検出し、その周辺にズームします。</p>
      <div class="row" style="gap: 12px;">
        <label><b>FH</b> 検出閾値 (x * Noise SD):</label>
        <input id="autoThresholdFH" type="number" value="5" step="0.5" style="width:80px;" />
        <button id="btnAutoDetect" class="btn-primary" style="flex:1;">1. FHインパルス自動検出</button>
      </div>
      <div class="help-box">
        <b>FH検出閾値:</b> FHチャネルのノイズの何倍を「インパルス開始」と見なすか。
      </div>
      
      <div id="autoSegmentControls">
        <h4>検出されたFHインパルス: <span id="autoSegmentTotal" class="ok">0</span> 件</h4>
        <div id="autoSegmentNav" class="row">
          <button id="btnPrevSegment" class="btn-outline" disabled>&lt; 前 (Prev)</button>
          <span class="mono">FH Impulse #<span id="autoSegmentCurrent">0</span></span>
          <button id="btnNextSegment" class="btn-outline" disabled>次 (Next) &gt;</button>
        </div>
        <div class="help-box">
            インパルスを選択すると、「詳細プレビュー」が自動でズームされます。その後、<b>各グラフをクリックして手動でセグメントを決定</b>してください。
        </div>
        <div id="autoSegmentStatus" class="muted" style="margin-top: 8px;"></div>
      </div>
      <div class="vspacer"></div>
      <h3 class="muted">Metrics（ご提案形式）</h3>
      <div style="overflow:auto; max-height: 260px;">
        <table class="metrics" id="metricsTable">
          <thead>
            <tr>
              <th style="width:120px">Channel</th>
              <th>Sum Abs</th>
              <th>Max_abs</th>
              <th>F/v_Sum</th>
              <th>F/v_dB_Sum</th>
              <th>F/v_Max</th>
              <th>F/v_dB_Max</th>
            </tr>
          </thead>
          <tbody id="metricsBody"></tbody>
        </table>
      </div>
      <p class="footer-note">Micは v = p/(ρc) に変換（ρ≈1.21kg/m³, c=343m/s）。Accはそのままvとして扱います。</p>
    </section>

    <section class="card">
      <h2>プレビュー (全体)</h2>
      <p class="help">グラフをクリックして、チャネルごとにセグメント範囲（2点）を微調整できます。</p>
      <div id="plots_overview" class="plots"></div>
    </section>
    
    <section class="card">
      <h2>プレビュー (詳細セグメント)</h2>
      <p class="help">「自動セグメント」で選択中のFHインパルス周辺を拡大表示します。ここでもクリックして微調整可能です。</p>
      <div id="plots_detail" class="plots"></div>
      
      <hr class="hr" style="margin-top:auto; padding-top: 10px;">
      <div class="row">
          <button id="btnExportSegmentDetail" class="btn-primary" style="flex:1;">
              現在のセグメント (元ファイル名_segment_#.csv) を保存
          </button>
      </div>
    </section>
  </main>

  <script>
    // =============================
    // Constants & Global State
    // =============================
    const rho = 1.21, c = 343;
    let rawRows = [];
    let headers = [];
    let mapping = [];
    let mapped = null;
    let selections = {};
    let plotDivs_Overview = {};
    let plotDivs_Detail = {};
    let autoSegments = [];
    let currentSegmentIdx = -1;
    let summaryRows = []; 
    let currentSourceFileName = "";

    // =============================
    // Helpers
    // =============================
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    
    const getFS = () => Number($("#samplingRate").value) || 51200;

    function showStatus(el, msg, ok=true) {
      el.innerHTML = (ok ? '<span class="status-dot status-ok"></span>' : '<span class="status-dot status-ng"></span>') + msg;
      el.className = ok ? "muted ok" : "muted danger";
    }
    
    function downloadText(filename, text) {
      const blob = new Blob([text], {type: "text/csv;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    }
    function ensureUniqueName(base, existing) {
      if (!existing.has(base)) return base;
      let idx = 2;
      while (existing.has(`${base}_${idx}`)) idx++;
      return `${base}_${idx}`;
    }
    function autoTimeIfMissing(rows) {
      const timeKey = headers.find(h => h.toLowerCase().trim() === "time (s)");
      if (timeKey) return rows.map((r,i)=> Number(r[timeKey]));
      const FS = getFS();
      return rows.map((_,i) => i / FS);
    }
    function toFloatArray(rows, key) {
      const arr = new Float64Array(rows.length);
      for (let i = 0; i < rows.length; i++) {
        const v = rows[i][key];
        arr[i] = (v === null || v === undefined || v === "" || isNaN(Number(v))) ? 0 : Number(v);
      }
      return arr;
    }
    function idxBetween(time, t0, t1) {
      const lo = Math.min(t0, t1), hi = Math.max(t0, t1);
      const idxs = [];
      for (let i = 0; i < time.length; i++) {
        const t = time[i];
        if (t >= lo && t <= hi) idxs.push(i);
      }
      return idxs;
    }
    function absSum(arr, idxs) { let s = 0; for (const i of idxs) s += Math.abs(arr[i]); return s; }
    function absMax(arr, idxs) { let m = 0; for (const i of idxs) { const v = Math.abs(arr[i]); if (v > m) m = v; } return m; }
    function fmt(v, d=2) { return (v===null || v===undefined || !isFinite(v)) ? "" : Number(v).toFixed(d); }

    function getFH() { return mapped ? (mapped.channels.find(c => c.role === "FH") || null) : null; }

    function selectionStatsFor(ch) {
      const sel = selections[ch.name];
      if (!sel) return null;
      
      let t0, t1;
      if (sel.clicks.length === 1 && sel.guide) {
          t0 = sel.guide.x0; t1 = sel.guide.x1;
      } else if (sel.clicks.length >= 2) {
          t0 = sel.clicks[0]; t1 = sel.clicks[1];
      } else {
          return null; // 選択未完了
      }

      const x0 = Math.min(t0, t1), x1 = Math.max(t0, t1);
      const idxs = idxBetween(mapped.time, x0, x1); if (idxs.length===0) return null;
      const maxv = absMax(ch.data, idxs);
      const dur = x1 - x0;
      return { start:x0, end:x1, duration:dur, max:maxv };
    }


    // =============================
    // CSV Loading
    // =============================
    async function loadCSVFromURL(url) {
      const res = await fetch(url, {mode: "cors"});
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      try {
          const urlObj = new URL(url);
          currentSourceFileName = urlObj.pathname.split('/').pop().replace(/\.csv$/i, '');
      } catch (e) {
          currentSourceFileName = "downloaded_file"; 
      }
      const text = await res.text();
      return parseCSVText(text);
    }
    function parseCSVText(text) {
      const out = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
      if (out.errors && out.errors.length) console.warn("Papa parse errors:", out.errors);
      
      rawRows = out.data;
      headers = (out.meta.fields || Object.keys(rawRows[0] || {})).map(h => h.trim());
      if (out.meta.fields) {
          rawRows = rawRows.map(row => {
              const newRow = {};
              for (const key in row) {
                  newRow[key.trim()] = row[key];
              }
              return newRow;
          });
      }

      buildMappingUI();
      $("#plots_overview").innerHTML = "";
      $("#plots_detail").innerHTML = "";
      $("#metricsBody").innerHTML = "";
      selections = {};
      plotDivs_Overview = {};
      plotDivs_Detail = {};
      summaryRows = [];
      resetAutoSegmentUI();
      return true;
    }
    function loadCSVFromFile(file) {
      currentSourceFileName = file.name.replace(/\.csv$/i, '');
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => { try { parseCSVText(reader.result); resolve(true); } catch (e) { reject(e); } };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file, "utf-8");
      });
    }

    // =============================
    // Mapping UI
    // =============================
    function buildMappingUI() {
      mapping = headers.map(h => ({ src: h, role: "Ignore", distance: "" }));
      const container = document.getElementById("mappingArea");
      const rowsHtml = headers.map((h, i) => {
        return `
          <tr>
            <td class="mono nowrap">${i+1}</td>
            <td class="mono">${h}</td>
            <td>
              <select data-idx="${i}" class="role">
                <option value="Ignore">Ignore</option>
                <option value="FH">FH</option>
                <option value="Acc">Acc</option>
                <option value="Mic">Mic</option>
                <option value="Time">Time (s)</option>
              </select>
            </td>
            <td>
              <input type="number" step="0.1" min="0" placeholder="Mic距離(m)" class="dist" data-idx="${i}" />
            </td>
          </tr>
        `;
      }).join("");
      container.innerHTML = `
        <table class="mapping-table">
          <thead><tr><th>#</th><th>CSV列名</th><th>役割</th><th>Mic距離(m)</th></tr></thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      `;
    }

    function applyMapping() {
      $$("#mappingArea select.role").forEach(sel => { const i = Number(sel.dataset.idx); mapping[i].role = sel.value; });
      $$("#mappingArea input.dist").forEach(inp => { const i = Number(inp.dataset.idx); mapping[i].distance = inp.value ? Number(inp.value) : ""; });

      const usedNames = new Set();
      const timeAuto = autoTimeIfMissing(rawRows);
      const channels = [];
      mapping.forEach((m, i) => {
        if (m.role === "Ignore" || m.role === "Time") return;
        let base = m.role;
        if (m.role === "Mic") {
          const d = (typeof m.distance === "number" && !isNaN(m.distance)) ? m.distance : null;
          base = d !== null ? `Mic(${d.toFixed(1)}m)` : "Mic";
        }
        const name = ensureUniqueName(base, usedNames);
        usedNames.add(name);
        channels.push({ name, role: m.role, src: mapping[i].src, data: toFloatArray(rawRows, mapping[i].src), distance: m.distance });
      });
      const timeIdx = mapping.findIndex(m => m.role === "Time");
      const timeFinal = (timeIdx >= 0) ? toFloatArray(rawRows, mapping[timeIdx].src) : Float64Array.from(timeAuto);
      if (channels.length === 0) throw new Error("データチャンネルがありません。");
      mapped = { time: timeFinal, channels };
      showStatus($("#mapStatus"), `OK: ${channels.length}ch 反映 (FH:${channels.filter(c=>c.role==='FH').length}, Acc:${channels.filter(c=>c.role==='Acc').length}, Mic:${channels.filter(c=>c.role==='Mic').length})`, true);
      renderPlots();
      resetAutoSegmentUI();
    }

    // プリセット1：Time, FH, Acc, Acc, Mic×5
    function applyPreset1() {
      const seq = ["Time","FH","Acc","Acc","Mic","Mic","Mic","Mic","Mic"];
      const selects = $$("#mappingArea select.role");
      for (let i = 0; i < selects.length; i++) {
        const role = (i < seq.length) ? seq[i] : "Ignore";
        selects[i].value = role;
        mapping[i].role = role;
      }
      showStatus($("#mapStatus"), "プリセット1を適用しました。必要に応じて距離(m)を入力してください。", true);
      try { applyMapping(); } catch (e) { console.error(e); showStatus($("#mapStatus"), `エラー: ${e.message}`, false); }
    }

    // =============================
    // Plotting & Selection (v4.7)
    // =============================
    function renderPlots() {
      const wrap_overview = $("#plots_overview"); wrap_overview.innerHTML = "";
      const wrap_detail = $("#plots_detail"); wrap_detail.innerHTML = "";
      
      plotDivs_Overview = {};
      plotDivs_Detail = {};
      selections = {};
      
      for (const ch of mapped.channels) {
        // --- 1. 全体(Overview)プロット ---
        const div_ov = document.createElement("div");
        div_ov.className = "plot-card";
        const title_ov = document.createElement("div");
        title_ov.className = "plot-title";
        title_ov.textContent = `Channel: ${ch.name} (${ch.role})`;
        const plot_ov = document.createElement("div");
        plot_ov.style.height = "200px";
        plot_ov.dataset.chan = ch.name;
        div_ov.appendChild(title_ov); div_ov.appendChild(plot_ov); wrap_overview.appendChild(div_ov);
        plotDivs_Overview[ch.name] = plot_ov;

        const trace = { x: Array.from(mapped.time), y: Array.from(ch.data), mode: "lines", line: { width: 1 }, hoverinfo: "x+y", name: ch.name };
        const layout_ov = {
          margin: { l: 40, r: 10, t: 30, b: 22 }, 
          xaxis: { title: "Time (s)", color: "#1f2937" },
          yaxis: { title: "Amp.", color: "#1f2937" },
          shapes: [], annotations: [], 
          showlegend: false, paper_bgcolor: "#ffffff", plot_bgcolor: "#ffffff", font: { color: "#1f2937" },
        };
        Plotly.newPlot(plot_ov, [trace], layout_ov, { responsive: true });

        // --- 2. 詳細(Detail)プロット ---
        const div_dt = document.createElement("div");
        div_dt
