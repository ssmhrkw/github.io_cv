<!DOCTYPE html>
<html lang="ja">
<head>
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HFR5WYG42Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-HFR5WYG42Q'); // ページビュー自動送信
  </script>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSV Segmenter (Web) v4.8 (Theoretical Delay)</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
  <style>
    :root {
      --bg: #faf6ed;
      --card: #ffffff;
      --muted: #5b6b7a;
      --text: #1e293b;
      --accent: #0b6bcb;
      --warn: #c77d00;
      --danger: #c92a2a;
      --ok: #13795b;
      --border: #e2e8f0;
      --soft: #f6f8fb;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 0;
      font-family: "Hiragino Kaku Gothic ProN", "Meiryo", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--text);
      background: var(--bg);
      min-height: 100vh;
    }
    header {
      padding: 18px 20px 10px;
      border-bottom: 1px solid var(--border);
      position: sticky; top: 0; background: rgba(255,255,255,0.85); backdrop-filter: blur(8px);
      z-index: 10;
    }
    header h1 { margin: 0 0 6px; font-size: 18px; font-weight: 700; letter-spacing: 0.2px; color: #0f2e54; }
    header p { margin: 0; font-size: 12px; color: var(--muted); }
    main { padding: 16px; max-width: 1600px; margin: 0 auto; } 
    
    .grid { display: grid; grid-template-columns: 1fr; gap: 14px; }
    @media (min-width: 1280px) {
      .grid-3-col {
        grid-template-columns: 1.2fr 1fr 1fr; /* 左:設定 | 中:全体 | 右:詳細 */
      }
    }
    
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px; padding: 14px;
      box-shadow: 0 6px 16px rgba(148,163,184,0.15);
      display: flex;
      flex-direction: column;
    }
    .card h2 { margin: 0 0 10px; font-size: 16px; color: #0f2e54; }
    .row { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
    label { font-size: 12px; color: var(--text); }
    input[type="text"], input[type="number"], select {
      background: #fff; color: var(--text); border: 1px solid var(--border);
      border-radius: 10px; padding: 8px 10px; font-size: 13px; outline: none;
      transition: box-shadow .2s ease, border-color .2s ease, background .2s ease;
    }
    input[type="number"] { width: 100px; }
    button {
      appearance: none; border: 1px solid var(--border); color: var(--text);
      background: #fff;
      padding: 8px 12px; font-size: 13px; border-radius: 12px; cursor: pointer;
      transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    button:hover { border-color: #b6c3d2; box-shadow: 0 2px 8px rgba(15,46,84,0.06); }
    button:active { transform: translateY(1px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn-primary { background: #0b6bcb; color: #fff; border-color: #0b6bcb; }
    .btn-green { background: #0b8f6b; color: #fff; border-color: #0b8f6b; }
    .btn-outline { background: transparent; }
    .muted { color: var(--muted); font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size: 12px; color: #334155; }
    .help { font-size: 12px; color: var(--muted); }
    .hr { border: none; border-top: 1px dashed var(--border); margin: 10px 0; }
    
    .mapping-table { width: 100%; border-collapse: collapse; }
    .mapping-table th, .mapping-table td { border-bottom: 1px dashed var(--border); padding: 6px 8px; font-size: 12px; }
    .mapping-table th { text-align: left; color: #0f2e54; }
    
    .plots { 
      display: grid; 
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
      gap: 12px; 
      width: 100%;
    }
    .plot-card { 
      background: var(--soft); border: 1px solid var(--border); 
      border-radius: 12px; padding: 8px; 
      flex-grow: 1;
    }
    .plot-title { margin: 0 0 6px; font-size: 13px; color: #0f2e54; }
    
    .kpi-row { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
    @media (min-width: 1200px) { .kpi-row { grid-template-columns: repeat(4, 1fr); } }
    .kpi { background: #fff; border: 1px solid var(--border); border-radius: 12px; padding: 10px; }
    table.metrics { width: 100%; border-collapse: collapse; font-size: 12px; table-layout: fixed; }
    table.metrics th, table.metrics td { border-bottom: 1px solid var(--border); padding: 6px 8px; }
    table.metrics th { text-align: left; color: #0f2e54; position: sticky; top: 0; background: #fff; z-index: 1; }
    table.metrics td, table.metrics th { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    
    .status-dot { width: 8px; height: 8px; border-radius: 50%; display: inline-block; margin-right: 6px; vertical-align: middle; }
    .status-ok { background: #22c55e; }
    .status-ng { background: #ef4444; }
    
    #autoSegmentControls {
      background: var(--soft); border: 1px solid var(--border);
      border-radius: 12px; padding: 12px;
      display: none; /* 初期状態は非表示 */
      margin-top: 10px;
    }
    #autoSegmentControls .row { justify-content: space-between; }
    #autoSegmentControls input[type="number"] { width: 120px; font-size: 14px; }
    #autoSegmentControls h4 { margin: 0 0 10px; color: #0f2e54; }
    #autoSegmentNav { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
    #autoSegmentNav span { font-size: 16px; font-weight: bold; color: var(--accent); }
    
    .help-box {
        background: #f0f4f8; border: 1px solid #d0d8e0; border-radius: 8px;
        padding: 8px 10px; font-size: 11px; color: #334155; margin: 5px 0 0;
    }
  </style>
</head>
<body>
  <header>
    <h1>CSV Segmenter (Web) — v4.8 (Theoretical Delay)</h1>
    <p class="muted"></p>
  </header>

  <main class="grid grid-3-col">
    <section class="card">
      <h2>1) データ入力</h2>
      <div class="row" id="urlRow">
        <label>CSV URL:</label>
        <input id="csvUrl" type="text" placeholder="/data/sample.csv または https://raw.githubusercontent.com/USER/REPO/BRANCH/path/to.csv" style="flex:1" />
        <button id="btnLoadUrl" class="btn-primary">URLから読み込む</button>
        <span id="urlStatus" class="muted"></span>
      </div>
      <div class="vspacer"></div>
      <div class="row file-wrap" id="fileRow">
        <label>ローカルCSV:</label>
        <input id="csvFile" type="file" accept=".csv" />
        <button id="btnLoadFile">ファイル読み込み</button>
        <span id="fileStatus" class="muted">（UTF-8推奨）</span>
      </div>

      <hr class="hr" />
      <h2>2) チャンネル・マッピング</h2>
      <p class="help">Mic 選択時は距離(m)を指定。Timeが無い場合 <span class="mono">Time (s)=index/Fs</span> を自動生成。</p>
      <div id="mappingArea" class="mono muted">CSV読み込み後に自動生成します。</div>
      <div class="vspacer"></div>
      <div class="row">
        <button id="btnApplyMapping" class="btn-green">マッピング適用 / 反映</button>
        <button id="btnResetMapping" class="btn-outline">リセット</button>
        <button id="btnPreset1" class="btn-outline">プリセット1 (w/ Mic Delay)</button>
        <span id="mapStatus" class="muted"></span>
      </div>

      <hr class="hr" />
      <h2>3) ツール</h2>
      <div class="kpi-row">
        <div class="kpi">
          <div class="muted">サンプリング周波数 (Hz)</div>
          <input id="samplingRate" type="number" value="51200" step="100" />
        </div>
        <div class="kpi">
          <div class="muted">セグメント番号</div>
          <div class="row">
            <input id="segmentNo" type="number" value="1" min="1" step="1" />
            <button id="btnClearSelections" class="btn-outline">全選択クリア</button>
          </div>
        </div>
        <div class="kpi">
          <div class="muted">計算</div>
          <div class="row">
            <button id="btnCompute" class="btn-primary">メトリクス計算</button>
          </div>
        </div>
        <div class="kpi">
          <div class="muted">エクスポート</div>
          <div class="row">
            <button id="btnExportSummary" class="btn-outline">calculation_summary.csv</button>
          </div>
        </div>
      </div>
      <p class="help"><b>推奨ワークフロー:</b> 4) 自動セグメント → 「1. FHインパルス自動検出」 → リストからインパルスを選択（自動ズーム） → <b>FH/Accを手動クリック</b> → <b>「2. 理論遅延を Acc/Mic に適用」</b> → 「メトリクス計算」。</p>

      <hr class="hr" />
      <h2>4) 自動セグメント (Auto-Zoom)</h2>
      <p class="help">FHチャネルに基づき、インパルス（ピーク）を自動検出し、その周辺にズームします。</p>
      <div class="row" style="gap: 12px;">
        <label><b>FH</b> 検出閾値 (x * Noise SD):</label>
        <input id="autoThresholdFH" type="number" value="5" step="0.5" style="width:80px;" />
        <button id="btnAutoDetect" class="btn-primary" style="flex:1;">1. FHインパルス自動検出</button>
      </div>
      <div class="help-box">
        <b>FH検出閾値:</b> FHチャネルのノイズの何倍を「インパルス開始」と見なすか。
      </div>
      
      <div id="autoSegmentControls">
        <h4>検出されたFHインパルス: <span id="autoSegmentTotal" class="ok">0</span> 件</h4>
        <div id="autoSegmentNav" class="row">
          <button id="btnPrevSegment" class="btn-outline" disabled>&lt; 前 (Prev)</button>
          <span class="mono">FH Impulse #<span id="autoSegmentCurrent">0</span></span>
          <button id="btnNextSegment" class="btn-outline" disabled>次 (Next) &gt;</button>
        </div>
        <div class="row" style="margin-top: 10px;">
           <button id="btnApplyTheoreticalDelay" class="btn-green" style="flex:1;">2. 理論遅延を Acc/Mic に適用</button>
        </div>
        <div class="help-box">
            <b>ボタンの動作:</b> FHの手動セグメントに基づき、Acc(遅延0)とMic(マッピング距離/340m/s)のセグメントを自動設定します。
        </div>
        <div id="autoSegmentStatus" class="muted" style="margin-top: 8px;"></div>
      </div>

      <div class="vspacer"></div>
      <h3 class="muted">Metrics（ご提案形式）</h3>
      <div style="overflow:auto; max-height: 260px;">
        <table class="metrics" id="metricsTable">
          <thead>
            <tr>
              <th style="width:120px">Channel</th>
              <th>Sum Abs</th>
              <th>Max_abs</th>
              <th>F/v_Sum</th>
              <th>F/v_dB_Sum</th>
              <th>F/v_Max</th>
              <th>F/v_dB_Max</th>
            </tr>
          </thead>
          <tbody id="metricsBody"></tbody>
        </table>
      </div>
      <p class="footer-note">Micは v = p/(ρc) に変換（ρ≈1.21kg/m³, c=343m/s）。Accはそのままvとして扱います。</p>
    </section>

    <section class="card">
      <h2>プレビュー (全体)</h2>
      <p class="help">グラフをクリックして、チャネルごとにセグメント範囲（2点）を微調整できます。</p>
      <div id="plots_overview" class="plots"></div>
    </section>
    
    <section class="card">
      <h2>プレビュー (詳細セグメント)</h2>
      <p class="help">「自動セグメント」で選択中のFHインパルス周辺を拡大表示します。ここでもクリックして微調整可能です。</p>
      <div id="plots_detail" class="plots"></div>
      
      <hr class="hr" style="margin-top:auto; padding-top: 10px;">
      <div class="row">
          <button id="btnExportSegmentDetail" class="btn-primary" style="flex:1;">
              現在のセグメント (元ファイル名_segment_#.csv) を保存
          </button>
      </div>
    </section>
  </main>

  <script>
    // =============================
    // Constants & Global State
    // =============================
    const rho = 1.21, c = 343;
    const soundVelocity = 340; // ★★★ v4.8 追加: 音速(m/s) ★★★
    let rawRows = [];
    let headers = [];
    let mapping = [];
    let mapped = null;
    let selections = {};
    let plotDivs_Overview = {};
    let plotDivs_Detail = {};
    let autoSegments = [];
    let currentSegmentIdx = -1;
    let summaryRows = []; 
    let currentSourceFileName = "";

    // =============================
    // Helpers
    // =============================
    const $ = (sel) => document.querySelector(sel);
    const $$ = (sel) => Array.from(document.querySelectorAll(sel));
    
    const getFS = () => Number($("#samplingRate").value) || 51200;

    function showStatus(el, msg, ok=true) {
      el.innerHTML = (ok ? '<span class="status-dot status-ok"></span>' : '<span class="status-dot status-ng"></span>') + msg;
      el.className = ok ? "muted ok" : "muted danger";
    }
    
    function downloadText(filename, text) {
      const blob = new Blob([text], {type: "text/csv;charset=utf-8"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
    }
    function ensureUniqueName(base, existing) {
      if (!existing.has(base)) return base;
      let idx = 2;
      while (existing.has(`${base}_${idx}`)) idx++;
      return `${base}_${idx}`;
    }
    function autoTimeIfMissing(rows) {
      const timeKey = headers.find(h => h.toLowerCase().trim() === "time (s)");
      if (timeKey) return rows.map((r,i)=> Number(r[timeKey]));
      const FS = getFS();
      return rows.map((_,i) => i / FS);
    }
    function toFloatArray(rows, key) {
      const arr = new Float64Array(rows.length);
      for (let i = 0; i < rows.length; i++) {
        const v = rows[i][key];
        arr[i] = (v === null || v === undefined || v === "" || isNaN(Number(v))) ? 0 : Number(v);
      }
      return arr;
    }
    function idxBetween(time, t0, t1) {
      const lo = Math.min(t0, t1), hi = Math.max(t0, t1);
      const idxs = [];
      for (let i = 0; i < time.length; i++) {
        const t = time[i];
        if (t >= lo && t <= hi) idxs.push(i);
      }
      return idxs;
    }
    function absSum(arr, idxs) { let s = 0; for (const i of idxs) s += Math.abs(arr[i]); return s; }
    function absMax(arr, idxs) { let m = 0; for (const i of idxs) { const v = Math.abs(arr[i]); if (v > m) m = v; } return m; }
    function fmt(v, d=2) { return (v===null || v===undefined || !isFinite(v)) ? "" : Number(v).toFixed(d); }

    function getFH() { return mapped ? (mapped.channels.find(c => c.role === "FH") || null) : null; }

    function selectionStatsFor(ch) {
      const sel = selections[ch.name];
      if (!sel) return null;
      
      let t0, t1;
      if (sel.clicks.length === 1 && sel.guide) {
          t0 = sel.guide.x0; t1 = sel.guide.x1;
      } else if (sel.clicks.length >= 2) {
          t0 = sel.clicks[0]; t1 = sel.clicks[1];
      } else {
          return null; // 選択未完了
      }

      const x0 = Math.min(t0, t1), x1 = Math.max(t0, t1);
      const idxs = idxBetween(mapped.time, x0, x1); if (idxs.length===0) return null;
      const maxv = absMax(ch.data, idxs);
      const dur = x1 - x0;
      return { start:x0, end:x1, duration:dur, max:maxv };
    }


    // =============================
    // CSV Loading
    // =============================
    async function loadCSVFromURL(url) {
      const res = await fetch(url, {mode: "cors"});
      if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
      try {
          const urlObj = new URL(url);
          currentSourceFileName = urlObj.pathname.split('/').pop().replace(/\.csv$/i, '');
      } catch (e) {
          currentSourceFileName = "downloaded_file"; 
      }
      const text = await res.text();
      return parseCSVText(text);
    }
    function parseCSVText(text) {
      const out = Papa.parse(text, { header: true, dynamicTyping: true, skipEmptyLines: true });
      if (out.errors && out.errors.length) console.warn("Papa parse errors:", out.errors);
      
      rawRows = out.data;
      headers = (out.meta.fields || Object.keys(rawRows[0] || {})).map(h => h.trim());
      if (out.meta.fields) {
          rawRows = rawRows.map(row => {
              const newRow = {};
              for (const key in row) {
                  newRow[key.trim()] = row[key];
              }
              return newRow;
          });
      }

      buildMappingUI();
      $("#plots_overview").innerHTML = "";
      $("#plots_detail").innerHTML = "";
      $("#metricsBody").innerHTML = "";
      selections = {};
      plotDivs_Overview = {};
      plotDivs_Detail = {};
      summaryRows = [];
      resetAutoSegmentUI();
      return true;
    }
    function loadCSVFromFile(file) {
      currentSourceFileName = file.name.replace(/\.csv$/i, '');
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => { try { parseCSVText(reader.result); resolve(true); } catch (e) { reject(e); } };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file, "utf-8");
      });
    }

    // =============================
    // Mapping UI
    // =============================
    function buildMappingUI() {
      mapping = headers.map(h => ({ src: h, role: "Ignore", distance: "" }));
      const container = document.getElementById("mappingArea");
      const rowsHtml = headers.map((h, i) => {
        return `
          <tr>
            <td class="mono nowrap">${i+1}</td>
            <td class="mono">${h}</td>
            <td>
              <select data-idx="${i}" class="role">
                <option value="Ignore">Ignore</option>
                <option value="FH">FH</option>
                <option value="Acc">Acc</option>
                <option value="Mic">Mic</option>
                <option value="Time">Time (s)</option>
              </select>
            </td>
            <td>
              <input type="number" step="0.1" min="0" placeholder="Mic距離(m)" class="dist" data-idx="${i}" />
            </td>
          </tr>
        `;
      }).join("");
      container.innerHTML = `
        <table class="mapping-table">
          <thead><tr><th>#</th><th>CSV列名</th><th>役割</th><th>Mic距離(m)</th></tr></thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      `;
    }

    function applyMapping() {
      $$("#mappingArea select.role").forEach(sel => { const i = Number(sel.dataset.idx); mapping[i].role = sel.value; });
      $$("#mappingArea input.dist").forEach(inp => { const i = Number(inp.dataset.idx); mapping[i].distance = inp.value ? Number(inp.value) : ""; });

      const usedNames = new Set();
      const timeAuto = autoTimeIfMissing(rawRows);
      const channels = [];
      mapping.forEach((m, i) => {
        if (m.role === "Ignore" || m.role === "Time") return;
        let base = m.role;
        if (m.role === "Mic") {
          const d = (typeof m.distance === "number" && !isNaN(m.distance)) ? m.distance : null;
          base = d !== null ? `Mic(${d.toFixed(1)}m)` : "Mic";
        }
        const name = ensureUniqueName(base, usedNames);
        usedNames.add(name);
        channels.push({ name, role: m.role, src: mapping[i].src, data: toFloatArray(rawRows, mapping[i].src), distance: m.distance });
      });
      const timeIdx = mapping.findIndex(m => m.role === "Time");
      const timeFinal = (timeIdx >= 0) ? toFloatArray(rawRows, mapping[timeIdx].src) : Float64Array.from(timeAuto);
      if (channels.length === 0) throw new Error("データチャンネルがありません。");
      mapped = { time: timeFinal, channels };
      showStatus($("#mapStatus"), `OK: ${channels.length}ch 反映 (FH:${channels.filter(c=>c.role==='FH').length}, Acc:${channels.filter(c=>c.role==='Acc').length}, Mic:${channels.filter(c=>c.role==='Mic').length})`, true);
      renderPlots();
      resetAutoSegmentUI();
    }

    // ★★★ v4.8 変更: プリセット1のロジック ★★★
    function applyPreset1() {
      const seq = ["Time","FH","Acc","Acc","Mic","Mic","Mic","Mic","Mic"];
      const mic_distances = [0.1, 0.4, 0.7, 1.0, 1.3];
      
      const selects = $$("#mappingArea select.role");
      const dists = $$("#mappingArea input.dist");
      
      let mic_count = 0;
      
      for (let i = 0; i < selects.length; i++) {
        const role = (i < seq.length) ? seq[i] : "Ignore";
        selects[i].value = role;
        mapping[i].role = role;
        
        // 距離を自動入力
        if (role === "Mic") {
          if (mic_count < mic_distances.length) {
            const dist_val = mic_distances[mic_count];
            dists[i].value = dist_val;
            mapping[i].distance = dist_val;
            mic_count++;
          } else {
            dists[i].value = "";
            mapping[i].distance = "";
          }
        } else {
          dists[i].value = "";
          mapping[i].distance = "";
        }
      }
      
      showStatus($("#mapStatus"), "プリセット1 (w/ Mic距離) を適用しました。", true);
      try { applyMapping(); } catch (e) { console.error(e); showStatus($("#mapStatus"), `エラー: ${e.message}`, false); }
    }

    // =============================
    // Plotting & Selection (v4.8)
    // =============================
    function renderPlots() {
      const wrap_overview = $("#plots_overview"); wrap_overview.innerHTML = "";
      const wrap_detail = $("#plots_detail"); wrap_detail.innerHTML = "";
      
      plotDivs_Overview = {};
      plotDivs_Detail = {};
      selections = {};
      
      for (const ch of mapped.channels) {
        // --- 1. 全体(Overview)プロット ---
        const div_ov = document.createElement("div");
        div_ov.className = "plot-card";
        const title_ov = document.createElement("div");
        title_ov.className = "plot-title";
        title_ov.textContent = `Channel: ${ch.name} (${ch.role})`;
        const plot_ov = document.createElement("div");
        plot_ov.style.height = "200px";
        plot_ov.dataset.chan = ch.name;
        div_ov.appendChild(title_ov); div_ov.appendChild(plot_ov); wrap_overview.appendChild(div_ov);
        plotDivs_Overview[ch.name] = plot_ov;

        const trace = { x: Array.from(mapped.time), y: Array.from(ch.data), mode: "lines", line: { width: 1 }, hoverinfo: "x+y", name: ch.name };
        const layout_ov = {
          margin: { l: 40, r: 10, t: 30, b: 22 }, 
          xaxis: { title: "Time (s)", color: "#1f2937" },
          yaxis: { title: "Amp.", color: "#1f2937" },
          shapes: [], annotations: [], 
          showlegend: false, paper_bgcolor: "#ffffff", plot_bgcolor: "#ffffff", font: { color: "#1f2937" },
        };
        Plotly.newPlot(plot_ov, [trace], layout_ov, { responsive: true });

        // --- 2. 詳細(Detail)プロット ---
        const div_dt = document.createElement("div");
        div_dt.className = "plot-card";
        const title_dt = document.createElement("div");
        title_dt.className = "plot-title";
        title_dt.textContent = `Channel: ${ch.name} (${ch.role})`;
        const plot_dt = document.createElement("div");
        plot_dt.style.height = "200px";
        plot_dt.dataset.chan = ch.name;
        div_dt.appendChild(title_dt); div_dt.appendChild(plot_dt); wrap_detail.appendChild(div_dt);
        plotDivs_Detail[ch.name] = plot_dt;
        
        const layout_dt = JSON.parse(JSON.stringify(layout_ov));
        layout_dt.xaxis.range = [mapped.time[0], mapped.time[0] + 0.1];
        Plotly.newPlot(plot_dt, [trace], layout_dt, { responsive: true });
        
        selections[ch.name] = { clicks: [], guide: null };

        plot_ov.on("plotly_click", (ev) => {
          if (!ev || !ev.points || !ev.points.length) return;
          handleClickOnChannel(ch.name, ev.points[0].x);
        });
        plot_dt.on("plotly_click", (ev) => {
          if (!ev || !ev.points || !ev.points.length) return;
          handleClickOnChannel(ch.name, ev.points[0].x);
        });
      }
    }
    
    function drawSelectionOnPlot(name) {
      const plot_ov = plotDivs_Overview[name];
      const plot_dt = plotDivs_Detail[name];
      if (!plot_ov || !plot_dt) return;
      
      const sel = selections[name];
      const shapes = [];
      const annotations = [];
      const FH = getFH();
      
      let dt_guide = null;
      if (FH && name !== FH.name) {
          const fhSelObj = selectionStatsFor(FH);
          if (fhSelObj) dt_guide = fhSelObj.duration;
      }
      
      if (sel.clicks.length === 1 && dt_guide && isFinite(dt_guide)) {
        const x0 = sel.clicks[0]; const x1 = x0 + dt_guide;
        shapes.push(
          { type: "rect", x0, x1, y0: 0, y1: 1, xref: "x", yref: "paper",
            fillcolor: "rgba(255,170,0,0.18)", line: { color: "rgba(199,125,0,0.8)", width: 1, dash: "dot" } },
          { type: "line", x0, x1: x0, y0: 0, y1: 1, xref: "x", yref: "paper",
            line: { color: "#c77d00", width: 2, dash: "dot" } }
        );
        sel.guide = { x0, x1, dt: dt_guide };
      } else { 
        sel.guide = null; 
        if (sel.clicks.length === 1) {
          const x0 = sel.clicks[0];
          shapes.push({ type: "line", x0, x1: x0, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } });
        } else if (sel.clicks.length >= 2) {
          const [a,b] = sel.clicks.slice(0,2); const x0 = Math.min(a,b), x1 = Math.max(a,b);
          shapes.push(
            { type: "line", x0: a, x1: a, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } },
            { type: "line", x0: b, x1: b, y0: 0, y1: 1, xref: "x", yref: "paper", line: { color: "#0b6bcb", width: 2, dash: "dot" } },
            { type: "rect", x0, x1, y0: 0, y1: 1, xref: "x", yref: "paper", fillcolor: "rgba(11,107,203,0.12)", line: { width: 0 } }
          );
        }
      }
      
      const st = selectionStatsFor(mapped.channels.find(c => c.name === name));
      if (st) {
          const annot_text = `<b>${fmt(st.start, 4)}s - ${fmt(st.end, 4)}s</b> (Dur: ${fmt(st.duration, 4)}s | Max: ${fmt(st.max, 2)})`;
          annotations.push({
              text: annot_text,
              align: 'left', x: 0.01, y: 1.15, 
              xref: 'paper', yref: 'paper',
              showarrow: false, font: {size: 10, color: '#0f2e54'},
              bgcolor: 'rgba(255,255,255,0.0)'
          });
      }

      if (currentSegmentIdx >= 0) {
          const segment = autoSegments[currentSegmentIdx];
          shapes.push({
            type: 'line',
            x0: segment.Peak_Time, x1: segment.Peak_Time,
            y0: 0, y1: 1, yref: 'paper',
            line: { color: 'red', width: 2, dash: 'dash' }
          });
      }
      
      Plotly.relayout(plot_ov, { shapes: shapes, annotations: annotations });
      Plotly.relayout(plot_dt, { shapes: shapes, annotations: annotations });
    }

    function handleClickOnChannel(name, x) {
      const sel = selections[name]; if (!sel) return;
      
      if (sel.clicks.length >= 2) sel.clicks = []; 
      sel.clicks.push(x);
      
      drawSelectionOnPlot(name); 
      
      const FH = getFH();
      if (FH && name === FH.name) { 
        for (const ch of mapped.channels) {
          if (ch.name !== FH.name && selections[ch.name].clicks.length === 1) {
            drawSelectionOnPlot(ch.name);
          }
        }
      }
    }

    // =============================
    // Auto Segment (v4.8)
    // =============================
    
    function resetAutoSegmentUI() {
      $("#autoSegmentControls").style.display = "none";
      $("#autoSegmentTotal").textContent = "0";
      $("#autoSegmentCurrent").textContent = "0";
      $("#btnPrevSegment").disabled = true;
      $("#btnNextSegment").disabled = true;
      $("#autoSegmentStatus").textContent = "";
      autoSegments = [];
      currentSegmentIdx = -1;
    }
    
    // v4.7のFHインパルス検出ロジック (変更なし)
    function findImpulseSegment(ch, t_search_start, t_search_end, detection_threshold_factor) {
        const time = mapped.time;
        const data = ch.data;
        const FS = getFS();
        let start_idx = -1, end_idx = -1;
        
        for(let i=0; i<time.length; i++) {
            if(time[i] >= t_search_start && start_idx === -1) start_idx = i;
            if(time[i] >= t_search_end) { end_idx = i; break; }
        }
        if(end_idx === -1) end_idx = time.length - 1;
        if(start_idx === -1) start_idx = 0; 

        let sum = 0, sum_abs_dev = 0;
        const n_samples = end_idx - start_idx;
        if (n_samples <= 0) return null;
        
        for(let i=start_idx; i<=end_idx; i++) sum += data[i];
        const mean = sum / n_samples;
        for(let i=start_idx; i<=end_idx; i++) sum_abs_dev += Math.abs(data[i] - mean);
        const NOISE_FLOOR_ESTIMATE = (sum_abs_dev / n_samples) * 1.25;
        
        const PEAK_THRESHOLD = NOISE_FLOOR_ESTIMATE * detection_threshold_factor;

        let peak_val = 0, peak_idx = -1;
        for(let i=start_idx; i<=end_idx; i++) {
            const val = Math.abs(data[i]);
            if(val > peak_val && val > PEAK_THRESHOLD) {
                peak_val = val;
                peak_idx = i;
            }
        }
        
        if (peak_idx === -1) return null; 

        const START_THRESHOLD_VAL = peak_val * 0.05; 
        let segment_start_idx = peak_idx;
        const lookback_samples = Math.round(0.01 * FS); 
        const search_start_limit = Math.max(0, peak_idx - lookback_samples);
        
        for(let i=peak_idx; i >= search_start_limit; i--) {
            if(Math.abs(data[i]) < START_THRESHOLD_VAL) {
                segment_start_idx = i + 1;
                break;
            }
        }
        
        let segment_end_idx = peak_idx;
        const lookforward_samples = Math.round(0.02 * FS); 
        const search_end_limit = Math.min(data.length - 1, peak_idx + lookforward_samples);
        const peak_sign = Math.sign(data[peak_idx]);
        
        for(let i=peak_idx; i <= search_end_limit; i++) {
            if (Math.sign(data[i]) !== peak_sign && Math.sign(data[i]) !== 0) {
                segment_end_idx = i;
                break;
            }
        }
        if (segment_end_idx === peak_idx) segment_end_idx = search_end_limit;

        return {
            Start_Time: time[segment_start_idx],
            End_Time: time[segment_end_idx],
            Peak_Time: time[peak_idx],
            Peak_Val: peak_val,
        };
    }

    // v4.7のFH検出ロジック (変更なし)
    function autoDetectFHSegments() {
      const FH = getFH();
      if (!FH) {
        alert("エラー: FH (加振力) チャンネルがマッピングされていません。");
        return;
      }
      
      const FS = getFS();
      const fh_signal = FH.data;
      const time_data = mapped.time;
      const THRESHOLD_FACTOR = Number($("#autoThresholdFH").value) || 5;

      let sum = 0, sum_abs_dev = 0;
      for (const v of fh_signal) sum += v;
      const mean = sum / fh_signal.length;
      for (const v of fh_signal) sum_abs_dev += Math.abs(v - mean);
      const NOISE_FLOOR_ESTIMATE = (sum_abs_dev / fh_signal.length) * 1.25;
      const DETECTION_THRESHOLD = THRESHOLD_FACTOR * NOISE_FLOOR_ESTIMATE;
      
      const abs_fh = fh_signal.map(v => Math.abs(v));
      
      const over_threshold_indices = [];
      for (let i = 0; i < abs_fh.length; i++) {
        if (abs_fh[i] > DETECTION_THRESHOLD) {
          over_threshold_indices.push(i);
        }
      }
      
      if (over_threshold_indices.length === 0) {
        showStatus($("#autoSegmentStatus"), "FHインパルスが検出されませんでした (閾値が高すぎる可能性があります)。", false);
        resetAutoSegmentUI();
        $("#autoSegmentControls").style.display = "block";
        return;
      }
      
      const MIN_GAP_SAMPLES = Math.round(0.1 * FS);
      const start_indices = [over_threshold_indices[0]];
      for (let i = 1; i < over_threshold_indices.length; i++) {
        if (over_threshold_indices[i] - over_threshold_indices[i-1] > MIN_GAP_SAMPLES) {
          start_indices.push(over_threshold_indices[i]);
        }
      }
      
      autoSegments = [];
      
      for (let i = 0; i < start_indices.length; i++) {
        const t_search_start = time_data[Math.max(0, start_indices[i] - Math.round(0.01*FS))];
        const t_search_end = time_data[Math.min(time_data.length - 1, start_indices[i] + Math.round(0.05*FS))];
        
        const segment = findImpulseSegment(FH, t_search_start, t_search_end, THRESHOLD_FACTOR);
        
        if (segment) {
          autoSegments.push({
            Impulse_No: i + 1,
            ...segment
          });
        }
      }
      
      $("#autoSegmentControls").style.display = "block";
      $("#autoSegmentTotal").textContent = autoSegments.length;
      showStatus($("#autoSegmentStatus"), `検出完了: ${autoSegments.length} 件のFHインパルスが見つかりました。`, true);
      
      if (autoSegments.length > 0) {
        $("#segmentNo").value = 1;
        showSegmentDetail(0);
      }
    }
    
    // v4.7の自動ズームロジック (v4.6から変更)
    function showSegmentDetail(index) {
      if (index < 0 || index >= autoSegments.length) return;
      
      currentSegmentIdx = index;
      const segment = autoSegments[index];
      
      $("#autoSegmentCurrent").textContent = segment.Impulse_No;
      $("#btnPrevSegment").disabled = (index === 0);
      $("#btnNextSegment").disabled = (index === autoSegments.length - 1);
      
      // ★★★ v4.7/v4.8: ズーム範囲を Peak ± 0.0025s に ★★★
      const PADDING = 0.0025; // 2.5ms
      const zoom_start = Math.max(0, segment.Peak_Time - PADDING);
      const zoom_end = Math.min(mapped.time[mapped.time.length - 1], segment.Peak_Time + PADDING);

      const peak_marker = {
        type: 'line',
        x0: segment.Peak_Time, x1: segment.Peak_Time,
        y0: 0, y1: 1, yref: 'paper',
        line: { color: 'red', width: 2, dash: 'dash' }
      };

      for (const ch of mapped.channels) {
        const plot_dt = plotDivs_Detail[ch.name];
        if (plot_dt) {
          const shapes = (plot_dt.layout.shapes || []).filter(s => s.type === 'rect' || (s.type === 'line' && s.line.color === '#0b6bcb'));
          shapes.push(peak_marker);
          
          Plotly.relayout(plot_dt, {
            'xaxis.range': [zoom_start, zoom_end],
            'shapes': shapes
          });
        }
      }
      
      $("#segmentNo").value = segment.Impulse_No;
    }
    
    // ★★★ v4.8 追加: 理論遅延適用ロジック ★★★
    function applyTheoreticalDelay() {
      const fh = getFH();
      if (!fh) {
          alert("エラー: FH チャンネルがマッピングされていません。");
          return;
      }
      
      const fhSt = selectionStatsFor(fh);
      if (!fhSt) {
          alert("エラー: 最初にFHチャネルのセグメントを手動で（2クリックして）確定してください。");
          return;
      }
      
      const fh_start = fhSt.start;
      const fh_duration = fhSt.duration;
      let applied_count = 0;
      
      // 全チャネルをループ
      for (const ch of mapped.channels) {
          let t_start_ch = fh_start;
          let t_end_ch = fhSt.end;
          
          if (ch.role === 'Acc') {
              // AccはFHと同じと仮定 (遅延 0)
              selections[ch.name].clicks = [fh_start, fhSt.end];
              applied_count++;
          } else if (ch.role === 'Mic') {
              // Micは理論遅延を計算
              const dist = ch.distance; // マッピングで設定された距離
              if (typeof dist === 'number' && dist > 0) {
                  const delay_s = dist / soundVelocity;
                  t_start_ch = fh_start + delay_s;
                  t_end_ch = t_start_ch + fh_duration; // FHと同じ時間幅を適用
                  selections[ch.name].clicks = [t_start_ch, t_end_ch];
                  applied_count++;
              } else {
                  // 距離が未設定のMicはFHと同じにする
                  selections[ch.name].clicks = [fh_start, fhSt.end];
              }
          } else if (ch.role === 'FH') {
              // FHはそのまま
              continue;
          }
          
          drawSelectionOnPlot(ch.name); // Annotate付きで描画
      }
      
      const segNoInput = $("#segmentNo");
      if (currentSegmentIdx >= 0) {
          segNoInput.value = autoSegments[currentSegmentIdx].Impulse_No;
      }
      
      showStatus($("#autoSegmentStatus"), `OK: ${applied_count}件のAcc/Micチャネルに理論遅延を適用しました。`, true);
    }

    
    // =============================
    // Metrics (v4.8)
    // =============================
    function computeAndRenderMetrics() {
      if (!mapped) throw new Error("データがありません。");
      const fh = getFH();
      const resChs = mapped.channels.filter(c => c.role !== "FH");
      if (!fh) throw new Error("FH チャンネルが必要です。");
      if (resChs.length === 0) throw new Error("FH以外のチャンネルが必要です。");

      const fhSt = selectionStatsFor(fh);
      if (!fhSt) throw new Error("FH の範囲が未選択です (グラフを2回クリックしてください)。");
      
      const fhIdxs = idxBetween(mapped.time, fhSt.start, fhSt.end);
      if (fhIdxs.length === 0) throw new Error("FH 範囲にデータ点がありません。");

      const sumAbsS = absSum(fh.data, fhIdxs);
      const maxAbsS = absMax(fh.data, fhIdxs);

      const tbody = $("#metricsBody");
      tbody.innerHTML = "";

      const trFH = document.createElement("tr");
      trFH.innerHTML = `
        <td class="mono nowrap">${fh.name}</td>
        <td class="mono right">${fmt(sumAbsS)}</td>
        <td class="mono right">${fmt(maxAbsS)}</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>
        <td class="mono right">-</td>`;
      tbody.appendChild(trFH);

      const segNo = Number($("#segmentNo").value || 1);
      const sourceFile = currentSourceFileName || "calculation";
      summaryRows = []; 

      for (const ch of resChs) {
        const chSt = selectionStatsFor(ch); 
        if (!chSt) continue; 

        const idxs = idxBetween(mapped.time, chSt.start, chSt.end);
        if (idxs.length === 0) continue;

        const sumAbsR_raw = absSum(ch.data, idxs);
        const maxAbsR_raw = absMax(ch.data, idxs);
        const vSum = (ch.role === "Mic") ? (sumAbsR_raw / (rho*c)) : sumAbsR_raw;
        const vMax = (ch.role === "Mic") ? (maxAbsR_raw / (rho*c)) : maxAbsR_raw;
        const F_over_v_Sum = (vSum === 0) ? NaN : (sumAbsS / vSum);
        const F_over_v_Max = (vMax === 0) ? NaN : (maxAbsS / vMax);
        const F_over_v_dB_Sum = (!isFinite(F_over_v_Sum) || F_over_v_Sum<=0) ? NaN : (20*Math.log10(F_over_v_Sum));
        const F_over_v_dB_Max = (!isFinite(F_over_v_Max) || F_over_v_Max<=0) ? NaN : (20*Math.log10(F_over_v_Max));

        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td class="mono nowrap">${ch.name}</td>
          <td class="mono right">${fmt(sumAbsR_raw)}</td>
          <td class="mono right">${fmt(maxAbsR_raw)}</td>
          <td class="mono right">${isFinite(F_over_v_Sum) ? fmt(F_over_v_Sum) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_dB_Sum) ? fmt(F_over_v_dB_Sum) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_Max) ? fmt(F_over_v_Max) : ""}</td>
          <td class="mono right">${isFinite(F_over_v_dB_Max) ? fmt(F_over_v_dB_Max) : ""}</td>`;
        tbody.appendChild(tr);
        
        summaryRows.push({
          SourceFile: sourceFile,
          SegmentFile: `${sourceFile}_segment_${segNo}.csv`, 
          Channel: ch.name,
          "Sum Abs(S)": sumAbsS,
          "Max_abs(S)": maxAbsS,
          "Sum Abs(R)": sumAbsR_raw,
          "Max_abs(R)": maxAbsR_raw,
          "F/v_Sum": F_over_v_Sum,
          "F/v_dB_Sum": F_over_v_dB_Sum,
          "F/v_Max": F_over_v_Max,
          "F/v_dB_Max": F_over_v_dB_Max,
          "Seg_Start_Time": chSt.start, 
          "Seg_End_Time": chSt.end,     
          "Seg_Duration": chSt.duration 
        });
      }
    }

    // =============================
    // Exporters (v4.8)
    // =============================
    function exportCombinedSegment() {
      if (!mapped) throw new Error("データがありません。");
      
      let all_selected = true;
      for (const ch of mapped.channels) {
        const st = selectionStatsFor(ch);
        if (!st) {
          all_selected = false;
          break;
        }
      }
      if (!all_selected) throw new Error("すべてのチャネルの範囲が未選択です (各チャネルを2回クリックしてください)。");

      const slices = {};
      let minLen = Infinity;

      for (const ch of mapped.channels) {
        const st = selectionStatsFor(ch); 
        const idxs = idxBetween(mapped.time, st.start, st.end);
        slices[ch.name] = idxs.map(i => ch.data[i]);
        if (idxs.length < minLen) minLen = idxs.length;
      }

      const st0 = selectionStatsFor(mapped.channels[0]);
      const tIdxs = idxBetween(mapped.time, st0.start, st0.end).slice(0, minLen);
      const tSlice = tIdxs.map(i => mapped.time[i]);
      
      if (minLen === 0) throw new Error("選択範囲にデータ点がありません。");

      const segNo = Number($("#segmentNo").value || 1);
      const cols = ["Time (s)", ...mapped.channels.map(ch => ch.name)];
      let csv = cols.join(",") + "\n";
      for (let i = 0; i < minLen; i++) {
        const vals = mapped.channels.map(ch => (slices[ch.name][i] !== undefined ? slices[ch.name][i] : ""));
        csv += [tSlice[i].toFixed(10), ...vals].join(",") + "\n";
      }
      
      const baseFileName = currentSourceFileName || "combined";
      const fileName = `${baseFileName}_segment_${segNo}.csv`;
      
      downloadText(fileName, csv);
      
      showStatus($("#autoSegmentStatus"), `${fileName} をエクスポートしました。`, true);
    }
    
    function exportSummaryCSV() {
      if (summaryRows.length === 0) { alert("先に「メトリクス計算」を実行してください。"); return; }
      const cols = [
          "SourceFile","SegmentFile","Channel",
          "Sum Abs(S)","Max_abs(S)","Sum Abs(R)","Max_abs(R)",
          "F/v_Sum","F/v_dB_Sum","F/v_Max","F/v_dB_Max",
          "Seg_Start_Time","Seg_End_Time","Seg_Duration"
      ];
      let csv = cols.join(",") + "\n";
      for (const r of summaryRows) {
        csv += cols.map(k => {
          const v = r[k];
          if (typeof v === "number") return Number.isFinite(v) ? v.toFixed(6) : "";
          return (v ?? "");
        }).join(",") + "\n";
      }
      downloadText("calculation_summary.csv", csv);
    }

    // =============================
    // Event Wiring
    // =============================
    $("#btnLoadUrl").addEventListener("click", async () => {
      try {
        const url = $("#csvUrl").value.trim();
        if (!url) return alert("CSV URL を入力してください。");
        await loadCSVFromURL(url);
      } catch (e) {
        console.error(e);
        showStatus($("#urlStatus"), `URL読み込み失敗: ${e.message}`, false);
      }
    });
    $("#btnLoadFile").addEventListener("click", async () => {
      try {
        const f = $("#csvFile").files[0];
        if (!f) return alert("CSVファイルを選択してください。");
        await loadCSVFromFile(f);
      } catch (e) {
        console.error(e);
        showStatus($("#fileStatus"), `ファイル読み込み失敗: ${e.message}`, false);
      }
    });
    $("#btnApplyMapping").addEventListener("click", () => { try { applyMapping(); } catch (e) { console.error(e); showStatus($("#mapStatus"), `エラー: ${e.message}`, false); } });
    $("#btnResetMapping").addEventListener("click", () => {
      buildMappingUI();
      $("#plots_overview").innerHTML = ""; $("#plots_detail").innerHTML = "";
      $("#metricsBody").innerHTML = "";
      selections = {}; plotDivs_Overview = {}; plotDivs_Detail = {}; summaryRows = [];
      resetAutoSegmentUI();
      showStatus($("#mapStatus"), "マッピングをリセットしました。", true);
    });
    $("#btnPreset1").addEventListener("click", applyPreset1);
    $("#btnClearSelections").addEventListener("click", () => {
      Object.keys(selections).forEach(name => { selections[name].clicks = []; selections[name].guide = null; });
      $$("#plots_overview .plot-card > div:last-child").forEach(plot => { 
          if(plot.layout) {
              plot.layout.shapes = []; plot.layout.annotations = [];
              Plotly.redraw(plot);
          }
      });
      $$("#plots_detail .plot-card > div:last-child").forEach(plot => { 
          if(plot.layout) {
              plot.layout.shapes = (plot.layout.shapes || []).filter(s => s.line && s.line.color === 'red'); 
              plot.layout.annotations = [];
              Plotly.redraw(plot);
          }
      });
    });
    $("#btnCompute").addEventListener("click", () => { try { computeAndRenderMetrics(); } catch (e) { alert(e.message); } });
    
    $("#btnExportSegmentDetail").addEventListener("click", () => { try { exportCombinedSegment(); } catch (e) { alert(e.message); } }); 
    $("#btnExportSummary").addEventListener("click", () => { exportSummaryCSV(); });
    
    $("#btnAutoDetect").addEventListener("click", () => { try { autoDetectFHSegments(); } catch (e) { alert(e.message); console.error(e); } });
    $("#btnPrevSegment").addEventListener("click", () => { showSegmentDetail(currentSegmentIdx - 1); });
    $("#btnNextSegment").addEventListener("click", () => { showSegmentDetail(currentSegmentIdx + 1); });
    
    // ★★★ v4.8 追加: 新しいボタンのリスナー ★★★
    $("#btnApplyTheoreticalDelay").addEventListener("click", () => { try { applyTheoreticalDelay(); } catch (e) { alert(e.message); } });
    
  </script>
</body>
</html>
