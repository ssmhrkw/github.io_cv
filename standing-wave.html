<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>スラブ（SS境界） v/F ビジュアライザ</title>
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
  :root{--bg:#f7f8fb;--card:#fff;--ink:#0f172a;--muted:#475569;--accent:#2563eb}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:Inter,"Noto Sans JP",system-ui,Segoe UI,Roboto}
  .wrap{max-width:1200px;margin:16px auto;padding:12px}
  h1{font-size:18px;margin:6px 0}
  .card{background:var(--card);border-radius:10px;padding:12px;border:1px solid #e6edf3;box-shadow:0 1px 2px rgba(2,6,23,0.03)}
  .grid{display:grid;grid-template-columns:360px 1fr;gap:12px}
  label{display:block;font-size:13px;color:var(--muted);margin-bottom:4px}
  input,select{width:100%;padding:8px;border-radius:8px;border:1px solid #e6edf3;margin-bottom:8px;box-sizing:border-box}
  .row{margin-bottom:8px}
  .btn{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#fff;cursor:pointer}
  .small{font-size:13px;color:var(--muted)}
  #plot{height:76vh;min-height:520px}
  .inline{display:flex;gap:8px;align-items:center}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:13px}
  footer{margin-top:8px;font-size:13px;color:var(--muted)}
  table{font-size:13px;border-collapse:collapse}
  td,th{padding:4px 6px;border-bottom:1px solid #f1f5f9}
</style>
</head>
<body>
<div class="wrap">
  <h1>スラブ平板（四周SS） v/F ビジュアライザ</h1>
  <div class="grid">
    <div class="card">
      <div class="row">
        <label>寸法 Lx [m], Ly [m]</label>
        <div style="display:flex;gap:8px">
          <input id="Lx" type="number" step="0.01" value="5.00">
          <input id="Ly" type="number" step="0.01" value="4.00">
        </div>
      </div>

      <div class="row">
        <label>板厚 h [m]</label>
        <input id="h" type="number" step="0.01" value="0.15">
      </div>

      <div class="row">
        <label>材料（コンクリート）E[Pa], ν, ρ[kg/m³]</label>
        <div style="display:flex;gap:8px">
          <input id="E" type="number" step="1e8" value="30e9">
          <input id="nu" type="number" step="0.01" value="0.20">
          <input id="rho" type="number" step="10" value="2400">
        </div>
      </div>

      <div class="row">
        <label>モード最大 (m_max, n_max)</label>
        <div style="display:flex;gap:8px">
          <input id="mmax" type="number" min="1" max="12" value="5">
          <input id="nmax" type="number" min="1" max="12" value="5">
        </div>
      </div>

      <div class="row">
        <label>周波数 f [Hz]（任意指定。デフォルトは (1,1) 固有周波数）</label>
        <input id="freq" type="number" step="0.1" value="">
      </div>

      <div class="row">
        <label>加振点 (x0,y0) [m]（点力 1 N，垂直）</label>
        <div style="display:flex;gap:8px">
          <input id="x0" type="number" step="0.01" value="2.50">
          <input id="y0" type="number" step="0.01" value="2.00">
        </div>
        <div class="small">クリックでグリッド上の加振点を設定できます（右側プロット上で）</div>
      </div>

      <div class="row">
        <label>表示量</label>
        <select id="displayChoice">
          <option value="v_over_F">v / F （m/s per N）</option>
          <option value="F_over_v">F / v （N per (m/s)）</option>
        </select>
      </div>

      <div class="row">
        <label>描画</label>
        <div style="display:flex;gap:8px">
          <button id="renderBtn" class="btn">描画 / 更新</button>
          <button id="snapBtn" style="padding:8px;border-radius:8px">スナップショット</button>
        </div>
      </div>

      <div class="row">
        <label>表示タイプ</label>
        <div style="display:flex;gap:8px">
          <label><input type="checkbox" id="show2d" checked> 2D ヒートマップ</label>
          <label><input type="checkbox" id="show3d" checked> 3D サーフェス</label>
        </div>
      </div>

      <div class="row">
        <label>グリッド解像度 Ngrid</label>
        <input id="Ngrid" type="number" step="8" min="32" value="120">
      </div>

      <div class="row">
        <label>小説明 (固有周波数一覧)</label>
        <div id="modalTable" class="card mono" style="padding:8px;max-height:160px;overflow:auto"></div>
      </div>

      <footer class="small card" style="margin-top:10px">
        <div><strong>式（簡潔）</strong></div>
        <div>曲げ剛性 D = E h³ / [12 (1-ν²)]</div>
        <div>固有角周波数 ω<sub>mn</sub> = √(D/(ρ h)) · [ (mπ/Lx)² + (nπ/Ly)² ]</div>
        <div>モード形 φ<sub>mn</sub>(x,y) = sin(mπx/Lx)·sin(nπy/Ly) （SS 両端支持）</div>
        <div>変位 W(x,y) = Σ η<sub>mn</sub> φ<sub>mn</sub>(x,y), η<sub>mn</sub> = F φ<sub>mn</sub>(x₀,y₀) / [M<sub>mn</sub>(ω<sub>mn</sub>² - ω² + i ω ω<sub>mn</sub>/Q)]</div>
        <div>速度 |v| = ω · |W|。ここでは Q を大きくして減衰を無視します。</div>
      </footer>
    </div>

    <div class="card">
      <div id="plot"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const $ = id => document.getElementById(id);
  // Complex helpers
  const cadd = (a,b)=>({re:a.re+b.re,im:a.im+b.im});
  const csub = (a,b)=>({re:a.re-b.re,im:a.im-b.im});
  const cmul = (a,b)=>({re:a.re*b.re - a.im*b.im, im: a.re*b.im + a.im*b.re});
  const cdiv = (a,b)=>{ const d=b.re*b.re+b.im*b.im; return {re:(a.re*b.re + a.im*b.im)/d, im:(a.im*b.re - a.re*b.im)/d};};
  const cabs = a=>Math.hypot(a.re,a.im);

  function D_of(E,h,nu){ return E * Math.pow(h,3) / (12*(1 - nu*nu)); }

  function buildModes(Lx,Ly,E,nu,rho,h,mmax,nmax){
    const D = D_of(E,h,nu);
    const modes = [];
    for(let m=1;m<=mmax;m++){
      for(let n=1;n<=nmax;n++){
        const k2 = Math.pow(m*Math.PI/Lx,2) + Math.pow(n*Math.PI/Ly,2);
        const omega = Math.sqrt(D/(rho*h)) * k2; // rad/s
        const f = omega / (2*Math.PI);
        modes.push({m,n,omega,f});
      }
    }
    modes.sort((a,b)=>a.f-b.f);
    return modes;
  }

  function phi(m,n,x,y,Lx,Ly){ return Math.sin(m*Math.PI*x/Lx) * Math.sin(n*Math.PI*y/Ly); }

  function modalMass(rho,h,Lx,Ly){
    // ∫φ^2 dA = Lx*Ly/4 for sin modes
    return rho * h * (Lx*Ly) / 4.0;
  }

  function computeField(opts){
    const {Lx,Ly,E,nu,rho,h,modes,mmax,nmax,freq,x0,y0,Ngrid,displayChoice,Q} = opts;
    const omega = 2*Math.PI*freq;
    const Mmn = modalMass(rho,h,Lx,Ly);
    // grid
    const Nx = Ngrid, Ny = Ngrid;
    const xs = new Array(Nx); const ys = new Array(Ny);
    for(let i=0;i<Nx;i++) xs[i] = Lx * i/(Nx-1);
    for(let j=0;j<Ny;j++) ys[j] = Ly * j/(Ny-1);
    // evaluate complex displacement field (sum of modes)
    const W = new Array(Ny*Nx).fill(0).map(()=>({re:0,im:0}));
    const F = 1.0; // unit point force (N)
    // sum modes (only modes with m<=mmax & n<=nmax)
    for(const md of modes){
      if(md.m>mmax || md.n>nmax) continue;
      const omega_m = md.omega;
      const phi0 = phi(md.m,md.n,x0,y0,Lx,Ly);
      // generalized force = F * phi0
      const num = {re: F * phi0, im: 0};
      // denom: Mmn*(omega_m^2 - omega^2 + i*omega*omega_m/Q)
      const real = Mmn * (omega_m*omega_m - omega*omega);
      const imag = Mmn * (omega * omega_m / Q);
      const denom = {re: real, im: imag};
      const eta = cdiv(num, denom); // complex modal amplitude
      // add to W: eta * phi(x,y)
      for(let j=0;j<Ny;j++){
        const cy = Math.sin(md.n * Math.PI * ys[j] / Ly);
        for(let i=0;i<Nx;i++){
          const cx = Math.sin(md.m * Math.PI * xs[i] / Lx);
          const idx = j*Nx + i;
          const ph = cx * cy;
          // W[idx] += eta * ph
          W[idx] = cadd(W[idx], {re: eta.re * ph, im: eta.im * ph});
        }
      }
    }
    // compute velocity amplitude magnitude |v| = ω * |W|
    const Vmag = new Float64Array(Ny*Nx);
    for(let k=0;k<W.length;k++){
      Vmag[k] = omega * cabs(W[k]); // m/s
    }
    // produce either v/F or F/v
    const out = new Float64Array(Ny*Nx);
    if(displayChoice === 'v_over_F'){
      for(let k=0;k<out.length;k++) out[k] = Vmag[k] / 1.0;
    }else{
      for(let k=0;k<out.length;k++) out[k] = (Vmag[k] > 0 ? 1.0 / Vmag[k] : 0);
    }
    return {xs,ys,Z:out};
  }

  // plotting helpers
  function to2D(arr,Nx,Ny){
    const z = new Array(Ny);
    for(let j=0;j<Ny;j++){
      const row = new Array(Nx);
      for(let i=0;i<Nx;i++) row[i] = arr[j*Nx + i];
      z[j]=row;
    }
    return z;
  }

  // initial render and wiring
  function render(){
    const Lx = parseFloat($('Lx').value);
    const Ly = parseFloat($('Ly').value);
    const h = parseFloat($('h').value);
    const E = parseFloat($('E').value);
    const nu = parseFloat($('nu').value);
    const rho= parseFloat($('rho').value);
    const mmax = parseInt($('mmax').value);
    const nmax = parseInt($('nmax').value);
    const Ngrid = parseInt($('Ngrid').value);
    // build modes
    const modes = buildModes(Lx,Ly,E,nu,rho,h,mmax,nmax);
    // default freq set to first mode if empty
    if(!$('freq').value || $('freq').value.trim()===''){
      $('freq').value = modes[0].f.toFixed(3);
    }
    const freq = parseFloat($('freq').value);
    const x0 = clamp(parseFloat($('x0').value), 0, Lx);
    const y0 = clamp(parseFloat($('y0').value), 0, Ly);
    const displayChoice = $('displayChoice').value;
    const Q = 1e8; // effectively no damping for simple model (large Q)
    // compute field
    const field = computeField({Lx,Ly,E,nu,rho,h,modes,mmax,nmax,freq,x0,y0,Ngrid,displayChoice,Q});
    // prepare plot traces
    const show2d = $('show2d').checked;
    const show3d = $('show3d').checked;
    const z2d = to2D(field.Z,Ngrid,Ngrid);
    const zmin = Math.min(...field.Z);
    const zmax = Math.max(...field.Z);
    const heatmap = {
      z: z2d,
      x: field.xs,
      y: field.ys,
      type: 'heatmap',
      colorscale: 'Viridis',
      zmin: zmin,
      zmax: zmax,
      colorbar: {title: $('displayChoice').value === 'v_over_F' ? 'm/s per N' : 'N per (m/s)'}
    };
    const surface = {
      z: z2d,
      x: field.xs,
      y: field.ys,
      type: 'surface',
      showscale:false,
      opacity:0.9
    };
    // marker for excitation point
    const px = parseFloat($('x0').value), py = parseFloat($('y0').value);
    const pt = {x:[px], y:[py], z:[z2d[Math.round((Ngrid-1)*py/Ly)][Math.round((Ngrid-1)*px/Lx)]], mode:'markers+text', marker:{size:6,color:'red'}, text:['P'], textposition:'top center', type:'scatter3d'};
    // build layout
    const layout = {
      margin:{l:60,r:10,t:30,b:60},
      scene:{xaxis:{title:'x [m]'}, yaxis:{title:'y [m]'}, zaxis:{title: $('displayChoice').value === 'v_over_F' ? 'm/s per N' : 'N per (m/s)'}},
      xaxis:{title:'x [m]'},
      yaxis:{title:'y [m]'},
      annotations: [{
        text: `f=${freq.toFixed(3)} Hz, source=(${px.toFixed(2)},${py.toFixed(2)})`,
        xref:'paper', yref:'paper', x:0.02, y:1.02, showarrow:false, font:{size:12}
      }]
    };
    const data = [];
    if(show2d) data.push(heatmap);
    if(show3d) { data.push(surface); data.push(pt); }
    // if only heatmap, plot 2D; if surface present, Plotly will show 3d scene. To support both elegantly, we'll create combined layout: if show3d then plot 3D, else 2D
    if(show3d){
      // convert heatmap to surface-compatible z (already), use surface + point
      Plotly.newPlot('plot', data, layout, {responsive:true,displaylogo:false});
    }else{
      // only 2D heatmap
      const layout2 = {margin:{l:60,r:10,t:30,b:60}, xaxis:{title:'x [m]',range:[0,Lx]}, yaxis:{title:'y [m]',autorange:'reversed',range:[0,Ly]}, annotations:layout.annotations};
      Plotly.newPlot('plot', [heatmap], layout2, {responsive:true,displaylogo:false});
      // attach click handler for setting excitation point on heatmap
    }
    // modal table
    const modalDiv = $('modalTable');
    modalDiv.innerHTML = '';
    const tbl = document.createElement('table');
    const header = document.createElement('tr');
    header.innerHTML = '<th>rank</th><th>m,n</th><th>f [Hz]</th>';
    tbl.appendChild(header);
    for(let i=0;i<Math.min(20,modes.length);i++){
      const r = document.createElement('tr');
      r.innerHTML = `<td>${i+1}</td><td>(${modes[i].m},${modes[i].n})</td><td>${modes[i].f.toFixed(3)}</td>`;
      tbl.appendChild(r);
    }
    modalDiv.appendChild(tbl);

    // enable clicking to set excitation point when in 2D heatmap mode
    const plotEl = document.getElementById('plot');
    plotEl.on('plotly_click', function(evt){
      // handle only 2D heatmap clicks
      const pts = evt.points && evt.points[0];
      if(!pts) return;
      if(!$('show2d').checked) return;
      // get x,y from click
      const cx = pts.x, cy = pts.y;
      // clamp and set
      const nx = Math.max(0, Math.min(Lx, cx));
      const ny = Math.max(0, Math.min(Ly, cy));
      $('x0').value = nx.toFixed(3);
      $('y0').value = ny.toFixed(3);
      // re-render
      render();
    });
  }

  function clamp(x,a,b){ return Math.max(a,Math.min(b,x)); }

  // initial
  render();

  $('renderBtn').addEventListener('click', render);
  $('snapBtn').addEventListener('click', ()=> {
    Plotly.toImage('plot',{format:'png',width:1200,height:800}).then(url=>{
      const a=document.createElement('a'); a.href=url; a.download=`slab_v_over_F_${Date.now()}.png`; a.click();
    });
  });

})();
</script>
</body>
</html>
