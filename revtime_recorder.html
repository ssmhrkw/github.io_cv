<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hand-Clap RT (EDT/T10/T20/T30) + SNR判定 v2.6</title>

  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HFR5WYG42Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date()); gtag('config','G-HFR5WYG42Q');
  </script>

  <style>
    :root{
      --bg:#f7f8fb; --card:#ffffff; --ink:#0f172a; --muted:#64748b;
      --accent:#2563eb; --ok:#16a34a; --warn:#eab308; --err:#dc2626;
      --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    }
    *{box-sizing:border-box}
    body{ margin:0; color:var(--ink); background:var(--bg);
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic","ヒラギノ角ゴ ProN W3","メイリオ",sans-serif; line-height:1.55; }
    header{ position:sticky; top:0; z-index:10; background:linear-gradient(90deg,#fff,#f5f9ff); border-bottom:1px solid #e2e8f0; }
    .wrap{ max-width:1200px; margin:0 auto; padding:16px; }
    h1{ font-size:clamp(20px,2.4vw,28px); margin:0 0 6px; }
    .sub{ color:var(--muted); font-size:14px; }
    main{ max-width:1200px; margin:18px auto; padding:0 16px 40px; }
    .grid{ display:grid; gap:16px; grid-template-columns: repeat(12, 1fr); }
    .card{ background:var(--card); border:1px solid #e5e7eb; border-radius:18px; padding:16px; box-shadow: 0 6px 24px rgba(30,41,59,0.06); }
    .card h2{ margin:0 0 10px; font-size:18px }
    .controls{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    button{ appearance:none; border:0; border-radius:14px; padding:10px 14px; font-weight:600; cursor:pointer; background:var(--accent); color:white; box-shadow:0 6px 16px rgba(37,99,235,0.2); }
    button.secondary{ background:#e2e8f0; color:#0f172a; }
    button.ghost{ background:transparent; color:var(--accent); border:1px solid #c7d2fe}
    button:disabled{ opacity:.6; cursor:not-allowed }
    label{ font-size:14px; color:var(--muted) }
    select, input[type="number"]{
      border:1px solid #e5e7eb; background:white; color:#0f172a; border-radius:12px; padding:8px 10px; min-width:100px;
    }
    .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-weight:700; font-size:12px }
    .hint{ font-size:12px; color:var(--muted) }
    .ok{ color:var(--ok) } .warn{ color:var(--warn) } .err{ color:var(--err) }
    table{ width:100%; border-collapse:collapse; }
    th, td{ padding:8px 10px; border-bottom:1px solid #e5e7eb; text-align:right; font-variant-numeric:tabular-nums; vertical-align:middle; }
    th:first-child, td:first-child{ text-align:left }
    .mono{ font-family:var(--mono); }
    .judge{ font-weight:800; padding:4px 10px; border-radius:999px; display:inline-block; }
    .judge.ok{ background:#ecfdf5; color:#065f46; border:1px solid #34d399; }
    .judge.ng{ background:#fef2f2; color:#991b1b; border:1px solid #fca5a5; }
    .decay-plot-cell{ text-align:center; }
    .decay-plot-cell canvas{ display:inline-block; width:160px; height:50px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; }
    @media (max-width:920px){ .grid{ grid-template-columns: repeat(6,1fr); } }
    @media (max-width:640px){ .grid{ grid-template-columns: repeat(4,1fr); } .controls{ gap:8px } }
    canvas#wave{ width:100%; height:150px; background:#fff; border-radius:12px; border:1px solid #e5e7eb }

    /* 録音状態フィードバック */
    button.recording { background: var(--err); box-shadow: 0 6px 16px rgba(220,38,38,0.2); }
    button.recorded  { background: var(--muted); box-shadow: 0 6px 16px rgba(100,116,139,0.2); }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>手をたたいて残響時間を推定（コンセプト）</h1>
    <div class="sub">録音 → 1/1オクターブBPF（含む63 Hz）→ シュレーダー積分 → 直線回帰（EDT/T10/T20/T30）／ 事前暗騒音と比較したSNRでOK/NG</div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card" style="grid-column: span 12;">
      <h2>1) 測定と入力</h2>
      <div class="controls">
        <button id="btnRecord"><span id="recLabel">録音開始</span></button>
        <button id="btnStop" class="secondary" disabled>停止</button>
        <label>録音長（秒）<input type="number" id="recSec" value="5" step="1" min="3" max="20" /></label>

        <label>測定点数
          <select id="measCount">
            <option value="1" selected>1</option>
            <option value="3">3</option>
            <option value="5">5</option>
          </select>
        </label>

        <button id="btnCommit" class="ghost" disabled>この測定を保存</button>
        <button id="btnAvg" class="ghost" disabled>平均を計算</button>

        <input type="file" id="fileInput" accept="audio/*" />
        <span id="state" class="pill">idle</span>
      </div>
      <p class="hint">静かな部屋で、<b>ボタンを押して約1秒後に1回だけ強く手を叩いてください</b>。端末側のNR/AGCは無効化要求を出しますが、OS依存で完全には止まりません。</p>
      <audio id="player" controls playsinline style="width:100%; display:none;"></audio>
      <div id="envInfo" class="footer-note mono"></div>
      <div class="footer-note">デバイス処理要求: echoCancellation=false / noiseSuppression=false / autoGainControl=false（適用可否は端末次第）</div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>2) 解析・判定設定</h2>
      <div class="controls">
        <label>帯域
          <select id="bandType">
            <option value="ob_63_4k" selected>1/1 Octave（63 Hz ～ 4 kHz）</option>
            <option value="ob_31_4k">1/1 Octave（31.5 Hz ～ 4 kHz）</option>
            <option value="ob_125_4k">1/1 Octave（125 Hz ～ 4 kHz）</option>
            <!-- 将来: 1/3 Octave は "tb_*" などの識別子で追加 -->
          </select>
        </label>
        <label><input type="checkbox" id="snrInclude63" checked/> 判定に63 Hzも含める</label>
        <label><input type="checkbox" id="noiseComp" checked/> BGノイズ補正（シュレーダー積分時に暗騒音電力を減算）</label>

        <button id="btnAnalyze" class="ghost" disabled>解析する</button>
        <button id="btnDownloadCsv" class="ghost" disabled>CSVを保存</button>
      </div>
      <p class="hint">SNRは<b>手拍子直後200 ms</b>の平均パワーと<b>手拍子前0.5 s</b>の平均パワーの比（10log10）。<span style="font-weight:700">中央値SNR</span>がしきい値以上なら<b>OK</b>。</p>
      <div>全体判定：<span id="overallJudge" class="judge ng">NG</span> <span id="overallNote" class="mono" style="margin-left:8px;"></span></div>
      <div class="footer-note">測定保存数: <span id="measSaved" class="mono">0</span> / <span id="measTarget" class="mono">1</span></div>
    </section>

    <section class="card" style="grid-column: span 12%;">
      <h2>3) 結果（帯域別）</h2>
      <div id="resultsWrap">
        <table id="results">
          <thead>
            <tr>
              <th>中心周波数 [Hz]</th>
              <th>EDT [s]</th>
              <th>T10 [s]</th>
              <th>T20 [s]</th>
              <th>T30 [s]</th>
              <th>R²（代表回帰）</th>
              <th>SNR [dB]</th>
              <th>判定</th>
              <th>減衰曲線</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="footer-note">代表回帰＝T30優先→T20→T10→EDT。回帰直線ラベルに<b>EDT/T10/T20/T30</b>を明示。</div>
      </div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>5) 元信号の切り取り位置</h2>
      <canvas id="wave"></canvas>
      <div class="footer-note">解析に用いた切り出し範囲の原波形。赤＝手拍子検出点、青帯＝事前暗騒音窓、緑帯＝直後200 ms窓。</div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>注意・限界</h2>
      <ul>
        <li>スマホ内蔵マイクは低域（～100 Hz）で感度が低いことが多く、<b>63 Hz</b>はSNR不足になりがちです。</li>
        <li>getUserMediaでechoCancellation/noiseSuppression/autoGainControlを<b>false</b>指定し、可能ならトラックにもapplyConstraintsします。iOS Safari等では完全に無効化できない場合があります。</li>
        <li>厳密測定には標準化手順・信号の使用を推奨。本ツールは簡易推定・事前チェック用です。</li>
      </ul>
    </section>
  </div>
</main>

<script type="module">
import { designButterworthBandpassSOS_N, sosFilter } from "./acoustics-core.js";

(() => {
  const $ = (s)=>document.querySelector(s);
  const $$ = (s)=>Array.from(document.querySelectorAll(s));
  const db10 = (x)=>10*Math.log10(Math.max(1e-24, x));
  const db20 = (x)=>20*Math.log10(Math.max(1e-12, Math.abs(x)));

  const player = $('#player');
  const stateEl = $('#state');
  const recBtn = $('#btnRecord');
  const stopBtn = $('#btnStop');
  const analyzeBtn = $('#btnAnalyze');
  const csvBtn = $('#btnDownloadCsv');
  const fileInput = $('#fileInput');

  let mediaStream = null;
  let recorder = null;
  let recordedChunks = [];
  let lastBuffer = null;  // {fs, data: Float32Array}
  let userConfirmed = false;

  // ---- 起動時の警告ポップアップ（confirm） ----
  function initConsent(){
    const ok = window.confirm('このツールは簡易測定用であり、標準的な残響時間測定の要件を満たしません。測定結果の正確性について保証はできません。よろしいですか？');
    userConfirmed = !!ok;
    if(!userConfirmed){
      recBtn.disabled = true;
      fileInput.disabled = true;
      analyzeBtn.disabled = true;
      csvBtn.disabled = true;
      stopBtn.disabled = true;
      stateEl.textContent = '警告確認待ち';
    }else{
      stateEl.textContent = 'idle';
    }
  }

  function makeBands(kind){
    // 1/1 Octave
    if(kind==='ob_31_4k') return [31.5,63,125,250,500,1000,2000,4000];
    if(kind==='ob_125_4k') return [125,250,500,1000,2000,4000];
    if(kind==='ob_63_4k') return [63,125,250,500,1000,2000,4000];
    // 1/3 Octave（将来拡張: 接頭辞 "tb_" を想定）
    // 例: tb_100_4k のようなIDであれば適宜生成（ここでは型のみ準備）
    if(kind.startsWith('tb_')){
      // 最小限の例。実際の1/3オクターブ中心周波数列は必要に応じて差し替え
      return [100,125,160,200,250,315,400,500,630,800,1000,1250,1600,2000,2500,3150,4000];
    }
    return [63,125,250,500,1000,2000,4000];
  }

  function pickRecorderMime(){
    const cands = [
      'audio/mp4;codecs=aac','audio/aac','audio/mp4',
      'audio/webm;codecs=opus','audio/webm'
    ];
    for(const t of cands){ if(window.MediaRecorder && MediaRecorder.isTypeSupported?.(t)) return t; }
    return '';
  }

  // ===== BPF：次数を帯域タイプで変更（1/1:36次, 1/3:24次）=====
  async function bandpassFilter(samples, fs, fc, bandType){
    const isOneThird = bandType.includes('tb_'); // 1/3 Octave の識別
    const N = isOneThird ? 24 : 36;
    const sos = designButterworthBandpassSOS_N(fc, fs, N);
    return sosFilter(samples, sos);
  }

  function detectClapStart(samples, fs, trigDb){
    let maxAbs=0, maxIdx=0;
    for(let i=0;i<samples.length;i++){ const a=Math.abs(samples[i]); if(a>maxAbs){ maxAbs=a; maxIdx=i; } }
    const peakDb = db20(maxAbs);
    if(peakDb < trigDb) return {idx:-1, peakDb};
    const pre = Math.floor(0.01*fs);
    return {idx: Math.max(0, maxIdx-pre), peakDb};
  }

  function sliceForAnalysis(samples, fs, startIdx){
    const maxDur=1.0; // 1秒に短縮
    const N = Math.min(samples.length-startIdx, Math.floor(maxDur*fs));
    const out = new Float32Array(N);
    let mean=0; for(let i=0;i<N;i++) mean += samples[startIdx+i]; mean/=N;
    for(let i=0;i<N;i++) out[i] = samples[startIdx+i]-mean;
    return out;
  }

  function schroederDB(x){
    const N=x.length; const e=new Float64Array(N);
    for(let i=0;i<N;i++){ const v=x[i]; e[i]=v*v; }
    for(let i=N-2;i>=0;i--) e[i]+=e[i+1];
    const e0=e[0] + 1e-12;
    const out=new Float32Array(N);
    for(let i=0;i<N;i++){ const r=Math.max(e[i]/e0,1e-12); out[i]=10*Math.log10(r); }
    return out;
  }

  function schroederDBNoiseComp(x, pbg){
    const N = x.length;
    const e = new Float64Array(N);
    let acc = 0;
    for(let i=N-1;i>=0;i--){
      const pi = x[i]*x[i] - pbg;
      acc += (pi > 0 ? pi : 0);
      e[i] = acc;
    }
    const e0 = e[0] + 1e-12;
    const out = new Float32Array(N);
    for(let i=0;i<N;i++){
      const r = Math.max(e[i]/e0, 1e-12);
      out[i] = 10*Math.log10(r);
    }
    return out;
  }

  function pickSegment(dBcurve, mode){
    let hi, lo;
    if(mode==='EDT'){ hi=0; lo=-10; }
    else if(mode==='T10'){ hi=-5; lo=-15; }
    else if(mode==='T20'){ hi=-5; lo=-25; }
    else if(mode==='T30'){ hi=-5; lo=-35; }
    else { hi=0; lo=-10; }
    const N=dBcurve.length; let i0=-1, i1=-1;
    for(let i=0;i<N;i++){ if(dBcurve[i]<hi){ i0=i; break; } }
    if(i0<0) return null;
    for(let i=i0;i<N;i++){ if(dBcurve[i]<lo){ i1=i; break; } }
    if(i1<0 || i1-i0<100) return null;
    return [i0,i1];
  }

  function linreg(x, y){
    const n = x.length; if(n<2) return {a:NaN,b:NaN,r2:NaN};
    let sx=0, sy=0, sxy=0, sxx=0, syy=0;
    for(let i=0;i<n;i++){ const xi=x[i], yi=y[i]; sx+=xi; sy+=yi; sxy+=xi*yi; sxx+=xi*xi; syy+=yi*yi; }
    const denom = n*sxx - sx*sx; if(Math.abs(denom)<1e-12) return {a:NaN,b:NaN,r2:NaN};
    const a = (n*sxy - sx*sy)/denom; const b=(sy - a*sx)/n;
    const ym = sy/n; let ssT=0, ssR=0;
    for(let i=0;i<n;i++){ const yi=y[i], yh=a*x[i]+b; ssT+=(yi-ym)**2; ssR+=(yi-yh)**2; }
    const r2 = ssT>0? 1-ssR/ssT : NaN;
    return {a,b,r2};
  }

  function fitRT(dBcurve, fs, mode){
    const seg = pickSegment(dBcurve, mode);
    if(!seg) return {T:NaN,a:NaN,b:NaN,r2:NaN,seg:null, used:null};
    const [i0,i1]=seg; const n=i1-i0;
    const x=new Float64Array(n), y=new Float64Array(n);
    for(let k=0;k<n;k++){ x[k]=i0+k; y[k]=dBcurve[i0+k]; }
    const {a,b,r2}=linreg(x,y);
    if(!isFinite(a) || Math.abs(a)<1e-12) return {T:NaN,a,b,r2,seg, used:mode};
    const T60 = -60/(a*fs);
    if(T60<=0 || T60>20) return {T:NaN,a,b,r2,seg, used:mode};
    return {T:T60,a,b,r2,seg, used:mode};
  }

  // 元信号Zoom描画
  function drawWave(canvas, data, fs, markers, i_start = 0, i_end = -1){
    const ctx=canvas.getContext('2d'); const W=canvas.width=canvas.clientWidth, H=canvas.height=canvas.clientHeight;
    ctx.clearRect(0,0,W,H); ctx.strokeStyle='#0f172a22'; ctx.strokeRect(0,0,W,H);
    if(!data || data.length === 0) return;

    if(i_end === -1) i_end = data.length;
    i_start = Math.max(0, i_start);
    i_end = Math.min(data.length, i_end);
    const N_disp = i_end - i_start;
    if(N_disp <= 0) return;

    ctx.strokeStyle='#0f172a'; ctx.beginPath();
    for(let x=0; x<W; x++){
      const i = i_start + Math.floor(x * N_disp / W);
      const y = data[i] || 0;
      const yy = H*(0.5-0.45*y);
      if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
    }
    ctx.stroke();

    if(markers){
      for(const m of markers){
        const x = Math.floor(((m.idx - i_start) / N_disp) * W);
        ctx.strokeStyle = m.color;
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
        if(m.band){
          ctx.fillStyle = m.color+'33';
          const x2 = Math.floor(((m.idx2 - i_start) / N_disp) * W);
          ctx.fillRect(Math.min(x,x2), 0, Math.abs(x2-x), H);
        }
      }
    }
  }

  // インライン減衰プロット：T10/T20/T30 の区間と直線を色分け
  function drawInlineDecay(div, dBcurve, fitsAll, repFit){
    const W=160, H=50;
    const canvas=document.createElement('canvas'); canvas.width=W; canvas.height=H;
    div.appendChild(canvas);
    const ctx=canvas.getContext('2d');
    ctx.clearRect(0,0,W,H);
    const N=dBcurve.length;
    const minY=-80, maxY=0;
    const x2px = (i)=> i/N*W;
    const y2px = (v)=> (1-(v-minY)/(maxY-minY))*H;

    // 区間背景色
    const segStyles = [
      {key:'T30', fill:'#f59e0b55', stroke:'#f59e0b'}, // オレンジ
      {key:'T20', fill:'#22c55e55', stroke:'#22c55e'}, // 緑
      {key:'T10', fill:'#3b82f655', stroke:'#3b82f6'}, // 青
      // EDT は薄グレー（任意）
      {key:'EDT', fill:'#9ca3af33', stroke:'#94a3b8'}
    ];
    for(const s of segStyles){
      const f = fitsAll?.[s.key];
      if(f && f.seg){
        const [i0,i1]=f.seg;
        ctx.fillStyle = s.fill;
        ctx.fillRect(x2px(i0),0,Math.max(1,x2px(i1)-x2px(i0)),H);
      }
    }

    // 減衰曲線
    ctx.strokeStyle='#0f172a'; ctx.lineWidth=1; ctx.beginPath();
    for(let i=0;i<N;i++){
      const x=x2px(i), y=y2px(dBcurve[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();

    // 回帰直線
    for(const s of segStyles){
      const f = fitsAll?.[s.key];
      if(f && f.seg && isFinite(f.a)){
        const [i0,i1]=f.seg;
        ctx.strokeStyle=s.stroke; ctx.setLineDash([2,2]); ctx.lineWidth=1; ctx.beginPath();
        const y0 = f.a*i0 + f.b;
        const y1 = f.a*(i1-1) + f.b;
        ctx.moveTo(x2px(i0), y2px(y0)); ctx.lineTo(x2px(i1-1), y2px(y1)); ctx.stroke(); ctx.setLineDash([]);
      }
    }
  }

  function makeCSV(rows){
    const head=['fc_Hz','EDT_s','T10_s','T20_s','T30_s','R2','SNR_dB','Judge'];
    const lines=[head.join(',')];
    for(const r of rows){
      lines.push([r.fc.toFixed(1), ...['EDT','T10','T20','T30'].map(k=>isFinite(r[k])?r[k].toFixed(3):''), (r.R2??'').toString(), r.SNR.toFixed(1), r.judge].join(','));
    }
    return new Blob([lines.join('\n')], {type:'text/csv'});
  }

  async function decodeBlobToMonoFloat(blob){
    const ac = new (window.AudioContext || window.webkitAudioContext)({sampleRate:48000});
    const arrbuf = await blob.arrayBuffer();
    const audioBuf = await ac.decodeAudioData(arrbuf);
    const fs = audioBuf.sampleRate;
    const ch0 = audioBuf.getChannelData(0);
    const out = new Float32Array(ch0.length);
    out.set(ch0);
    ac.close();
    return {fs, data:out};
  }

  function enableDuringRecording(v){
    recBtn.disabled=v; stopBtn.disabled=!v; analyzeBtn.disabled=true; csvBtn.disabled=true;
  }

  function setState(s){ stateEl.textContent=s; }

  async function startRecording(){
    if(!userConfirmed){ initConsent(); if(!userConfirmed) return; }
    const recSec = Math.max(1, Math.min(20, parseInt($('#recSec').value,10) || 5));
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });

    const mime = pickRecorderMime();
    recorder = new MediaRecorder(mediaStream, mime ? {mimeType:mime} : undefined);
    recordedChunks = [];

    // ボタン状態を「録音中」に
    recBtn.classList.remove('recorded');
    recBtn.classList.add('recording');
    $('#recLabel').textContent = '録音中';

    recorder.ondataavailable = e=>{ if(e.data && e.data.size>0) recordedChunks.push(e.data); };
    recorder.onstop = async ()=>{
      const type = mime || recordedChunks[0]?.type || 'audio/mp4';
      const blob = new Blob(recordedChunks, {type});
      const url = URL.createObjectURL(blob);
      player.src = url;
      player.style.display='block';
      try { await player.play(); } catch(_) {}

      lastBuffer = await decodeBlobToMonoFloat(blob);
      setState(`recorded @ ${lastBuffer.fs} Hz, ${lastBuffer.data.length} samples`);
      analyzeBtn.disabled = false;

      // 完了時「録音完了」
      recBtn.classList.remove('recording');
      recBtn.classList.add('recorded');
      $('#recLabel').textContent = '録音完了';
    };
    recorder.start();
    enableDuringRecording(true); setState('recording…');
    setTimeout(()=>{
      if(recorder && recorder.state==='recording') recorder.stop();
      stopStream(); enableDuringRecording(false);
    }, recSec*1000);
  }

  function stopStream(){
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  }

  function stopRecording(){
    if(recorder && recorder.state==='recording'){ recorder.stop(); }
    stopStream(); enableDuringRecording(false); setState('stopped');
  }

  function fitAll(dec, fs){
    const fits = {EDT:fitRT(dec, fs, 'EDT'), T10:fitRT(dec, fs, 'T10'), T20:fitRT(dec, fs, 'T20'), T30:fitRT(dec, fs, 'T30')};
    let rep = fits.T30; let tag='T30';
    if(!isFinite(rep.T)) { rep=fits.T20; tag='T20'; }
    if(!isFinite(rep.T)) { rep=fits.T10; tag='T10'; }
    if(!isFinite(rep.T)) { rep=fits.EDT; tag='EDT'; }
    return {fits, rep, tag};
  }

  async function analyze(){
    if(!userConfirmed){ initConsent(); if(!userConfirmed) return; }
    if(!lastBuffer){ setState('no audio'); return; }
    const fs = lastBuffer.fs, x = lastBuffer.data;

    // 固定値：トリガー閾値
    const trigDb = -20;
    const clap = detectClapStart(x, fs, trigDb);
    if(clap.idx<0){ setState(`clap not detected (peak ${clap.peakDb.toFixed(1)} dBFS < ${trigDb} dBFS)`); return; }

    const preN  = Math.max(1, Math.floor(0.5*fs));
    const postN = Math.max(1, Math.floor(0.2*fs));
    const preStart  = Math.max(0, clap.idx - preN);
    const postStart = clap.idx;

    // 切り出し開始を「preStart」に変更し、長さ1秒に固定
    const xcut = sliceForAnalysis(x, fs, preStart);

    const bandType = $('#bandType').value;
    const bands = makeBands(bandType);

    const results=[];
    const include63 = $('#snrInclude63').checked;
    const noiseComp = $('#noiseComp').checked;

    let pbg=0, psig=0;
    for(let i=0;i<preN;i++){ const v=x[preStart+i]||0; pbg += v*v; }
    for(let i=0;i<postN;i++){ const v=x[postStart+i]||0; psig += v*v; }
    pbg/=preN; psig/=postN;

    for(const fc of bands){
      const y = await bandpassFilter(x, fs, fc, bandType);
      let pbg_b=0, psig_b=0;
      for(let i=0;i<preN;i++){ const v=y[preStart+i]||0; pbg_b += v*v; }
      for(let i=0;i<postN;i++){ const v=y[postStart+i]||0; psig_b += v*v; }
      pbg_b/=preN; psig_b/=postN;
      const SNR = db10(psig_b/(pbg_b||1e-24));

      const ycut = await bandpassFilter(xcut, fs, fc, bandType);
      let dec;
      if(noiseComp) dec = schroederDBNoiseComp(ycut, pbg_b);
      else{
        dec = schroederDB(ycut);
        const shift = dec[0]; for(let i=0;i<dec.length;i++) dec[i] = dec[i]-shift;
      }

      const {fits, rep, tag} = fitAll(dec, fs);

      results.push({
        fc,
        EDT: fits.EDT.T, T10:fits.T10.T, T20:fits.T20.T, T30:fits.T30.T,
        R2: isFinite(rep.r2)?rep.r2.toFixed(3):'',
        repTag: tag,
        SNR,
        judge: (fc===63 && !include63)? '—' : (SNR >= 20.0 ? 'OK':'NG'),
        decay: dec, fit: rep, fits
      });
    }

    // テーブル描画
    const tbody = $('#results tbody'); tbody.innerHTML='';
    for(const r of results){
      // 既存の信頼性マーク（※）：短RTで不一致>=0.3s
      let markT10='', markT20='', markT30='';
      const rt10=r.fits.T10.T, rt20=r.fits.T20.T, rt30=r.fits.T30.T;
      const rtsFinite = [rt10, rt20, rt30].filter(isFinite);
      if (rtsFinite.length >= 2 && rtsFinite.every(t => t <= 1.0)) {
        const maxDiff = Math.max(...rtsFinite) - Math.min(...rtsFinite);
        if (maxDiff >= 0.3) {
          if(isFinite(rt10)) markT10 += '※';
          if(isFinite(rt20)) markT20 += '※';
          if(isFinite(rt30)) markT30 += '※';
        }
      }
      // 強化エラーマーク（!!）
      // 条件1：相対差 >= 0.1 * Tmin
      if (rtsFinite.length >= 2){
        const tmin = Math.min(...rtsFinite);
        const tmax = Math.max(...rtsFinite);
        if (tmax - tmin >= 0.1 * tmin){
          if(isFinite(rt10)) markT10 += '!!';
          if(isFinite(rt20)) markT20 += '!!';
          if(isFinite(rt30)) markT30 += '!!';
        }
      }
      // 条件2：T10またはT20が10秒以上
      if (isFinite(rt10) && rt10 >= 10) markT10 += '!!';
      if (isFinite(rt20) && rt20 >= 10) markT20 += '!!';

      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>${r.fc.toFixed(1)}</td>
        <td>${isFinite(r.EDT)?r.EDT.toFixed(3):''}</td>
        <td>${isFinite(r.T10)?r.T10.toFixed(3)+markT10:''}</td>
        <td>${isFinite(r.T20)?r.T20.toFixed(3)+markT20:''}</td>
        <td>${isFinite(r.T30)?r.T30.toFixed(3)+markT30:''}</td>
        <td>${r.R2}</td>
        <td>${r.SNR.toFixed(1)}</td>
        <td>${r.judge}</td>
        <td class="decay-plot-cell" id="plot-${r.fc}"></td>`;
      tbody.appendChild(tr);

      // 各行のインラインプロット（区間色分け）
      const plotDiv = tr.querySelector(`#plot-${r.fc}`);
      if (plotDiv) drawInlineDecay(plotDiv, r.decay, r.fits, r.fit);
    }

    // Overall判定
    const th = 20.0;
    const valid = results.filter(r => (r.fc!==63 || $('#snrInclude63').checked));
    const okList = valid.filter(r => r.SNR>=th);
    const overall = (okList.length >= Math.ceil(valid.length*0.6)) ? 'OK' : 'NG';
    $('#overallJudge').className = 'judge ' + (overall==='OK'?'ok':'ng');
    $('#overallJudge').textContent = overall;
    $('#overallNote').textContent = `OK数 ${okList.length}/${valid.length}`;

    // 元信号プロット：preStart から preStart + xcut.length を表示（暗騒音を含む）
    const markers = [
      {idx:0, color:'#999'},
      {idx:clap.idx, color:'#ef4444'},
      {idx:clap.idx, idx2:clap.idx+Math.floor(0.2*fs), color:'#16a34a', band:true},
      {idx:preStart, idx2:clap.idx, color:'#0ea5e9', band:true}
    ];
    drawWave($('#wave'), x, fs, markers, preStart, preStart + xcut.length);

    // CSV
    csvBtn.disabled=false;
    csvBtn.onclick = ()=>{
      const blob = makeCSV(results);
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='revtime_results.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    setState('analyzed');
  }

  // 起動時に同意ダイアログ
  initConsent();

  recBtn.onclick = startRecording;
  stopBtn.onclick = stopRecording;
  analyzeBtn.onclick = analyze;

  fileInput.onchange = async (e)=>{
    if(!userConfirmed){ initConsent(); if(!userConfirmed) return; }
    const f=e.target.files?.[0]; if(!f) return;
    lastBuffer = await decodeBlobToMonoFloat(f);
    setState(`loaded file @ ${lastBuffer.fs} Hz`);
    analyzeBtn.disabled=false;
  };

  $('#measTarget').textContent = $('#measCount').value;
})();
</script>
</body>
</html>
