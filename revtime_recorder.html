<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hand-Clap RT (EDT/T10/T20/T30) + SNR判定 v2.2</title>
  <style>
    :root{
      --bg:#f7f8fb; --card:#ffffff; --ink:#0f172a; --muted:#64748b;
      --accent:#2563eb; --ok:#16a34a; --warn:#eab308; --err:#dc2626;
      --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    }
    *{box-sizing:border-box}
    body{ margin:0; color:var(--ink); background:var(--bg);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", "Yu Gothic", "ヒラギノ角ゴ ProN W3", "メイリオ", sans-serif; line-height:1.55; }
    header{ position:sticky; top:0; z-index:10; background:linear-gradient(90deg,#fff,#f5f9ff); border-bottom:1px solid #e2e8f0; }
    .wrap{ max-width:1200px; margin:0 auto; padding:16px; }
    h1{ font-size:clamp(20px,2.4vw,28px); margin:0 0 6px; }
    .sub{ color:var(--muted); font-size:14px; }
    main{ max-width:1200px; margin:18px auto; padding:0 16px 40px; }
    .grid{ display:grid; gap:16px; grid-template-columns: repeat(12, 1fr); }
    .card{ background:var(--card); border:1px solid #e5e7eb; border-radius:18px; padding:16px; box-shadow: 0 6px 24px rgba(30,41,59,0.06); }
    .card h2{ margin:0 0 10px; font-size:18px }
    .controls{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    button{ appearance:none; border:0; border-radius:14px; padding:10px 14px; font-weight:600; cursor:pointer; background:var(--accent); color:white; box-shadow: 0 6px 16px rgba(37,99,235,0.2); }
    button.secondary{ background:#e2e8f0; color:#0f172a; }
    button.ghost{ background:transparent; color:var(--accent); border:1px solid #c7d2fe}
    button:disabled{ opacity:.6; cursor:not-allowed }
    .danger{ background:#dc2626 !important; }
    label{ font-size:14px; color:var(--muted) }
    select, input[type="number"]{
      border:1px solid #e5e7eb; background:white; color:#0f172a; border-radius:12px; padding:8px 10px; min-width:100px;
    }
    .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-weight:700; font-size:12px }
    .hint{ font-size:12px; color:var(--muted) }
    .ok{ color:var(--ok) } .warn{ color:var(--warn) } .err{ color:var(--err) }
    table{ width:100%; border-collapse:collapse; }
    th, td{ padding:8px 10px; border-bottom:1px solid #e5e7eb; text-align:right; font-variant-numeric: tabular-nums; }
    th:first-child, td:first-child{ text-align:left }
    .muted{ color: var(--muted); }
    .footer-note{ font-size:12px; color:var(--muted); margin-top:8px }
    canvas{ width:100%; height:260px; background:#fff; border-radius:12px; border:1px solid #e5e7eb }
    .mono{ font-family: var(--mono); }
    .judge{ font-weight:800; padding:4px 10px; border-radius:999px; display:inline-block; }
    .judge.ok{ background: #ecfdf5; color: #065f46; border:1px solid #34d399; }
    .judge.ng{ background: #fef2f2; color: #991b1b; border:1px solid #fca5a5; }
    @media (max-width:920px){ .grid{ grid-template-columns: repeat(6,1fr); } }
    @media (max-width:640px){ .grid{ grid-template-columns: repeat(4,1fr); } .controls{ gap:8px } }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>手をたたいて残響時間を推定（コンセプト）</h1>
    <div class="sub">録音 → 1/1オクターブBPF（含む63 Hz）→ シュレーダー積分 → 直線回帰（EDT/T10/T20/T30）／ 事前暗騒音と比較したSNRでOK/NG</div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card" style="grid-column: span 12;">
      <h2>1) 測定と入力</h2>
      <div class="controls">
        <button id="btnRecord"><span id="recLabel">録音開始</span></button>
        <button id="btnStop" class="secondary" disabled>停止</button>
        <label>録音長（秒）<input type="number" id="recSec" value="5" step="1" min="3" max="20" /></label>

        <label>測定点数
          <select id="measCount">
            <option value="1" selected>1</option>
            <option value="3">3</option>
            <option value="5">5</option>
          </select>
        </label>
        <label>トリガー閾値[dBFS]
          <input type="number" id="trigDb" value="-20" step="1" min="-60" max="-1" />
        </label>

        <button id="btnAnalyze" class="ghost" disabled>解析する</button>
        <button id="btnCommit" class="ghost" disabled>この測定を保存</button>
        <button id="btnAvg" class="ghost" disabled>平均を計算</button>

        <input type="file" id="fileInput" accept="audio/*" />
        <span id="state" class="pill">idle</span>
      </div>
      <p class="hint">静かな部屋で、<b>ボタンを押して約1秒後に1回だけ強く手を叩いてください</b>。端末側のNR/AGCは無効化要求を出しますが、OS依存で完全には止まりません。</p>
      <audio id="player" controls style="width:100%; display:none;"></audio>
      <div id="envInfo" class="footer-note mono"></div>
      <div class="footer-note">デバイス処理要求: echoCancellation=false / noiseSuppression=false / autoGainControl=false（適用可否は端末次第）</div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>2) 解析・判定設定</h2>
      <div class="controls">
        <label>帯域
          <select id="bandType">
            <option value="ob_63_4k" selected>1/1 Octave（63 Hz ～ 4 kHz）</option>
            <option value="ob_31_4k">1/1 Octave（31.5 Hz ～ 4 kHz）</option>
            <option value="ob_125_4k">1/1 Octave（125 Hz ～ 4 kHz）</option>
          </select>
        </label>
        <label>BPF段数（Biquad×）
          <select id="bpOrder">
            <option value="1">1（軽量）</option>
            <option value="2" selected>2（推奨）</option>
            <option value="3">3（重い）</option>
          </select>
        </label>
        <label>回帰区間
          <select id="rtMode">
            <option value="ALL" selected>EDT/T10/T20/T30 すべて</option>
            <option value="EDT">EDTのみ</option>
            <option value="T10">T10のみ</option>
            <option value="T20">T20のみ</option>
            <option value="T30">T30のみ</option>
          </select>
        </label>
        <label>OK判定SNRしきい値[dB]
          <select id="snrTh">
            <option value="10">10</option>
            <option value="20" selected>20</option>
            <option value="30">30</option>
          </select>
        </label>
        <label><input type="checkbox" id="snrInclude63" checked/> 判定に63 Hzも含める</label>
        <label><input type="checkbox" id="noiseComp" checked/> BGノイズ補正（シュレーダー積分時に暗騒音電力を減算）</label>
        <button id="btnDownloadCsv" class="ghost" disabled>CSVを保存</button>
      </div>
      <p class="hint">SNRは<b>手拍子直後200 ms</b>の平均パワーと<b>手拍子前0.5 s</b>の平均パワーの比（10log10）。中央値SNRがしきい値以上なら<b>OK</b>。</p>
      <div>全体判定：<span id="overallJudge" class="judge ng">NG</span> <span id="overallNote" class="mono" style="margin-left:8px;"></span></div>
      <div class="footer-note">測定保存数: <span id="measSaved" class="mono">0</span> / <span id="measTarget" class="mono">1</span></div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>3) 結果（帯域別）</h2>
      <div id="resultsWrap">
        <table id="results">
          <thead>
            <tr>
              <th>中心周波数 [Hz]</th>
              <th>EDT [s]</th>
              <th>T10 [s]</th>
              <th>T20 [s]</th>
              <th>T30 [s]</th>
              <th>R²（代表回帰）</th>
              <th>SNR [dB]</th>
              <th>判定</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="footer-note">代表回帰＝T30優先→T20→T10→EDT。回帰直線ラベルに<b>EDT/T10/T20/T30</b>を明示。</div>
      </div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>4) 参考プロット（代表帯域）</h2>
      <label>表示帯域 <select id="plotBand"></select></label>
      <canvas id="plot"></canvas>
      <div class="footer-note">曲線＝シュレーダー（相対dB）。灰色が回帰区間、点線が回帰直線。</div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>5) 元信号の切り取り位置</h2>
      <canvas id="wave" style="height:150px"></canvas>
      <div class="footer-note">原波形。赤＝手拍子検出点、青帯＝事前暗騒音窓、緑帯＝直後200 ms窓、灰帯＝解析用に切り出した範囲。</div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>注意・限界</h2>
      <ul>
        <li>スマホ内蔵マイクは低域（～100 Hz）で感度が低いことが多く、<b>63 Hz</b>はSNR不足になりがちです。</li>
        <li>getUserMediaでechoCancellation/noiseSuppression/autoGainControlを<b>false</b>指定し、可能ならトラックにもapplyConstraintsします。iOS Safari等では完全に無効化できない場合があります。</li>
        <li>厳密測定には標準化手順・信号の使用を推奨。本ツールは簡易推定・事前チェック用です。</li>
      </ul>
    </section>
  </div>
</main>

<script>
(() => {
  const $ = (s)=>document.querySelector(s);
  const $$ = (s)=>Array.from(document.querySelectorAll(s));
  const db10 = (x)=>10*Math.log10(x);
  const db20 = (x)=>20*Math.log10(Math.max(1e-12, Math.abs(x)));
  function linreg(x, y){
    const n = x.length; if(n<2) return {a:NaN,b:NaN,r2:NaN};
    let sx=0, sy=0, sxy=0, sxx=0, syy=0;
    for(let i=0;i<n;i++){ const xi=x[i], yi=y[i]; sx+=xi; sy+=yi; sxy+=xi*yi; sxx+=xi*xi; syy+=yi*yi; }
    const denom = n*sxx - sx*sx; if(Math.abs(denom)<1e-12) return {a:NaN,b:NaN,r2:NaN};
    const a = (n*sxy - sx*sy)/denom; const b=(sy - a*sx)/n;
    const ym = sy/n; let ssT=0, ssR=0;
    for(let i=0;i<n;i++){ const yi=y[i], yh=a*x[i]+b; ssT+=(yi-ym)**2; ssR+=(yi-yh)**2; }
    const r2 = ssT>0? 1-ssR/ssT : NaN;
    return {a,b,r2};
  }
  function makeBands(kind){
    if(kind==='ob_31_4k') return [31.5, 63,125,250,500,1000,2000,4000];
    if(kind==='ob_125_4k') return [125,250,500,1000,2000,4000];
    return [63,125,250,500,1000,2000,4000]; // default
  }
  function calcQ(fc){ const f1=fc/Math.SQRT2, f2=fc*Math.SQRT2; return fc/(f2-f1); }
  function detectClapStart(samples, fs, trigDb){
    let maxAbs=0, maxIdx=0;
    for(let i=0;i<samples.length;i++){ const a=Math.abs(samples[i]); if(a>maxAbs){ maxAbs=a; maxIdx=i; } }
    const peakDb = db20(maxAbs); // dBFS
    if(peakDb < trigDb){ return {idx:-1, peakDb}; }
    const pre = Math.floor(0.01*fs);
    return {idx: Math.max(0, maxIdx-pre), peakDb};
  }
  function sliceForAnalysis(samples, fs, startIdx){
    const maxDur=3.5;
    const N = Math.min(samples.length-startIdx, Math.floor(maxDur*fs));
    const out = new Float32Array(N);
    let mean=0; for(let i=0;i<N;i++) mean += samples[startIdx+i]; mean/=N;
    for(let i=0;i<N;i++) out[i] = samples[startIdx+i]-mean;
    return out;
  }
  function schroederDB(x){
    const N=x.length; const e=new Float64Array(N);
    for(let i=0;i<N;i++){ const v=x[i]; e[i]=v*v; }
    for(let i=N-2;i>=0;i--) e[i]+=e[i+1];
    const e0=e[0] + 1e-12;
    const out=new Float32Array(N);
    for(let i=0;i<N;i++){ const r=Math.max(e[i]/e0,1e-12); out[i]=10*Math.log10(r); }
    return out;
  }
  function schroederDBNoiseComp(x, pbg){
    const N=x.length; const e=new Float64Array(N);
    let s=0;
    for(let i=N-1;i>=0;i--){
      const vi=x[i]; const pi=vi*vi - pbg;
      s += Math.max(0, pi);
      e[i]=s;
    }
    const e0 = e[0] + 1e-12;
    const out=new Float32Array(N);
    for(let i=0;i<N;i++){ const r=Math.max(e[i]/e0,1e-12); out[i]=10*Math.log10(r); }
    return out;
  }
  function pickSegment(dBcurve, mode){
    let hi, lo;
    if(mode==='EDT'){ hi=0; lo=-10; }
    else if(mode==='T10'){ hi=-5; lo=-15; }
    else if(mode==='T20'){ hi=-5; lo=-25; }
    else if(mode==='T30'){ hi=-5; lo=-35; }
    else { hi=0; lo=-10; }
    const N=dBcurve.length; let i0=-1, i1=-1;
    for(let i=0;i<N;i++){ if(dBcurve[i]<hi){ i0=i; break; } }
    if(i0<0) return null;
    for(let i=i0;i<N;i++){ if(dBcurve[i]<lo){ i1=i; break; } }
    if(i1<0 || i1-i0<100) return null;
    return [i0,i1];
  }
  function fitRT(dBcurve, fs, mode){
    const seg = pickSegment(dBcurve, mode);
    if(!seg) return {T:NaN,a:NaN,b:NaN,r2:NaN,seg:null, used:null};
    const [i0,i1]=seg; const n=i1-i0;
    const x=new Float64Array(n), y=new Float64Array(n);
    for(let k=0;k<n;k++){ x[k]=i0+k; y[k]=dBcurve[i0+k]; }
    const {a,b,r2}=linreg(x,y);
    if(!isFinite(a) || Math.abs(a)<1e-12) return {T:NaN,a,b,r2,seg, used:mode};
    const T60 = -60/(a*fs);
    if(T60<=0 || T60>20) return {T:NaN,a,b,r2,seg, used:mode};
    return {T:T60,a,b,r2,seg, used:mode};
  }
  async function bandpassFilter(samples, fs, fc, stages=2){
    const N=samples.length;
    const offline = new OfflineAudioContext(1, N, fs);
    const buf = offline.createBuffer(1, N, fs);
    buf.copyToChannel(samples,0);
    const src = offline.createBufferSource(); src.buffer = buf;
    let node = src; const Q=calcQ(fc);
    for(let k=0;k<stages;k++){ const bp=offline.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=fc; bp.Q.value=Q; node.connect(bp); node=bp; }
    node.connect(offline.destination); src.start(); const rendered = await offline.startRendering();
    return rendered.getChannelData(0);
  }
  function computeBandSNR(bp, fs, startIdx){
    const preDur = 0.5, guard = 0.05, postDur = 0.2;
    const pre0 = Math.max(0, startIdx - Math.floor((preDur+guard)*fs));
    const pre1 = Math.max(0, startIdx - Math.floor(guard*fs));
    const post0 = startIdx;
    const post1 = Math.min(bp.length, startIdx + Math.floor(postDur*fs));
    const validPre = pre1 - pre0;
    const validPost = post1 - post0;
    if(validPre < 0.25*fs || validPost < 0.05*fs) return {snr: NaN, bg: NaN, cl: NaN, pbg: NaN, pre0, pre1, post0, post1};
    let pbg=0, pcl=0;
    for(let i=pre0;i<pre1;i++){ const v=bp[i]; pbg += v*v; }
    for(let i=post0;i<post1;i++){ const v=bp[i]; pcl += v*v; }
    pbg /= Math.max(1, validPre); pcl /= Math.max(1, validPost);
    const snr = 10 * Math.log10((pcl+1e-18) / (pbg+1e-18));
    return {snr, bg: Math.sqrt(pbg), cl: Math.sqrt(pcl), pbg, pre0, pre1, post0, post1};
  }

  // ===== App State/Elements =====
  const stateEl = $('#state'), envInfo = $('#envInfo'), player = $('#player');
  const btnRecord=$('#btnRecord'), btnStop=$('#btnStop'), btnAnalyze=$('#btnAnalyze'), btnCsv=$('#btnDownloadCsv');
  const btnCommit=$('#btnCommit'), btnAvg=$('#btnAvg');
  const bandType=$('#bandType'), bpOrder=$('#bpOrder'), rtMode=$('#rtMode'), snrThSel=$('#snrTh'), snrInclude63=$('#snrInclude63'), noiseComp=$('#noiseComp');
  const recSec=$('#recSec'), fileInput=$('#fileInput'), plotCanvas=$('#plot'), plotBandSel=$('#plotBand');
  const waveCanvas=$('#wave');
  const overallJudge=$('#overallJudge'), overallNote=$('#overallNote');
  const measCountSel=$('#measCount'), measSavedEl=$('#measSaved'), measTargetEl=$('#measTarget');
  const trigDbEl=$('#trigDb');

  let mediaRecorder=null, chunks=[], stream=null, recordedBlob=null, decoded=null;
  let lastAnalysis=null, plotCache={};
  let measurements=[];
  measTargetEl.textContent = measCountSel.value;

  function setState(t){ stateEl.textContent=t; }
  function updateEnvInfo(extra=""){
    const hasMR=!!window.MediaRecorder; const ua=navigator.userAgent;
    envInfo.textContent = `MediaRecorder: ${hasMR?'✓':'×'} | UA: ${ua} ${extra? '| '+extra:''}`;
  }
  function pickMimeType(){
    const prefs=['audio/webm;codecs=opus','audio/webm','audio/mp4;codecs=aac','audio/mp4','audio/ogg'];
    for(const t of prefs){ if(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t; }
    return '';
  }
  async function startRecording(){
    try{
      updateEnvInfo();
      stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false, noiseSuppression:false, autoGainControl:false, channelCount:1}});
      const track = stream.getAudioTracks()[0];
      try{ await track.applyConstraints({echoCancellation:false, noiseSuppression:false, autoGainControl:false}); }catch(_){}
      const mimeType = pickMimeType();
      mediaRecorder = new MediaRecorder(stream, mimeType? {mimeType}: {});
      chunks=[];
      mediaRecorder.ondataavailable = (e)=>{ if(e.data && e.data.size>0) chunks.push(e.data); };
      mediaRecorder.onstop = () => {
        recordedBlob = new Blob(chunks, {type: mimeType || 'audio/webm'});
        btnAnalyze.disabled = false;
        player.src = URL.createObjectURL(recordedBlob); player.style.display='block';
        setState('recorded');
        btnRecord.classList.remove('danger');
      };
      mediaRecorder.start(); setState('recording'); btnRecord.classList.add('danger');
      const s = Math.max(3, Math.min(20, Number(recSec.value)||5));
      setTimeout(()=>{ if(mediaRecorder && mediaRecorder.state==='recording'){ mediaRecorder.stop(); stopStream(); } }, s*1000);
    }catch(err){ console.error(err); setState('error'); alert('マイクアクセスに失敗: '+err.message); btnRecord.classList.remove('danger'); }
  }
  function stopStream(){ if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; } }
  async function stopRecordingManual(){ try{ if(mediaRecorder && mediaRecorder.state==='recording'){ mediaRecorder.stop(); } stopStream(); setState('stopped'); btnRecord.classList.remove('danger'); }catch(_){ } }
  async function decodeBlobToPCM(blob){
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    const arr = await blob.arrayBuffer();
    const audioBuf = await ac.decodeAudioData(arr);
    const fs = audioBuf.sampleRate; const N = audioBuf.length; const ch0 = audioBuf.getChannelData(0);
    const data = new Float32Array(N); data.set(ch0); ac.close();
    return {fs, data, length:N};
  }
  function renderResultsTable(rows){
    const tbody = $('#results tbody'); tbody.innerHTML='';
    rows.forEach(r=>{
      const tr=document.createElement('tr');
      function td(v, cls){ const e=document.createElement('td'); e.textContent=v; if(cls) e.className=cls; return e; }
      tr.appendChild(td(r.fc.toFixed(1)));
      tr.appendChild(td(isFinite(r.EDT)? r.EDT.toFixed(3):'—', isFinite(r.EDT)?'':'muted'));
      tr.appendChild(td(isFinite(r.T10)? r.T10.toFixed(3):'—', isFinite(r.T10)?'':'muted'));
      tr.appendChild(td(isFinite(r.T20)? r.T20.toFixed(3):'—', isFinite(r.T20)?'':'muted'));
      tr.appendChild(td(isFinite(r.T30)? r.T30.toFixed(3):'—', isFinite(r.T30)?'':'muted'));
      tr.appendChild(td(isFinite(r.R2)? r.R2.toFixed(3):'—', isFinite(r.R2)?'':'muted'));
      tr.appendChild(td(isFinite(r.SNR)? r.SNR.toFixed(1):'—', isFinite(r.SNR)?'':'muted'));
      tr.appendChild(td(r.pass? 'OK':'NG', r.pass? 'ok':'err'));
      tbody.appendChild(tr);
    });
  }
  function exportCSV(rows, filename='revtime_results_v2.csv'){
    const header=['fc_Hz','EDT_s','T10_s','T20_s','T30_s','R2_repr','SNR_dB','PASS'];
    const lines=[header.join(',')];
    rows.forEach(r=>{ lines.push([r.fc, r.EDT, r.T10, r.T20, r.T30, r.R2, r.SNR, r.pass?1:0].map(v=>isFinite(v)?v:'').join(',')); });
    const blob = new Blob([lines.join('\n')], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=filename;
    document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(url),1000);
  }
  function drawPlot(curve, fs, seg, fit, label){
    const cv=plotCanvas, ctx=cv.getContext('2d'); const W=cv.width, H=cv.height;
    ctx.clearRect(0,0,W,H);
    const padL=40, padR=10, padT=10, padB=24; const plotW=W-padL-padR, plotH=H-padT-padB;
    const tMax=Math.min(2.5, curve.length/fs); const xToPx=(t)=>padL + (t/tMax)*plotW;
    const yMin=-45, yMax=0, yToPx=(d)=> padT + (yMax-d)/(yMax-yMin)*plotH;
    ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=1;
    for(let d=0; d>=-45; d-=5){ const y=yToPx(d); ctx.beginPath(); ctx.moveTo(padL,y); ctx.lineTo(W-padR,y); ctx.stroke(); ctx.fillStyle='#94a3b8'; ctx.font='12px system-ui'; ctx.fillText(`${d}`,6,y+3); }
    for(let t=0; t<=tMax; t+=0.5){ const x=xToPx(t); ctx.beginPath(); ctx.moveTo(x,padT); ctx.lineTo(x,H-padB); ctx.stroke(); ctx.fillStyle='#94a3b8'; ctx.font='12px system-ui'; ctx.fillText(`${t.toFixed(1)}`, x-6, H-6); }
    ctx.strokeStyle='#111827'; ctx.lineWidth=1.6; ctx.beginPath();
    const N=Math.min(curve.length, Math.floor(tMax*fs));
    for(let i=0;i<N;i++){ const x=xToPx(i/fs); const y=yToPx(curve[i]); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.stroke();
    if(seg){ ctx.fillStyle='rgba(148,163,184,0.18)'; const x0=xToPx(seg[0]/fs), x1=xToPx(seg[1]/fs); ctx.fillRect(x0,padT,x1-x0,plotH); }
    if(fit && isFinite(fit.a)){ ctx.strokeStyle='#2563eb'; ctx.lineWidth=2; ctx.setLineDash([4,4]); ctx.beginPath();
      const i0=seg?seg[0]:0, i1=seg?seg[1]:N; const y0=fit.a*i0+fit.b, y1=fit.a*i1+fit.b;
      ctx.moveTo(xToPx(i0/fs), yToPx(y0)); ctx.lineTo(xToPx(i1/fs), yToPx(y1)); ctx.stroke(); ctx.setLineDash([]);
      ctx.fillStyle='#1f2937'; ctx.font='12px system-ui'; ctx.fillText(`${label}`, padL+8, padT+16);
    }
  }
  function drawWave(wave, fs, startIdx, sliceN, pre0, pre1, post0, post1){
    const cv=waveCanvas, ctx=cv.getContext('2d'); const W=cv.width, H=cv.height;
    ctx.clearRect(0,0,W,H);
    const pad=10; const plotW=W-2*pad, plotH=H-2*pad;
    const N=wave.length;
    let amax=1e-9; for(let i=0;i<N;i++){ const a=Math.abs(wave[i]); if(a>amax) amax=a; }
    const xToPx=(i)=> pad + (i/N)*plotW;
    const yToPx=(v)=> pad + (0.5 - v/(2*amax))*plotH;
    ctx.fillStyle='rgba(59,130,246,0.15)'; if(pre1>pre0) ctx.fillRect(xToPx(pre0), pad, xToPx(pre1)-xToPx(pre0), plotH);
    ctx.fillStyle='rgba(16,185,129,0.15)'; if(post1>post0) ctx.fillRect(xToPx(post0), pad, xToPx(post1)-xToPx(post0), plotH);
    ctx.fillStyle='rgba(148,163,184,0.18)'; if(sliceN>0) ctx.fillRect(xToPx(startIdx), pad, xToPx(startIdx+sliceN)-xToPx(startIdx), plotH);
    ctx.strokeStyle='#111827'; ctx.lineWidth=1; ctx.beginPath();
    for(let i=0;i<N;i++){ const x=xToPx(i); const y=yToPx(wave[i]); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); } ctx.stroke();
    ctx.strokeStyle='#dc2626'; ctx.lineWidth=2; const xt=xToPx(startIdx); ctx.beginPath(); ctx.moveTo(xt,pad); ctx.lineTo(xt,H-pad); ctx.stroke();
  }
  function populatePlotBandSelect(bands){
    plotBandSel.innerHTML=''; bands.forEach((fc, i)=>{ const opt=document.createElement('option'); opt.value=String(fc); opt.textContent=`${fc} Hz`; if(i===Math.floor(bands.length/2)) opt.selected=true; plotBandSel.appendChild(opt); });
  }

  async function analyze(){
    try{
      setState('analyzing');
      const buf = decoded; if(!buf){ alert('録音またはファイル選択を行ってください。'); setState('idle'); return; }
      const {fs, data} = buf;
      const trigDb = Number(trigDbEl.value)||-20;
      const det = detectClapStart(data, fs, trigDb);
      if(det.idx<0){ alert(`トリガー未検出: peak=${det.peakDb.toFixed(1)} dBFS < 閾値 ${trigDb} dBFS`); setState('idle'); return; }
      const startIdx = det.idx;
      const slice = sliceForAnalysis(data, fs, startIdx);
      const stages = Math.max(1, Math.min(3, Number(bpOrder.value)||2));
      const bands = makeBands(bandType.value); populatePlotBandSelect(bands);
      const want = rtMode.value; const rows=[]; plotCache={};
      const snrTH = Number(snrThSel.value)||20;
      const include63 = !!snrInclude63.checked;
      const useNoiseComp = !!noiseComp.checked;

      const snrForOverall = [];
      let lastWin = {pre0:0, pre1:0, post0:0, post1:0};

      for(const fc of bands){
        const filtered = await bandpassFilter(slice, fs, fc, stages);
        const filteredFull = await bandpassFilter(new Float32Array(data), fs, fc, stages);
        const snrPack = computeBandSNR(filteredFull, fs, startIdx);
        const SNR = snrPack.snr;
        lastWin = snrPack;

        const curve = useNoiseComp && isFinite(snrPack.pbg) ? schroederDBNoiseComp(filtered, snrPack.pbg) : schroederDB(filtered);

        let EDT=NaN, T10=NaN, T20=NaN, T30=NaN, R2=NaN; let used='—', seg=null, fit=null;
        if(want==='ALL' || want==='EDT'){ const r=fitRT(curve, fs, 'EDT'); EDT=r.T; }
        if(want==='ALL' || want==='T10'){ const r=fitRT(curve, fs, 'T10'); T10=r.T; }
        if(want==='ALL' || want==='T20'){ const r=fitRT(curve, fs, 'T20'); T20=r.T; }
        if(want==='ALL' || want==='T30'){ const r=fitRT(curve, fs, 'T30'); T30=r.T; }
        let repr=fitRT(curve, fs, 'T30'); if(!isFinite(repr.T)) repr=fitRT(curve, fs, 'T20'); if(!isFinite(repr.T)) repr=fitRT(curve, fs, 'T10'); if(!isFinite(repr.T)) repr=fitRT(curve, fs, 'EDT');
        if(isFinite(repr.r2)) R2=repr.r2;
        used = repr.used || '—'; seg=repr.seg; fit={a:repr.a,b:repr.b,r2:repr.r2, used};

        const pass = isFinite(SNR) ? (SNR >= snrTH) : false;
        const inJudge = include63 ? (fc>=63 && fc<=4000) : (fc>=125 && fc<=4000);
        if(inJudge && isFinite(SNR)) snrForOverall.push({fc, SNR});

        rows.push({fc, EDT, T10, T20, T30, R2, SNR, pass});
        plotCache[fc] = { curve, fs, seg, fit };
      }

      renderResultsTable(rows);
      lastAnalysis = {rows, fs, data, startIdx, sliceN: slice.length, lastWin};
      btnCsv.disabled = false; btnCommit.disabled = false;

      const snrVals = snrForOverall.map(o=>o.SNR).sort((a,b)=>a-b);
      let med = NaN;
      if(snrVals.length>0){ const m=Math.floor(snrVals.length/2); med = (snrVals.length%2? snrVals[m] : (snrVals[m-1]+snrVals[m])/2); }
      const overallOK = isFinite(med) && med >= (Number(snrThSel.value)||20);
      overallJudge.textContent = overallOK ? 'OK' : 'NG';
      overallJudge.className = 'judge ' + (overallOK ? 'ok' : 'ng');
      overallNote.textContent = snrVals.length ? `中央値SNR=${med.toFixed(1)} dB（判定帯域: ${snrInclude63.checked? '63–4k': '125–4k'}）` : 'SNRを評価できません（前静音不足または解析失敗）';

      const fcShow = Number(plotBandSel.value) || bands[Math.floor(bands.length/2)];
      const pc = plotCache[fcShow] || plotCache[bands[Math.floor(bands.length/2)]];
      if(pc) drawPlot(pc.curve, pc.fs, pc.seg, pc.fit, `${fcShow||'代表'} Hz｜代表回帰=${pc.fit.used}｜R²=${(pc.fit.r2||0).toFixed(3)}｜T60=${(isFinite(-60/(pc.fit.a*pc.fs))?(-60/(pc.fit.a*pc.fs)).toFixed(2):'—')} s`);

      if(lastAnalysis){
        const {data, startIdx, sliceN, lastWin} = lastAnalysis;
        drawWave(data, fs, startIdx, sliceN, lastWin.pre0, lastWin.pre1, lastWin.post0, lastWin.post1);
      }

      setState('done');
    }catch(err){ console.error(err); setState('error'); alert('解析失敗: '+err.message); }
  }

  function averageMeasurements(){
    if(measurements.length===0){ alert('保存済み測定がありません。'); return; }
    const rows0 = measurements[0].rows;
    const byFc = new Map();
    rows0.forEach(r=>byFc.set(r.fc, {EDT:[],T10:[],T20:[],T30:[],R2:[],SNR:[]}));
    for(const m of measurements){
      for(const r of m.rows){
        const acc = byFc.get(r.fc); if(!acc) continue;
        if(isFinite(r.EDT)) acc.EDT.push(r.EDT);
        if(isFinite(r.T10)) acc.T10.push(r.T10);
        if(isFinite(r.T20)) acc.T20.push(r.T20);
        if(isFinite(r.T30)) acc.T30.push(r.T30);
        if(isFinite(r.R2)) acc.R2.push(r.R2);
        if(isFinite(r.SNR)) acc.SNR.push(r.SNR);
      }
    }
    function mean(a){ return a.length? a.reduce((p,c)=>p+c,0)/a.length : NaN; }
    function median(a){ if(!a.length) return NaN; const b=[...a].sort((x,y)=>x-y); const m=Math.floor(b.length/2); return b.length%2? b[m] : (b[m-1]+b[m])/2; }
    const snrTH = Number(snrThSel.value)||20;
    const out=[];
    for(const [fc, acc] of byFc.entries()){
      const r={
        fc,
        EDT: mean(acc.EDT),
        T10: mean(acc.T10),
        T20: mean(acc.T20),
        T30: mean(acc.T30),
        R2: mean(acc.R2),
        SNR: median(acc.SNR)
      };
      r.pass = isFinite(r.SNR) ? (r.SNR >= snrTH) : false;
      out.push(r);
    }
    out.sort((a,b)=>a.fc-b.fc);
    renderResultsTable(out);
    btnCsv.onclick = ()=> exportCSV(out, 'revtime_results_avg.csv');
  }

  const recLabel = $('#recLabel');
  btnRecord.addEventListener('click', async ()=>{
    btnRecord.disabled=true; btnStop.disabled=true; btnAnalyze.disabled=true; recLabel.textContent='録音中…';
    await startRecording(); btnRecord.disabled=false; btnStop.disabled=true; recLabel.textContent='録音開始';
  });
  btnStop.addEventListener('click', stopRecordingManual);
  btnAnalyze.addEventListener('click', async ()=>{
    if(recordedBlob){ decoded = await decodeBlobToPCM(recordedBlob); updateEnvInfo(`decoded fs=${decoded.fs}Hz, N=${decoded.length}`); await analyze(); }
    else alert('録音データがありません。');
  });
  fileInput.addEventListener('change', async (e)=>{
    const f=e.target.files?.[0]; if(!f) return; recordedBlob=f;
    decoded = await decodeBlobToPCM(f); player.src = URL.createObjectURL(f); player.style.display='block'; btnAnalyze.disabled=false;
    setState('file selected'); updateEnvInfo(`decoded fs=${decoded.fs}Hz, N=${decoded.length}`);
  });
  plotBandSel.addEventListener('change', ()=>{
    const fc=Number(plotBandSel.value); const pc=plotCache[fc]; if(pc) drawPlot(pc.curve, pc.fs, pc.seg, pc.fit, `${fc} Hz｜代表回帰=${pc.fit.used}｜R²=${(pc.fit.r2||0).toFixed(3)}｜T60=${(isFinite(-60/(pc.fit.a*pc.fs))?(-60/(pc.fit.a*pc.fs)).toFixed(2):'—')} s`);
  });
  btnCsv.addEventListener('click', ()=>{ if(lastAnalysis) exportCSV(lastAnalysis.rows); });
  btnCommit.addEventListener('click', ()=>{
    if(!lastAnalysis){ alert('解析結果がありません。'); return; }
    measurements.push({rows:lastAnalysis.rows});
    measSavedEl.textContent = String(measurements.length);
    const target = Number(measCountSel.value)||1;
    if(measurements.length >= target){ btnAvg.disabled=false; }
  });
  btnAvg.addEventListener('click', averageMeasurements);
  measCountSel.addEventListener('change', ()=>{ measTargetEl.textContent = measCountSel.value; btnAvg.disabled=true; measurements=[]; measSavedEl.textContent='0'; });

  setState('idle'); updateEnvInfo();
})();
</script>
</body>
</html>
