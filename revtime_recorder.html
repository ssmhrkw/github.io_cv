<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hand-Clap RT (EDT/T10/T20/T30) + SNR判定 v2.7</title>

  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HFR5WYG42Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date()); gtag('config','G-HFR5WYG42Q');
  </script>
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>

  <style>
    :root{
      --bg:#f7f8fb; --card:#ffffff; --ink:#0f172a; --muted:#64748b;
      --accent:#2563eb; --ok:#16a34a; --warn:#eab308; --err:#dc2626;
      --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    }
    *{box-sizing:border-box}
    body{ margin:0; color:var(--ink); background:var(--bg);
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic","ヒラギノ角ゴ ProN W3","メイリオ",sans-serif; line-height:1.55; }
    header{ position:sticky; top:0; z-index:10; background:linear-gradient(90deg,#fff,#f5f9ff); border-bottom:1px solid #e2e8f0; }
    .wrap{ max-width:1200px; margin:0 auto; padding:16px; }
    h1{ font-size:clamp(20px,2.4vw,28px); margin:0 0 6px; }
    .sub{ color:var(--muted); font-size:14px; }
    main{ max-width:1200px; margin:18px auto; padding:0 16px 40px; }
    .grid{ display:grid; gap:16px; grid-template-columns: repeat(12, 1fr); }
    .card{ background:var(--card); border:1px solid #e5e7eb; border-radius:18px; padding:16px; box-shadow:0 6px 24px rgba(30,41,59,0.06); }
    .card h2{ margin:0 0 10px; font-size:18px }
    .controls{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    button{ appearance:none; border:0; border-radius:14px; padding:10px 14px; font-weight:600; cursor:pointer; background:var(--accent); color:white; box-shadow:0 6px 16px rgba(37,99,235,0.2); }
    button.secondary{ background:#e2e8f0; color:#0f172a; }
    button.ghost{ background:transparent; color:var(--accent); border:1px solid #c7d2fe}
    button:disabled{ opacity:.6; cursor:not-allowed }
    label{ font-size:14px; color:var(--muted) }
    select, input[type="number"], input[type="text"]{
      border:1px solid #e5e7eb; background:white; color:#0f172a; border-radius:12px; padding:8px 10px; min-width:100px;
    }
    .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-weight:700; font-size:12px }
    .hint{ font-size:12px; color:var(--muted) }
    .mono{ font-family:var(--mono); }
    .judge{ font-weight:800; padding:4px 10px; border-radius:999px; display:inline-block; }
    .judge.ok{ background:#ecfdf5; color:#065f46; border:1px solid #34d399; }
    .judge.ng{ background:#fef2f2; color:#991b1b; border:1px solid #fca5a5; }
    table{ width:100%; border-collapse:collapse; }
    th, td{ padding:8px 10px; border-bottom:1px solid #e5e7eb; text-align:right; font-variant-numeric:tabular-nums; vertical-align:middle; }
    th:first-child, td:first-child{ text-align:left }
    @media (max-width:920px){ .grid{ grid-template-columns: repeat(6,1fr); } }
    @media (max-width:640px){ .grid{ grid-template-columns: repeat(4,1fr); } .controls{ gap:8px } }
    canvas#wave{ width:100%; height:150px; background:#fff; border-radius:12px; border:1px solid #e5e7eb }

    /* 録音状態フィードバック */
    button.recording { background: var(--err); box-shadow: 0 6px 16px rgba(220,38,38,0.2); }
    button.recorded  { background: var(--muted); box-shadow: 0 6px 16px rgba(100,116,139,0.2); }

    /* 詳細プロット */
    #decay-controls{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; margin-bottom:8px; }
    #decay-controls .note{ color:#64748b; font-size:12px }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>手をたたいて残響時間を推定（コンセプト）</h1>
    <div class="sub">録音 → 1/1 または 1/3 オクターブBPF → シュレーダー積分 → 直線回帰（EDT/T10/T20/T30）／ 事前暗騒音と比較したSNRでOK/NG</div>
  </div>
</header>

<main>
  <div class="grid">
    <!-- 1) -->
    <section class="card" style="grid-column: span 12;">
      <h2>1) 測定と入力</h2>
      <div class="controls">
        <button id="btnRecord"><span id="recLabel">録音開始</span></button>
        <button id="btnStop" class="secondary" disabled>停止</button>
        <label>録音長（秒）<input type="number" id="recSec" value="5" step="1" min="3" max="20" /></label>

        <label>測定点数
          <select id="measCount">
            <option value="1" selected>1</option>
            <option value="3">3</option>
            <option value="5">5</option>
          </select>
        </label>

        <button id="btnCommit" class="ghost" disabled>この測定を保存</button>
        <button id="btnAvg" class="ghost" disabled>平均を計算</button>

        <input type="file" id="fileInput" accept="audio/*" />
        <span id="state" class="pill">idle</span>
      </div>
      <p class="hint">静かな部屋で、<b>ボタンを押して約1秒後に1回だけ強く手を叩いてください</b>。端末側のNR/AGCは無効化要求を出しますが、OS依存で完全には止まりません。</p>
      <audio id="player" controls playsinline style="width:100%; display:none;"></audio>
      <div id="envInfo" class="footer-note mono"></div>
      <div class="footer-note">デバイス処理要求: echoCancellation=false / noiseSuppression=false / autoGainControl=false（適用可否は端末次第）</div>
    </section>

    <!-- 2) -->
    <section class="card" style="grid-column: span 12;">
      <h2>2) 解析・判定設定</h2>
      <div class="controls">
        <label>帯域
          <select id="bandType">
            <option value="ob_63_4k" selected>1/1 Octave（63 Hz ～ 4 kHz）</option>
            <option value="ob_31_4k">1/1 Octave（31.5 Hz ～ 4 kHz）</option>
            <option value="ob_125_4k">1/1 Octave（125 Hz ～ 4 kHz）</option>
            <option value="tb_100_4k">1/3 Octave（100 Hz ～ 4 kHz）</option>
          </select>
        </label>
        <label><input type="checkbox" id="snrInclude63" checked/> 判定に63 Hzも含める</label>
        <label><input type="checkbox" id="noiseComp" checked/> BGノイズ補正（シュレーダー積分時に暗騒音電力を減算）</label>

        <button id="btnAnalyze" class="ghost" disabled>解析する</button>
        <button id="btnDownloadCsv" class="ghost" disabled>CSVを保存</button>
      </div>
      <p class="hint">SNRは<b>手拍子直後200 ms</b>の平均パワーと<b>手拍子前0.5 s</b>の平均パワーの比（10log10）。<span style="font-weight:700">中央値SNR</span>がしきい値以上なら<b>OK</b>。</p>
      <div>全体判定：<span id="overallJudge" class="judge ng">NG</span> <span id="overallNote" class="mono" style="margin-left:8px;"></span></div>
      <div class="footer-note">測定保存数: <span id="measSaved" class="mono">0</span> / <span id="measTarget" class="mono">1</span></div>
    </section>

    <!-- 3) -->
    <section class="card" style="grid-column: span 12;">
      <h2>3) 結果（帯域別）</h2>
      <div id="resultsWrap">
        <table id="results">
          <thead>
            <tr>
              <th>中心周波数 [Hz]</th>
              <th>EDT [s]</th>
              <th>T10 [s]</th>
              <th>T20 [s]</th>
              <th>T30 [s]</th>
              <th>R²（代表回帰）</th>
              <th>SNR [dB]</th>
              <th>判定</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="footer-note">
          代表回帰＝T30優先→T20→T10→EDT。回帰直線ラベルに<b>EDT/T10/T20/T30</b>を明示。<br>
          <b>!!</b>: 信頼性警告（例: Tの相対差が大きい、T10/T20が異常に長い10s以上）<br>
          <b>※</b>: ショートRT不一致警告（すべて1.0s以下かつ最大差0.3s以上）
        </div>
      </div>
    </section>

    <!-- 4) 新設：減衰曲線（詳細・Plotly） -->
    <section class="card" style="grid-column: span 12;">
      <h2>4) 減衰曲線（詳細）</h2>
      <div id="decay-controls">
        <label>表示帯域
          <select id="detailBand"></select>
        </label>
        <label>開始時間[s] <input type="number" id="zoomStart" value="0" step="0.05" min="0"></label>
        <label>終了時間[s] <input type="number" id="zoomEnd" value="1.0" step="0.05" min="0.1"></label>
        <button id="applyZoom" class="ghost">ズーム適用</button>
        <span class="note">曲線＝Schroeder（相対dB）。着色帯＝回帰区間。点線＝回帰直線。</span>
      </div>
      <div id="decayPlot" style="width:100%;height:420px;"></div>
    </section>

    <!-- 5) -->
    <section class="card" style="grid-column: span 12;">
      <h2>5) 元信号の切り取り位置</h2>
      <canvas id="wave"></canvas>
      <div class="footer-note">解析に用いた切り出し範囲の原波形。赤＝手拍子検出点、青帯＝事前暗騒音窓、緑帯＝直後200 ms窓。</div>
    </section>
  </div>
</main>

<script type="module">
import { designButterworthBandpassSOS_N, sosFilter } from "./acoustics-core.js";

(() => {
  const $  = (s)=>document.querySelector(s);
  const $$ = (s)=>Array.from(document.querySelectorAll(s));
  const db10 = (x)=>10*Math.log10(Math.max(1e-24, x));
  const db20 = (x)=>20*Math.log10(Math.max(1e-12, Math.abs(x)));

  const player = $('#player');
  const stateEl = $('#state');
  const recBtn = $('#btnRecord');
  const stopBtn = $('#btnStop');
  const analyzeBtn = $('#btnAnalyze');
  const csvBtn = $('#btnDownloadCsv');
  const fileInput = $('#fileInput');

  const detailBandSel = $('#detailBand');
  const applyZoomBtn  = $('#applyZoom');
  const zoomStartEl   = $('#zoomStart');
  const zoomEndEl     = $('#zoomEnd');

  let mediaStream = null;
  let recorder = null;
  let recordedChunks = [];
  let lastBuffer = null;  // {fs, data: Float32Array}
  let userConfirmed = false;

  // consent
  function initConsent(){
    const msg = [
      'このツールは簡易測定用であり、標準的な残響時間測定の要件を満たしません。',
      'スマホ内蔵マイクは低域（～100 Hz）で感度が低く、63 HzはSNR不足になりがちです。',
      'getUserMediaでechoCancellation/noiseSuppression/autoGainControlをfalse指定しますが、iOS Safari等では完全に無効化できない場合があります。',
      '厳密測定には標準化手順・信号の使用を推奨します。',
      '測定結果の正確性について保証はできません。よろしいですか？'
    ].join('\n\n');
    const ok = window.confirm(msg);
    userConfirmed = !!ok;
    if(!userConfirmed){
      recBtn.disabled = true; fileInput.disabled = true;
      analyzeBtn.disabled = true; csvBtn.disabled = true; stopBtn.disabled = true;
      stateEl.textContent = '警告確認待ち';
    }else{
      stateEl.textContent = 'idle';
    }
  }

  function makeBands(kind){
    if(kind==='ob_31_4k')  return [31.5,63,125,250,500,1000,2000,4000];
    if(kind==='ob_125_4k') return [125,250,500,1000,2000,4000];
    if(kind==='ob_63_4k')  return [63,125,250,500,1000,2000,4000];
    if(kind==='tb_100_4k') return [100,125,160,200,250,315,400,500,630,800,1000,1250,1600,2000,2500,3150,4000];
    return [63,125,250,500,1000,2000,4000];
  }

  function pickRecorderMime(){
    const cands = ['audio/mp4;codecs=aac','audio/aac','audio/mp4','audio/webm;codecs=opus','audio/webm'];
    for(const t of cands){ if(window.MediaRecorder && MediaRecorder.isTypeSupported?.(t)) return t; }
    return '';
  }

  // 1/1:36次, 1/3:24次
  async function bandpassFilter(samples, fs, fc, bandType){
    const N = bandType.includes('tb_') ? 24 : 36;
    const sos = designButterworthBandpassSOS_N(fc, fs, N);
    return sosFilter(samples, sos);
  }

  function detectClapStart(samples, fs, trigDb){
    let maxAbs=0, maxIdx=0;
    for(let i=0;i<samples.length;i++){ const a=Math.abs(samples[i]); if(a>maxAbs){ maxAbs=a; maxIdx=i; } }
    const peakDb = db20(maxAbs);
    if(peakDb < trigDb) return {idx:-1, peakDb};
    const pre = Math.floor(0.01*fs);
    return {idx: Math.max(0, maxIdx-pre), peakDb};
  }

  // 1.0 s 固定、平均値除去
  function sliceForAnalysis(samples, fs, startIdx){
    const maxDur=1.0;
    const N = Math.min(samples.length-startIdx, Math.floor(maxDur*fs));
    const out = new Float32Array(N);
    let mean=0; for(let i=0;i<N;i++) mean += samples[startIdx+i]; mean/=N;
    for(let i=0;i<N;i++) out[i] = samples[startIdx+i]-mean;
    return out;
  }

  function schroederDB(x){
    const N=x.length; const e=new Float64Array(N);
    for(let i=0;i<N;i++){ const v=x[i]; e[i]=v*v; }
    for(let i=N-2;i>=0;i--) e[i]+=e[i+1];
    const e0=e[0] + 1e-12;
    const out=new Float32Array(N);
    for(let i=0;i<N;i++){ const r=Math.max(e[i]/e0,1e-12); out[i]=10*Math.log10(r); }
    return out;
  }

  function schroederDBNoiseComp(x, pbg){
    const N = x.length;
    const e = new Float64Array(N);
    let acc = 0;
    for(let i=N-1;i>=0;i--){
      const pi = x[i]*x[i] - pbg;
      acc += (pi > 0 ? pi : 0);
      e[i] = acc;
    }
    const e0 = e[0] + 1e-12;
    const out = new Float32Array(N);
    for(let i=0;i<N;i++){
      const r = Math.max(e[i]/e0, 1e-12);
      out[i] = 10*Math.log10(r);
    }
    return out;
  }

  function pickSegment(dBcurve, mode){
    let hi, lo;
    if(mode==='EDT'){ hi=0; lo=-10; }
    else if(mode==='T10'){ hi=-5; lo=-15; }
    else if(mode==='T20'){ hi=-5; lo=-25; }
    else if(mode==='T30'){ hi=-5; lo=-35; }
    else { hi=0; lo=-10; }
    const N=dBcurve.length; let i0=-1, i1=-1;
    for(let i=0;i<N;i++){ if(dBcurve[i]<hi){ i0=i; break; } }
    if(i0<0) return null;
    for(let i=i0;i<N;i++){ if(dBcurve[i]<lo){ i1=i; break; } }
    if(i1<0 || i1-i0<100) return null;
    return [i0,i1];
  }

  function linreg(x, y){
    const n = x.length; if(n<2) return {a:NaN,b:NaN,r2:NaN};
    let sx=0, sy=0, sxy=0, sxx=0, syy=0;
    for(let i=0;i<n;i++){ const xi=x[i], yi=y[i]; sx+=xi; sy+=yi; sxy+=xi*yi; sxx+=xi*xi; syy+=yi*yi; }
    const denom = n*sxx - sx*sx; if(Math.abs(denom)<1e-12) return {a:NaN,b:NaN,r2:NaN};
    const a = (n*sxy - sx*sy)/denom; const b=(sy - a*sx)/n;
    const ym = sy/n; let ssT=0, ssR=0;
    for(let i=0;i<n;i++){ const yi=y[i], yh=a*x[i]+b; ssT+=(yi-ym)**2; ssR+=(yi-yh)**2; }
    const r2 = ssT>0? 1-ssR/ssT : NaN;
    return {a,b,r2};
  }

  function fitRT(dBcurve, fs, mode){
    const seg = pickSegment(dBcurve, mode);
    if(!seg) return {T:NaN,a:NaN,b:NaN,r2:NaN,seg:null, used:null};
    const [i0,i1]=seg; const n=i1-i0;
    const x=new Float64Array(n), y=new Float64Array(n);
    for(let k=0;k<n;k++){ x[k]=i0+k; y[k]=dBcurve[i0+k]; }
    const {a,b,r2}=linreg(x,y);
    if(!isFinite(a) || Math.abs(a)<1e-12) return {T:NaN,a,b,r2,seg, used:mode};
    const T60 = -60/(a*fs);
    if(T60<=0 || T60>20) return {T:NaN,a,b,r2,seg, used:mode};
    return {T:T60,a,b,r2,seg, used:mode};
  }

  // 元信号Zoom描画
  function drawWave(canvas, data, fs, markers, i_start = 0, i_end = -1){
    const ctx=canvas.getContext('2d'); const W=canvas.width=canvas.clientWidth, H=canvas.height=canvas.clientHeight;
    ctx.clearRect(0,0,W,H); ctx.strokeStyle='#0f172a22'; ctx.strokeRect(0,0,W,H);
    if(!data || data.length === 0) return;

    if(i_end === -1) i_end = data.length;
    i_start = Math.max(0, i_start);
    i_end = Math.min(data.length, i_end);
    const N_disp = i_end - i_start;
    if(N_disp <= 0) return;

    ctx.strokeStyle='#0f172a'; ctx.beginPath();
    for(let x=0; x<W; x++){
      const i = i_start + Math.floor(x * N_disp / W);
      const y = data[i] || 0;
      const yy = H*(0.5-0.45*y);
      if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
    }
    ctx.stroke();

    if(markers){
      for(const m of markers){
        const x = Math.floor(((m.idx - i_start) / N_disp) * W);
        ctx.strokeStyle = m.color;
        ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
        if(m.band){
          ctx.fillStyle = m.color+'33';
          const x2 = Math.floor(((m.idx2 - i_start) / N_disp) * W);
          ctx.fillRect(Math.min(x,x2), 0, Math.abs(x2-x), H);
        }
      }
    }
  }

  // ==== Plotly描画 ====
  function renderDecayPlot(containerId, r, fs, zoomStart=0, zoomEnd=1.0){
    const N  = r.decay.length;
    const t  = Array.from({length:N}, (_,i)=> i/fs);
    const y  = Array.from(r.decay);

    const shapes = [];
    const segStyle = {
      EDT : {fill:'rgba(148,163,184,0.25)', line:'rgba(148,163,184,1)'},
      T10 : {fill:'rgba(59,130,246,0.25)', line:'rgba(59,130,246,1)'},
      T20 : {fill:'rgba(34,197,94,0.25)',  line:'rgba(34,197,94,1)'},
      T30 : {fill:'rgba(245,158,11,0.25)', line:'rgba(245,158,11,1)'},
    };

    const traces = [{
      name:'Schroeder',
      x:t, y:y, mode:'lines',
      line:{width:1.5, color:'#0f172a'}
    }];

    for(const key of ['EDT','T10','T20','T30']){
      const f = r.fits[key];
      if(f && f.seg){
        const [i0,i1] = f.seg;
        const x0=t[i0], x1=t[Math.max(i1-1,i0)];
        shapes.push({
          type:'rect', xref:'x', yref:'paper',
          x0:x0, x1:x1, y0:0, y1:1,
          fillcolor: segStyle[key].fill, line:{width:0}
        });
        if(isFinite(f.a)){
          const y0 = f.a*i0 + f.b;
          const y1 = f.a*(i1-1) + f.b;
          traces.push({
            name:`${key} fit`,
            x:[x0,x1], y:[y0,y1], mode:'lines',
            line:{dash:'dot', width:2, color:segStyle[key].line}
          });
        }
      }
    }

    const layout = {
      margin:{l:60,r:20,t:10,b:40},
      xaxis:{title:'Time [s]', range:[zoomStart, zoomEnd]},
      yaxis:{title:'Level [dB]', range:[-80,0]},
      showlegend:true,
      shapes
    };
    Plotly.newPlot(containerId, traces, layout, {responsive:true, displaylogo:false});
  }

  function makeCSV(rows){
    const head=['fc_Hz','EDT_s','T10_s','T20_s','T30_s','R2','SNR_dB','Judge'];
    const lines=[head.join(',')];
    for(const r of rows){
      lines.push([r.fc.toFixed(1), ...['EDT','T10','T20','T30'].map(k=>isFinite(r[k])?r[k].toFixed(3):''), (r.R2??'').toString(), r.SNR.toFixed(1), r.judge].join(','));
    }
    return new Blob([lines.join('\n')], {type:'text/csv'});
  }

  async function decodeBlobToMonoFloat(blob){
    const ac = new (window.AudioContext || window.webkitAudioContext)({sampleRate:48000});
    const arrbuf = await blob.arrayBuffer();
    const audioBuf = await ac.decodeAudioData(arrbuf);
    const fs = audioBuf.sampleRate;
    const ch0 = audioBuf.getChannelData(0);
    const out = new Float32Array(ch0.length); out.set(ch0);
    ac.close();
    return {fs, data:out};
  }

  function enableDuringRecording(v){
    recBtn.disabled=v; stopBtn.disabled=!v; analyzeBtn.disabled=true; csvBtn.disabled=true;
  }

  function setState(s){ stateEl.textContent=s; }

  async function startRecording(){
    if(!userConfirmed){ initConsent(); if(!userConfirmed) return; }
    const recSec = Math.max(1, Math.min(20, parseInt($('#recSec').value,10) || 5));
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio:{ echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });

    const mime = pickRecorderMime();
    recorder = new MediaRecorder(mediaStream, mime ? {mimeType:mime} : undefined);
    recordedChunks = [];

    recBtn.classList.remove('recorded');
    recBtn.classList.add('recording');
    $('#recLabel').textContent = '録音中';

    recorder.ondataavailable = e=>{ if(e.data && e.data.size>0) recordedChunks.push(e.data); };
    recorder.onstop = async ()=>{
      const type = mime || recordedChunks[0]?.type || 'audio/mp4';
      const blob = new Blob(recordedChunks, {type});
      const url = URL.createObjectURL(blob);
      player.src = url; player.style.display='block'; try { await player.play(); } catch(_) {}

      lastBuffer = await decodeBlobToMonoFloat(blob);
      setState(`recorded @ ${lastBuffer.fs} Hz, ${lastBuffer.data.length} samples`);
      analyzeBtn.disabled = false;

      recBtn.classList.remove('recording');
      recBtn.classList.add('recorded');
      $('#recLabel').textContent = '録音完了';
    };
    recorder.start();
    enableDuringRecording(true); setState('recording…');
    setTimeout(()=>{
      if(recorder && recorder.state==='recording') recorder.stop();
      stopStream(); enableDuringRecording(false);
    }, recSec*1000);
  }

  function stopStream(){
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  }
  function stopRecording(){
    if(recorder && recorder.state==='recording'){ recorder.stop(); }
    stopStream(); enableDuringRecording(false); setState('stopped');
  }

  function fitAll(dec, fs){
    const fits = {EDT:fitRT(dec, fs, 'EDT'), T10:fitRT(dec, fs, 'T10'), T20:fitRT(dec, fs, 'T20'), T30:fitRT(dec, fs, 'T30')};
    let rep = fits.T30; let tag='T30';
    if(!isFinite(rep.T)) { rep=fits.T20; tag='T20'; }
    if(!isFinite(rep.T)) { rep=fits.T10; tag='T10'; }
    if(!isFinite(rep.T)) { rep=fits.EDT; tag='EDT'; }
    return {fits, rep, tag};
  }

  async function analyze(){
    if(!userConfirmed){ initConsent(); if(!userConfirmed) return; }
    if(!lastBuffer){ setState('no audio'); return; }
    const fs = lastBuffer.fs, x = lastBuffer.data;

    // 固定：トリガー閾値
    const trigDb = -20;
    const clap = detectClapStart(x, fs, trigDb);
    if(clap.idx<0){ setState(`clap not detected (peak ${clap.peakDb.toFixed(1)} dBFS < ${trigDb} dBFS)`); return; }

    const preN  = Math.max(1, Math.floor(0.5*fs));
    const postN = Math.max(1, Math.floor(0.2*fs));
    const preStart  = Math.max(0, clap.idx - preN);
    const postStart = clap.idx;

    // 切り出しは preStart から 1.0 s
    const xcut = sliceForAnalysis(x, fs, preStart);

    const bandType = $('#bandType').value;
    const bands = makeBands(bandType);

    const results=[];
    const include63 = $('#snrInclude63').checked;
    const noiseComp = $('#noiseComp').checked;

    let pbg=0, psig=0;
    for(let i=0;i<preN;i++){ const v=x[preStart+i]||0; pbg += v*v; }
    for(let i=0;i<postN;i++){ const v=x[postStart+i]||0; psig += v*v; }
    pbg/=preN; psig/=postN;

    for(const fc of bands){
      const y = await bandpassFilter(x, fs, fc, bandType);
      let pbg_b=0, psig_b=0;
      for(let i=0;i<preN;i++){ const v=y[preStart+i]||0; pbg_b += v*v; }
      for(let i=0;i<postN;i++){ const v=y[postStart+i]||0; psig_b += v*v; }
      pbg_b/=preN; psig_b/=postN;
      const SNR = db10(psig_b/(pbg_b||1e-24));

      const ycut = await bandpassFilter(xcut, fs, fc, bandType);
      let dec;
      if(noiseComp) dec = schroederDBNoiseComp(ycut, pbg_b);
      else{
        dec = schroederDB(ycut);
        const shift = dec[0]; for(let i=0;i<dec.length;i++) dec[i] = dec[i]-shift;
      }

      const {fits, rep, tag} = fitAll(dec, fs);

      results.push({
        fc,
        EDT: fits.EDT.T, T10:fits.T10.T, T20:fits.T20.T, T30:fits.T30.T,
        R2: isFinite(rep.r2)?rep.r2.toFixed(3):'',
        repTag: tag,
        SNR,
        judge: (fc===63 && !include63)? '—' : (SNR >= 20.0 ? 'OK':'NG'),
        decay: dec, fit: rep, fits
      });
    }

    // テーブル描画（インラインプロット列は削除）
    const tbody = $('#results tbody'); tbody.innerHTML='';
    for(const r of results){
      // 既存マーク（※）
      let markT10='', markT20='', markT30='';
      const rt10=r.fits.T10.T, rt20=r.fits.T20.T, rt30=r.fits.T30.T;
      const rtsFinite = [rt10, rt20, rt30].filter(isFinite);
      if (rtsFinite.length >= 2 && rtsFinite.every(t => t <= 1.0)) {
        const maxDiff = Math.max(...rtsFinite) - Math.min(...rtsFinite);
        if (maxDiff >= 0.3) {
          if(isFinite(rt10)) markT10 += '※';
          if(isFinite(rt20)) markT20 += '※';
          if(isFinite(rt30)) markT30 += '※';
        }
      }
      // 新規警告（!!）
      if (rtsFinite.length >= 2){
        const tmin = Math.min(...rtsFinite);
        const tmax = Math.max(...rtsFinite);
        if (tmax - tmin >= 0.1 * tmin){
          if(isFinite(rt10)) markT10 += '!!';
          if(isFinite(rt20)) markT20 += '!!';
          if(isFinite(rt30)) markT30 += '!!';
        }
      }
      if (isFinite(rt10) && rt10 >= 10) markT10 += '!!';
      if (isFinite(rt20) && rt20 >= 10) markT20 += '!!';

      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>${r.fc.toFixed(1)}</td>
        <td>${isFinite(r.EDT)?r.EDT.toFixed(3):''}</td>
        <td>${isFinite(r.T10)?r.T10.toFixed(3)+markT10:''}</td>
        <td>${isFinite(r.T20)?r.T20.toFixed(3)+markT20:''}</td>
        <td>${isFinite(r.T30)?r.T30.toFixed(3)+markT30:''}</td>
        <td>${r.R2}</td>
        <td>${r.SNR.toFixed(1)}</td>
        <td>${r.judge}</td>`;
      tbody.appendChild(tr);
    }

    // Overall
    const th = 20.0;
    const valid = results.filter(r => (r.fc!==63 || $('#snrInclude63').checked));
    const okList = valid.filter(r => r.SNR>=th);
    const overall = (okList.length >= Math.ceil(valid.length*0.6)) ? 'OK' : 'NG';
    $('#overallJudge').className = 'judge ' + (overall==='OK'?'ok':'ng');
    $('#overallJudge').textContent = overall;
    $('#overallNote').textContent = `OK数 ${okList.length}/${valid.length}`;

    // 詳細Plotly：バンド選択を構築し初期描画
    detailBandSel.innerHTML = '';
    for(const r of results){
      const opt=document.createElement('option');
      opt.value = String(r.fc); opt.textContent = `${r.fc} Hz`;
      detailBandSel.appendChild(opt);
    }
    const defaultFc = results[0]?.fc;
    if(defaultFc!=null){ detailBandSel.value=String(defaultFc); }
    const renderCurrent = ()=>{
      const fc = parseFloat(detailBandSel.value);
      const r = results.find(v=>v.fc===fc) || results[0];
      if(!r) return;
      // ズーム既定値を更新（xcut 由来 1.0 s）
      zoomStartEl.value = Number(zoomStartEl.value || 0).toFixed(2);
      zoomEndEl.value   = Number(zoomEndEl.value || (r.decay.length/fs)).toFixed(2);
      renderDecayPlot('decayPlot', r, fs, parseFloat(zoomStartEl.value), parseFloat(zoomEndEl.value));
    };
    detailBandSel.onchange = renderCurrent;
    applyZoomBtn.onclick = renderCurrent;
    renderCurrent();

    // 波形：preStart ～ preStart + xcut.length
    const markers = [
      {idx:0, color:'#999'},
      {idx:clap.idx, color:'#ef4444'},
      {idx:clap.idx, idx2:clap.idx+Math.floor(0.2*fs), color:'#16a34a', band:true},
      {idx:preStart, idx2:clap.idx, color:'#0ea5e9', band:true}
    ];
    drawWave($('#wave'), x, fs, markers, preStart, preStart + xcut.length);

    // CSV
    csvBtn.disabled=false;
    csvBtn.onclick = ()=>{
      const blob = makeCSV(results);
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob); a.download='revtime_results.csv'; a.click();
      URL.revokeObjectURL(a.href);
    };

    setState('analyzed');
  }

  // init
  initConsent();
  recBtn.onclick = startRecording;
  stopBtn.onclick = stopRecording;
  analyzeBtn.onclick = analyze;
  fileInput.onchange = async (e)=>{
    if(!userConfirmed){ initConsent(); if(!userConfirmed) return; }
    const f=e.target.files?.[0]; if(!f) return;
    lastBuffer = await decodeBlobToMonoFloat(f);
    setState(`loaded file @ ${lastBuffer.fs} Hz`);
    analyzeBtn.disabled=false;
  };
  $('#measTarget').textContent = $('#measCount').value;
})();
</script>
</body>
</html>
