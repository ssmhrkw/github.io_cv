<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hand-Clap RT (EDT/T10/T20/T30) + SNR判定 v2.2</title>

  <!-- GA: 通常スクリプトとして分離 -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HFR5WYG42Q"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date()); gtag('config','G-HFR5WYG42Q');
  </script>

  <style>
    :root{
      --bg:#f7f8fb; --card:#ffffff; --ink:#0f172a; --muted:#64748b;
      --accent:#2563eb; --ok:#16a34a; --warn:#eab308; --err:#dc2626;
      --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    }
    *{box-sizing:border-box}
    body{ margin:0; color:var(--ink); background:var(--bg);
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic","ヒラギノ角ゴ ProN W3","メイリオ",sans-serif; line-height:1.55; }
    header{ position:sticky; top:0; z-index:10; background:linear-gradient(90deg,#fff,#f5f9ff); border-bottom:1px solid #e2e8f0; }
    .wrap{ max-width:1200px; margin:0 auto; padding:16px; }
    h1{ font-size:clamp(20px,2.4vw,28px); margin:0 0 6px; }
    .sub{ color:var(--muted); font-size:14px; }
    main{ max-width:1200px; margin:18px auto; padding:0 16px 40px; }
    .grid{ display:grid; gap:16px; grid-template-columns: repeat(12, 1fr); }
    .card{ background:var(--card); border:1px solid #e5e7eb; border-radius:18px; padding:16px; box-shadow: 0 6px 24px rgba(30,41,59,0.06); }
    .card h2{ margin:0 0 10px; font-size:18px }
    .controls{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; }
    button{ appearance:none; border:0; border-radius:14px; padding:10px 14px; font-weight:600; cursor:pointer; background:var(--accent); color:white; box-shadow:0 6px 16px rgba(37,99,235,0.2); }
    button.secondary{ background:#e2e8f0; color:#0f172a; }
    button.ghost{ background:transparent; color:var(--accent); border:1px solid #c7d2fe}
    button:disabled{ opacity:.6; cursor:not-allowed }
    .danger{ background:#dc2626 !important; }
    label{ font-size:14px; color:var(--muted) }
    select, input[type="number"]{
      border:1px solid #e5e7eb; background:white; color:#0f172a; border-radius:12px; padding:8px 10px; min-width:100px;
    }
    .pill{ display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-weight:700; font-size:12px }
    .hint{ font-size:12px; color:var(--muted) }
    .ok{ color:var(--ok) } .warn{ color:var(--warn) } .err{ color:var(--err) }
    table{ width:100%; border-collapse:collapse; }
    th, td{ padding:8px 10px; border-bottom:1px solid #e5e7eb; text-align:right; font-variant-numeric:tabular-nums; }
    th:first-child, td:first-child{ text-align:left }
    .mono{ font-family:var(--mono); }
    .judge{ font-weight:800; padding:4px 10px; border-radius:999px; display:inline-block; }
    .judge.ok{ background:#ecfdf5; color:#065f46; border:1px solid #34d399; }
    .judge.ng{ background:#fef2f2; color:#991b1b; border:1px solid #fca5a5; }
    @media (max-width:920px){ .grid{ grid-template-columns: repeat(6,1fr); } }
    @media (max-width:640px){ .grid{ grid-template-columns: repeat(4,1fr); } .controls{ gap:8px } }
    canvas{ width:100%; height:260px; background:#fff; border-radius:12px; border:1px solid #e5e7eb }
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>手をたたいて残響時間を推定（コンセプト）</h1>
    <div class="sub">録音 → 1/1オクターブBPF（含む63 Hz）→ シュレーダー積分 → 直線回帰（EDT/T10/T20/T30）／ 事前暗騒音と比較したSNRでOK/NG</div>
  </div>
</header>

<main>
  <div class="grid">
    <section class="card" style="grid-column: span 12;">
      <h2>1) 測定と入力</h2>
      <div class="controls">
        <button id="btnRecord"><span id="recLabel">録音開始</span></button>
        <button id="btnStop" class="secondary" disabled>停止</button>
        <label>録音長（秒）<input type="number" id="recSec" value="5" step="1" min="3" max="20" /></label>

        <label>測定点数
          <select id="measCount">
            <option value="1" selected>1</option>
            <option value="3">3</option>
            <option value="5">5</option>
          </select>
        </label>
        <label>トリガー閾値[dBFS]
          <input type="number" id="trigDb" value="-20" step="1" min="-60" max="-1" />
        </label>

        <button id="btnAnalyze" class="ghost" disabled>解析する</button>
        <button id="btnCommit" class="ghost" disabled>この測定を保存</button>
        <button id="btnAvg" class="ghost" disabled>平均を計算</button>

        <input type="file" id="fileInput" accept="audio/*" />
        <span id="state" class="pill">idle</span>
      </div>
      <p class="hint">静かな部屋で、<b>ボタンを押して約1秒後に1回だけ強く手を叩いてください</b>。端末側のNR/AGCは無効化要求を出しますが、OS依存で完全には止まりません。</p>
      <audio id="player" controls style="width:100%; display:none;"></audio>
      <div id="envInfo" class="footer-note mono"></div>
      <div class="footer-note">デバイス処理要求: echoCancellation=false / noiseSuppression=false / autoGainControl=false（適用可否は端末次第）</div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>2) 解析・判定設定</h2>
      <div class="controls">
        <label>帯域
          <select id="bandType">
            <option value="ob_63_4k" selected>1/1 Octave（63 Hz ～ 4 kHz）</option>
            <option value="ob_31_4k">1/1 Octave（31.5 Hz ～ 4 kHz）</option>
            <option value="ob_125_4k">1/1 Octave（125 Hz ～ 4 kHz）</option>
          </select>
        </label>
        <label>BPF段数（Biquad×）
          <select id="bpOrder">
            <option value="1">1（軽量）</option>
            <option value="2" selected>2（推奨）</option>
            <option value="3">3（重い）</option>
          </select>
        </label>
        <label>回帰区間
          <select id="rtMode">
            <option value="ALL" selected>EDT/T10/T20/T30 すべて</option>
            <option value="EDT">EDTのみ</option>
            <option value="T10">T10のみ</option>
            <option value="T20">T20のみ</option>
            <option value="T30">T30のみ</option>
          </select>
        </label>
        <label>OK判定SNRしきい値[dB]
          <select id="snrTh">
            <option value="10">10</option>
            <option value="20" selected>20</option>
            <option value="30">30</option>
          </select>
        </label>
        <label><input type="checkbox" id="snrInclude63" checked/> 判定に63 Hzも含める</label>
        <label><input type="checkbox" id="noiseComp" checked/> BGノイズ補正（シュレーダー積分時に暗騒音電力を減算）</label>
        <button id="btnDownloadCsv" class="ghost" disabled>CSVを保存</button>
      </div>
      <p class="hint">SNRは<b>手拍子直後200 ms</b>の平均パワーと<b>手拍子前0.5 s</b>の平均パワーの比（10log10）。中央値SNRがしきい値以上なら<b>OK</b>。</p>
      <div>全体判定：<span id="overallJudge" class="judge ng">NG</span> <span id="overallNote" class="mono" style="margin-left:8px;"></span></div>
      <div class="footer-note">測定保存数: <span id="measSaved" class="mono">0</span> / <span id="measTarget" class="mono">1</span></div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>3) 結果（帯域別）</h2>
      <div id="resultsWrap">
        <table id="results">
          <thead>
            <tr>
              <th>中心周波数 [Hz]</th>
              <th>EDT [s]</th>
              <th>T10 [s]</th>
              <th>T20 [s]</th>
              <th>T30 [s]</th>
              <th>R²（代表回帰）</th>
              <th>SNR [dB]</th>
              <th>判定</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <div class="footer-note">代表回帰＝T30優先→T20→T10→EDT。回帰直線ラベルに<b>EDT/T10/T20/T30</b>を明示。</div>
      </div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>4) 参考プロット（代表帯域）</h2>
      <label>表示帯域 <select id="plotBand"></select></label>
      <canvas id="plot"></canvas>
      <div class="footer-note">曲線＝シュレーダー（相対dB）。灰色が回帰区間、点線が回帰直線。</div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>5) 元信号の切り取り位置</h2>
      <canvas id="wave" style="height:150px"></canvas>
      <div class="footer-note">原波形。赤＝手拍子検出点、青帯＝事前暗騒音窓、緑帯＝直後200 ms窓、灰帯＝解析用に切り出した範囲。</div>
    </section>

    <section class="card" style="grid-column: span 12;">
      <h2>注意・限界</h2>
      <ul>
        <li>スマホ内蔵マイクは低域（～100 Hz）で感度が低いことが多く、<b>63 Hz</b>はSNR不足になりがちです。</li>
        <li>getUserMediaでechoCancellation/noiseSuppression/autoGainControlを<b>false</b>指定し、可能ならトラックにもapplyConstraintsします。iOS Safari等では完全に無効化できない場合があります。</li>
        <li>厳密測定には標準化手順・信号の使用を推奨。本ツールは簡易推定・事前チェック用です。</li>
      </ul>
    </section>
  </div>
</main>

<!-- 本体ロジック：モジュール1個だけ -->
<script type="module">
import {
  designButterworthBandpassSOS_N, sosFilter
} from "./acoustics-core.js";

(() => {
  const $ = (s)=>document.querySelector(s);
  const $$ = (s)=>Array.from(document.querySelectorAll(s));
  const db10 = (x)=>10*Math.log10(Math.max(1e-24, x));
  const db20 = (x)=>20*Math.log10(Math.max(1e-12, Math.abs(x)));

  const player = $('#player');
  const stateEl = $('#state');
  const recBtn = $('#btnRecord');
  const stopBtn = $('#btnStop');
  const analyzeBtn = $('#btnAnalyze');
  const csvBtn = $('#btnDownloadCsv');
  const plotBandSel = $('#plotBand');

  let mediaStream = null;
  let recorder = null;
  let recordedChunks = [];
  let lastBuffer = null;  // {fs, data: Float32Array}

  function makeBands(kind){
    if(kind==='ob_31_4k') return [31.5,63,125,250,500,1000,2000,4000];
    if(kind==='ob_125_4k') return [125,250,500,1000,2000,4000];
    return [63,125,250,500,1000,2000,4000];
  }
  function calcQ(fc){ const f1=fc/Math.SQRT2, f2=fc*Math.SQRT2; return fc/(f2-f1); }
  function edges_from_fc(fc){ const f1=fc/Math.SQRT2, f2=fc*Math.SQRT2; return [f1,f2]; }

  async function bandpassFilter(samples, fs, fc, stages=2){
    const N = 2*Math.max(1, Math.round(stages));
    const sos = designButterworthBandpassSOS_N(fc, fs, N);
    return sosFilter(samples, sos);
  }

  function detectClapStart(samples, fs, trigDb){
    let maxAbs=0, maxIdx=0;
    for(let i=0;i<samples.length;i++){ const a=Math.abs(samples[i]); if(a>maxAbs){ maxAbs=a; maxIdx=i; } }
    const peakDb = db20(maxAbs);
    if(peakDb < trigDb) return {idx:-1, peakDb};
    const pre = Math.floor(0.01*fs);
    return {idx: Math.max(0, maxIdx-pre), peakDb};
  }

  function sliceForAnalysis(samples, fs, startIdx){
    const maxDur=3.5;
    const N = Math.min(samples.length-startIdx, Math.floor(maxDur*fs));
    const out = new Float32Array(N);
    let mean=0; for(let i=0;i<N;i++) mean += samples[startIdx+i]; mean/=N;
    for(let i=0;i<N;i++) out[i] = samples[startIdx+i]-mean;
    return out;
  }

  function schroederDB(x){
    const N=x.length; const e=new Float64Array(N);
    for(let i=0;i<N;i++){ const v=x[i]; e[i]=v*v; }
    for(let i=N-2;i>=0;i--) e[i]+=e[i+1];
    const e0=e[0] + 1e-12;
    const out=new Float32Array(N);
    for(let i=0;i<N;i++){ const r=Math.max(e[i]/e0,1e-12); out[i]=10*Math.log10(r); }
    return out;
  }

  function schroederDBNoiseComp(x, pbg){
    const N=x.length; const out=new Float32Array(N);
    let s=0;
    for(let i=N-1;i>=0;i--){
      const pi = x[i]*x[i] - pbg;
      s += Math.max(0, pi);
      out[i] = 10*Math.log10(Math.max(s/(s||1), 1e-12)); // 相対化は後でやるのでここでは形だけ
    }
    // 正規化
    const maxv = out[0];
    for(let i=0;i<N;i++) out[i] = out[i] - maxv;
    return out;
  }

  function pickSegment(dBcurve, mode){
    let hi, lo;
    if(mode==='EDT'){ hi=0; lo=-10; }
    else if(mode==='T10'){ hi=-5; lo=-15; }
    else if(mode==='T20'){ hi=-5; lo=-25; }
    else if(mode==='T30'){ hi=-5; lo=-35; }
    else { hi=0; lo=-10; }
    const N=dBcurve.length; let i0=-1, i1=-1;
    for(let i=0;i<N;i++){ if(dBcurve[i]<hi){ i0=i; break; } }
    if(i0<0) return null;
    for(let i=i0;i<N;i++){ if(dBcurve[i]<lo){ i1=i; break; } }
    if(i1<0 || i1-i0<100) return null;
    return [i0,i1];
  }

  function linreg(x, y){
    const n = x.length; if(n<2) return {a:NaN,b:NaN,r2:NaN};
    let sx=0, sy=0, sxy=0, sxx=0, syy=0;
    for(let i=0;i<n;i++){ const xi=x[i], yi=y[i]; sx+=xi; sy+=yi; sxy+=xi*yi; sxx+=xi*xi; syy+=yi*yi; }
    const denom = n*sxx - sx*sx; if(Math.abs(denom)<1e-12) return {a:NaN,b:NaN,r2:NaN};
    const a = (n*sxy - sx*sy)/denom; const b=(sy - a*sx)/n;
    const ym = sy/n; let ssT=0, ssR=0;
    for(let i=0;i<n;i++){ const yi=y[i], yh=a*x[i]+b; ssT+=(yi-ym)**2; ssR+=(yi-yh)**2; }
    const r2 = ssT>0? 1-ssR/ssT : NaN;
    return {a,b,r2};
  }

  function fitRT(dBcurve, fs, mode){
    const seg = pickSegment(dBcurve, mode);
    if(!seg) return {T:NaN,a:NaN,b:NaN,r2:NaN,seg:null, used:null};
    const [i0,i1]=seg; const n=i1-i0;
    const x=new Float64Array(n), y=new Float64Array(n);
    for(let k=0;k<n;k++){ x[k]=i0+k; y[k]=dBcurve[i0+k]; }
    const {a,b,r2}=linreg(x,y);
    if(!isFinite(a) || Math.abs(a)<1e-12) return {T:NaN,a,b,r2,seg, used:mode};
    const T60 = -60/(a*fs);
    if(T60<=0 || T60>20) return {T:NaN,a,b,r2,seg, used:mode};
    return {T:T60,a,b,r2,seg, used:mode};
  }

  function drawWave(canvas, data, fs, markers){
    const ctx=canvas.getContext('2d'); const W=canvas.width=canvas.clientWidth, H=canvas.height=canvas.clientHeight;
    ctx.clearRect(0,0,W,H); ctx.strokeStyle='#0f172a22'; ctx.strokeRect(0,0,W,H);
    if(!data) return;
    ctx.strokeStyle='#0f172a'; ctx.beginPath();
    const N=data.length; const step=Math.max(1, Math.floor(N/W));
    for(let x=0,i=0;x<W;x++,i+=step){
      const y=data[i]; const yy=H*(0.5-0.45*y);
      if(x===0) ctx.moveTo(x,yy); else ctx.lineTo(x,yy);
    }
    ctx.stroke();
    if(markers){
      for(const m of markers){
        const x = Math.floor((m.idx/N)*W);
        ctx.strokeStyle=m.color; ctx.beginPath();
        ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke();
        if(m.band){ ctx.fillStyle=m.color+'33'; const x2=Math.floor((m.idx2/N)*W); ctx.fillRect(Math.min(x,x2),0,Math.abs(x2-x),H); }
      }
    }
  }

  function drawDecay(canvas, dBcurve, fs, fit){
    const ctx=canvas.getContext('2d'); const W=canvas.width=canvas.clientWidth, H=canvas.height=canvas.clientHeight;
    ctx.clearRect(0,0,W,H); ctx.strokeStyle='#0f172a22'; ctx.strokeRect(0,0,W,H);
    if(!dBcurve) return;
    const N=dBcurve.length;
    const minY=-80, maxY=0;
    const x2px = (i)=> i/N*W;
    const y2px = (v)=> (1-(v-minY)/(maxY-minY))*H;
    ctx.strokeStyle='#0f172a'; ctx.beginPath();
    for(let i=0;i<N;i++){
      const x=x2px(i), y=y2px(dBcurve[i]);
      if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    if(fit && fit.seg){
      const [i0,i1]=fit.seg;
      ctx.fillStyle='#9ca3af55';
      ctx.fillRect(x2px(i0),0,x2px(i1)-x2px(i0),H);
      // 回帰直線
      ctx.strokeStyle='#0ea5e9'; ctx.setLineDash([6,6]); ctx.beginPath();
      const y0 = fit.a*i0 + fit.b;
      const y1 = fit.a*(i1-1) + fit.b;
      ctx.moveTo(x2px(i0), y2px(y0)); ctx.lineTo(x2px(i1), y2px(y1)); ctx.stroke(); ctx.setLineDash([]);
    }
  }

  function makeCSV(rows){
    const head=['fc_Hz','EDT_s','T10_s','T20_s','T30_s','R2','SNR_dB','Judge'];
    const lines=[head.join(',')];
    for(const r of rows){
      lines.push([r.fc.toFixed(1), ...['EDT','T10','T20','T30'].map(k=>isFinite(r[k])?r[k].toFixed(3):''), (r.R2??'').toString(), r.SNR.toFixed(1), r.judge].join(','));
    }
    return new Blob([lines.join('\n')], {type:'text/csv'});
  }

  async function decodeBlobToMonoFloat(blob){
    const ac = new AudioContext({sampleRate:48000});
    const arrbuf = await blob.arrayBuffer();
    const audioBuf = await ac.decodeAudioData(arrbuf);
    const fs = audioBuf.sampleRate;
    const ch0 = audioBuf.getChannelData(0);
    const out = new Float32Array(ch0.length);
    out.set(ch0);
    ac.close();
    return {fs, data:out};
  }

  function enableDuringRecording(v){
    recBtn.disabled=v; stopBtn.disabled=!v; analyzeBtn.disabled=true; csvBtn.disabled=true;
  }

  function setState(s){ stateEl.textContent=s; }

  async function startRecording(){
    const recSec = Math.max(1, Math.min(20, parseInt($('#recSec').value,10) || 5));
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio:{
        echoCancellation:false, noiseSuppression:false, autoGainControl:false
      }
    });
    recorder = new MediaRecorder(mediaStream);
    recordedChunks = [];
    recorder.ondataavailable = e=>{ if(e.data && e.data.size>0) recordedChunks.push(e.data); };
    recorder.onstop = async ()=>{
      const blob = new Blob(recordedChunks, {type:'audio/webm'});
      player.src = URL.createObjectURL(blob);
      player.style.display='block';
      lastBuffer = await decodeBlobToMonoFloat(blob);
      setState(`recorded @ ${lastBuffer.fs} Hz, ${lastBuffer.data.length} samples`);
      analyzeBtn.disabled = false;
    };
    recorder.start();
    enableDuringRecording(true); setState('recording…');
    setTimeout(()=>{ if(recorder && recorder.state==='recording') recorder.stop(); stopStream(); enableDuringRecording(false); }, recSec*1000);
  }

  function stopStream(){
    if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
  }

  function stopRecording(){
    if(recorder && recorder.state==='recording'){ recorder.stop(); }
    stopStream(); enableDuringRecording(false); setState('stopped');
  }

  async function analyze(){
    if(!lastBuffer){ setState('no audio'); return; }
    const fs = lastBuffer.fs, x = lastBuffer.data;
    const trigDb = parseFloat($('#trigDb').value)||-20;
    const clap = detectClapStart(x, fs, trigDb);
    if(clap.idx<0){ setState(`clap not detected (peak ${clap.peakDb.toFixed(1)} dBFS < ${trigDb} dBFS)`); return; }
    const xcut = sliceForAnalysis(x, fs, clap.idx);

    // SNR用窓
    const preN  = Math.max(1, Math.floor(0.5*fs));
    const postN = Math.max(1, Math.floor(0.2*fs));
    const preStart  = Math.max(0, clap.idx - preN);
    const postStart = clap.idx;

    // 帯域
    const bands = makeBands($('#bandType').value);
    plotBandSel.innerHTML = '';
    for(const fc of bands){ const o=document.createElement('option'); o.value=fc; o.textContent=fc+' Hz'; plotBandSel.appendChild(o); }

    // 解析
    const results=[];
    const include63 = $('#snrInclude63').checked;
    const noiseComp = $('#noiseComp').checked;
    const stages = parseInt($('#bpOrder').value,10)||2;

    for(const fc of bands){
      const y = await bandpassFilter(x, fs, fc, stages);
      // SNR
      let pbg=0, psig=0;
      for(let i=0;i<preN;i++){ const v=x[preStart+i]||0; pbg += v*v; }
      for(let i=0;i<postN;i++){ const v=x[postStart+i]||0; psig += v*v; }
      pbg/=preN; psig/=postN;
      const SNR = db10(psig/(pbg||1e-24));

      // 解析対象は切り出し→帯域通過
      const ycut = await bandpassFilter(xcut, fs, fc, stages);
      let dec;
      if(noiseComp) dec = schroederDBNoiseComp(ycut, pbg);
      else{
        dec = schroederDB(ycut);
        const shift = dec[0]; for(let i=0;i<dec.length;i++) dec[i] = dec[i]-shift; // 0dB起点化
      }

      const modeSel = $('#rtMode').value;
      const modes = modeSel==='ALL' ? ['EDT','T10','T20','T30'] : [modeSel];
      const fits = {};
      for(const m of ['EDT','T10','T20','T30']){ fits[m]=fitRT(dec, fs, m); }

      // 代表回帰
      let rep = fits.T30; let tag='T30';
      if(!isFinite(rep.T)) { rep=fits.T20; tag='T20'; }
      if(!isFinite(rep.T)) { rep=fits.T10; tag='T10'; }
      if(!isFinite(rep.T)) { rep=fits.EDT; tag='EDT'; }

      results.push({
        fc,
        EDT: fits.EDT.T, T10:fits.T10.T, T20:fits.T20.T, T30:fits.T30.T,
        R2: isFinite(rep.r2)?rep.r2.toFixed(3):'',
        repTag: tag,
        SNR,
        judge: (fc===63 && !include63)? '—' : (SNR >= parseFloat($('#snrTh').value)? 'OK':'NG'),
        decay: dec, fit: rep
      });
    }

    // 表
    const tbody = $('#results tbody'); tbody.innerHTML='';
    for(const r of results){
      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>${r.fc.toFixed(1)}</td>
        <td>${isFinite(r.EDT)?r.EDT.toFixed(3):''}</td>
        <td>${isFinite(r.T10)?r.T10.toFixed(3):''}</td>
        <td>${isFinite(r.T20)?r.T20.toFixed(3):''}</td>
        <td>${isFinite(r.T30)?r.T30.toFixed(3):''}</td>
        <td>${r.R2}</td>
        <td>${r.SNR.toFixed(1)}</td>
        <td>${r.judge}</td>`;
      tbody.appendChild(tr);
    }

    // 全体判定
    const th = parseFloat($('#snrTh').value);
    const okList = results.filter(r => (r.fc!==63 || include63) && r.SNR>=th);
    const overall = (okList.length >= Math.ceil(results.length*0.6)) ? 'OK' : 'NG';
    $('#overallJudge').className = 'judge ' + (overall==='OK'?'ok':'ng');
    $('#overallJudge').textContent = overall;
    $('#overallNote').textContent = `OK数 ${okList.length}/${results.length}`;

    // プロット選択
    plotBandSel.onchange = ()=>{
      const f = parseFloat(plotBandSel.value);
      const r = results.find(v=>v.fc===f) || results[0];
      drawDecay($('#plot'), r.decay, fs, r.fit);
    };
    plotBandSel.value = results[0]?.fc;
    plotBandSel.onchange();

    // 波形表示
    const markers = [
      {idx:0, color:'#999'}, // 先頭
      {idx:clap.idx, color:'#ef4444'},
      {idx:clap.idx, idx2:clap.idx+Math.floor(0.2*fs), color:'#16a34a', band:true},
      {idx:Math.max(0, clap.idx-Math.floor(0.5*fs)), idx2:clap.idx, color:'#0ea5e9', band:true}
    ];
    drawWave($('#wave'), x, fs, markers);

    // CSV
    csvBtn.disabled=false;
    csvBtn.onclick = ()=>{
      const blob = makeCSV(results);
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download='revtime_results.csv';
      a.click();
      URL.revokeObjectURL(a.href);
    };

    setState('analyzed');
  }

  // 録音UI
  recBtn.onclick = startRecording;
  stopBtn.onclick = stopRecording;
  analyzeBtn.onclick = analyze;

  // ファイル解析（任意）
  $('#fileInput').onchange = async (e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    lastBuffer = await decodeBlobToMonoFloat(f);
    setState(`loaded file @ ${lastBuffer.fs} Hz`);
    analyzeBtn.disabled=false;
  };

  // 初期化
  $('#measTarget').textContent = $('#measCount').value;
  setState('idle');
})();
</script>
</body>
</html>
