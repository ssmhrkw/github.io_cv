<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>wav2Fmax — Pro v3</title>
<script src="https://cdn.plot.ly/plotly-2.24.2.min.js"></script>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Kaku Gothic ProN','Noto Sans JP','Yu Gothic',sans-serif;color:#0f172a;background:#fff;margin:12px}
  .wrap{max-width:1280px;margin:0 auto}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .btn{padding:8px 12px;border:1px solid #cbd5e1;border-radius:10px;background:#fff;cursor:pointer}
  .btn.primary{background:#0ea5a4;color:#fff;border:none}
  .file-name{min-width:200px;max-width:520px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;border:1px solid #e2e8f0;padding:6px;border-radius:8px;background:#fff}
  .card{border:1px solid #e5e7eb;border-radius:12px;padding:10px;background:#fff;margin-top:10px}
  label.small{font-size:13px;color:#334155}
  input[type="number"]{width:110px;padding:6px;border-radius:10px;border:1px solid #cbd5e1}
  select{padding:6px;border-radius:10px;border:1px solid #cbd5e1}
  #log{font-size:12px;white-space:pre-wrap;border:1px dashed #cbd5e1;border-radius:10px;padding:6px;max-height:160px;overflow:auto}
  .tabs{display:flex;gap:6px;flex-wrap:wrap;margin:8px 0}
  .tab{padding:6px 12px;border:1px solid #e5e7eb;border-radius:10px;cursor:pointer}
  .tab.active{background:#0ea5a4;color:#fff;border:none}
  .hidden{display:none}
  .muted{color:#64748b;font-size:12px}
  .progress{height:14px;background:#e2e8f0;border-radius:8px;overflow:hidden}
  .bar{height:100%;width:0%;background:#0ea5a4;transition:width .2s}
  table{border-collapse:collapse;width:100%}
  th,td{border:1px solid #e5e7eb;padding:6px;font-size:12px;text-align:right}
  th{background:#f1f5f9;text-align:center}
  td.f{font-variant-numeric:tabular-nums;text-align:right}
  td.sel{background:#ecfeff}
  .band-plot{height:170px;margin-top:8px}
  #overlay{position:fixed;inset:0;background:rgba(0,0,0,0.25);backdrop-filter:saturate(0.1) blur(1px);display:none;z-index:999;align-items:center;justify-content:center;color:#fff;font-size:20px}
</style>
</head>
<body>
<div class="wrap">
  <h2>wav2Fmax — Pro v3</h2>

  <!-- Top controls -->
  <div class="row">
    <input id="file-input" type="file" accept=".wav,.wave,.csv,.txt" multiple />
    <button id="load-btn" class="btn primary">Load</button>
    <div id="file-name" class="file-name">No file selected</div>
    <span id="status" class="muted">Ready</span>
  </div>

  <!-- Channel setup under file chooser -->
  <div id="setup" class="card hidden">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <strong>Channel setup</strong><span class="muted">対象CH選択・ロール名・補正係数</span>
    </div>
    <div id="setup-body"></div>
  </div>

  <!-- Filtering and processing -->
  <div id="config" class="card hidden">
    <div class="row">
      <label class="small">Bands:
        <select id="band-type">
          <option value="oct">1/1 Octave</option>
          <option value="third">1/3 Octave</option>
        </select>
      </label>
      <label class="small">Lo(Hz): <select id="band-lo"></select></label>
      <label class="small">Hi(Hz): <select id="band-hi"></select></label>
      <label class="small">Filter:
        <select id="filter-type">
          <option value="butterN">Butterworth N (SOS)</option>
        </select>
      </label>
      <label class="small">Order N(LP原型): <input id="filter-order" type="number" min="1" step="1" value="12" /></label>
      <label class="small">Time weighting:
        <select id="time-weight">
          <option value="fast">Fast(125 ms)</option>
          <option value="slow">Slow(1 s)</option>
          <option value="leq">Leq(window s)</option>
          <option value="maxhold">MaxHold</option>
        </select>
      </label>
      <label class="small">Leq window(s): <input id="leq-win" type="number" step="0.1" value="1.0" /></label>
      <label class="small">CSV SR(Hz): <input id="csv-sr" type="number" value="25600" /></label>
      <label class="small"><input id="has-header" type="checkbox" checked /> header row</label>
      <button id="process-btn" class="btn primary" disabled style="padding:10px 16px">Process</button>
      <div class="progress" style="flex:1;min-width:220px"><div id="bar" class="bar"></div></div>
      <span id="p-label" class="muted">idle</span>
    </div>
  </div>

  <!-- Channel tabs -->
  <div id="tabs" class="tabs hidden"></div>

  <!-- Summary + plots per channel -->
  <div id="summary" class="card hidden">
    <div class="row" style="justify-content:space-between;align-items:center">
      <strong id="summary-title">Summary</strong>
      <span class="muted">クリックで行を選択→該当バンド位置へスクロール</span>
    </div>
    <div id="table-wrap"></div>
    <div id="plots-wrap"></div>
  </div>

  <div class="card">
    <div class="muted">Log</div>
    <div id="log"></div>
  </div>
</div>

<div id="overlay">計算中…</div>

<script>
/*** logging ***/
function logln(s){ const el=document.getElementById('log'); const t=new Date().toLocaleTimeString(); el.textContent += `[${t}] ${s}\n`; el.scrollTop=el.scrollHeight; }
function setStatus(s){ document.getElementById('status').textContent=s; logln(s); }
window.addEventListener('error', e=>{ setStatus('JS error: '+(e.message||e)); });
window.addEventListener('unhandledrejection', e=>{ setStatus('Promise error: '+(e.reason && e.reason.message ? e.reason.message : e.reason)); });

/*** state ***/
let g = { files:[], csv:{rows:[], headerTokens:[], headerLike:false}, srCSV:25600, audio:null, results:null, setup:[] };

/*** constants ***/
const P0 = 2e-5; // Pa

/*** CSV parse ***/
function splitCSV(line){ const out=[]; let cur=''; let inQ=false; for(let i=0;i<line.length;i++){ const ch=line[i]; if(ch=='"'){ inQ=!inQ; continue; } if(!inQ&&(ch===','||ch==='\\t')){ out.push(cur.trim()); cur=''; continue; } cur+=ch; } out.push(cur.trim()); if(out.length===1 && out[0].includes(' ')) return out[0].split(/\\s+/); return out; }
function parseCSV(text, hasHeader=true){
  text = text.replace(/^\\uFEFF/, '');
  const raw = text.split(/\\r?\\n/).filter(x=>x.trim().length>0);
  const headerTokens = hasHeader ? splitCSV(raw[0]) : [];
  const body = hasHeader ? raw.slice(1) : raw;
  const rows = body.map(line => splitCSV(line).map(t=>{ const c=t.replace(/,/g,''); const v=Number(c); return isFinite(v)?v:NaN; }));
  return {rows, headerTokens, headerLike:hasHeader};
}

/*** WAV decode ***/
function readWavHeader(buf){
  const v=new DataView(buf);
  function str(o,n){ return String.fromCharCode(...new Uint8Array(buf,o,n)); }
  if(str(0,4)!=='RIFF' || str(8,4)!=='WAVE') throw new Error('Not WAVE');
  let off=12, fmt=-1, data=-1, dl=0, ba=0, bps=0, ch=0, sr=0, af=0;
  while(off+8<=v.byteLength){
    const id=str(off,4); const len=v.getUint32(off+4,true); off+=8;
    if(id==='fmt '){ af=v.getUint16(off+0,true); ch=v.getUint16(off+2,true); sr=v.getUint32(off+4,true); ba=v.getUint16(off+12,true); bps=v.getUint16(off+14,true); }
    else if(id==='data'){ data=off; dl=len; }
    off+=len;
  }
  return {audioFormat:af, numChannels:ch, sampleRate:sr, bitsPerSample:bps, blockAlign:ba, dataOffset:data, dataLength:dl};
}
function decodePCM(buf){
  const h=readWavHeader(buf);
  const v=new DataView(buf, h.dataOffset, h.dataLength);
  const frames=Math.floor(h.dataLength/h.blockAlign);
  const out=Array.from({length:h.numChannels}, ()=>new Float32Array(frames));
  let p=0;
  for(let i=0;i<frames;i++){
    for(let c=0;c<h.numChannels;c++){
      let y=0;
      if(h.audioFormat===1){
        if(h.bitsPerSample===16){ y=v.getInt16(p,true)/32768; p+=2; }
        else if(h.bitsPerSample===24){ const b0=v.getUint8(p), b1=v.getUint8(p+1), b2=v.getUint8(p+2); let x=(b2<<16)|(b1<<8)|b0; if(x&0x800000) x|=0xFF000000; y=x/8388608; p+=3; }
        else if(h.bitsPerSample===32){ y=v.getInt32(p,true)/2147483648; p+=4; }
        else throw new Error('PCM bits '+h.bitsPerSample);
      }else if(h.audioFormat===3){
        if(h.bitsPerSample!==32) throw new Error('float bits '+h.bitsPerSample);
        y=v.getFloat32(p,true); p+=4;
      }else{ throw new Error('fmt '+h.audioFormat); }
      out[c][i]=y;
    }
  }
  return {sampleRate:h.sampleRate, numberOfChannels:h.numChannels, length:frames, duration:frames/h.sampleRate, getChannelData:(i)=>out[i]};
}

/*** DSP: Butterworth N SOS ***/
function d1_LP(fc, fs){ const K=Math.tan(Math.PI*fc/fs); const a0=1+K; return {b0:K/a0,b1:K/a0,b2:0, a1:(1-K)/a0,a2:0}; }
function d1_HP(fc, fs){ const K=Math.tan(Math.PI*fc/fs); const a0=1+K; return {b0:1/a0,b1:-1/a0,b2:0, a1:(1-K)/a0,a2:0}; }
function rbjLP(fc, fs, Q){ const w0=2*Math.atan(Math.tan(Math.PI*fc/fs)), c=Math.cos(w0), s=Math.sin(w0), alpha=s/(2*Q); const a0=1+alpha, a1=-2*c, a2=1-alpha, b0=(1-c)/2, b1=1-c, b2=(1-c)/2; return {b0:b0/a0,b1:b1/a0,b2:b2/a0, a1:a1/a0,a2:a2/a0}; }
function rbjHP(fc, fs, Q){ const w0=2*Math.atan(Math.tan(Math.PI*fc/fs)), c=Math.cos(w0), s=Math.sin(w0), alpha=s/(2*Q); const a0=1+alpha, a1=-2*c, a2=1-alpha, b0=(1+c)/2, b1=-(1+c), b2=(1+c)/2; return {b0:b0/a0,b1:b1/a0,b2:b2/a0, a1:a1/a0,a2:a2/a0}; }
function butterQ(n,k){ return 1/(2*Math.sin((2*k+1)*Math.PI/(2*n))); }
function butterLP_sos(fc, fs, order){ if(order<=0) return []; const sos=[], p=Math.floor(order/2); for(let k=0;k<p;k++) sos.push(rbjLP(fc,fs,butterQ(order,k))); if(order%2===1) sos.push(d1_LP(fc,fs)); return sos; }
function butterHP_sos(fc, fs, order){ if(order<=0) return []; const sos=[], p=Math.floor(order/2); for(let k=0;k<p;k++) sos.push(rbjHP(fc,fs,butterQ(order,k))); if(order%2===1) sos.push(d1_HP(fc,fs)); return sos; }
function sosFreqz(sections, fs, fgrid){
  const H = new Float64Array(fgrid.length);
  for(let i=0;i<fgrid.length;i++){
    const w = 2*Math.PI*fgrid[i]/fs;
    const c1 = Math.cos(-w), s1 = Math.sin(-w);
    const c2 = Math.cos(-2*w), s2 = Math.sin(-2*w);
    let Nr=1, Ni=0, Dr=1, Di=0;
    for(const s of sections){
      const nre = s.b0 + s.b1*c1 + s.b2*c2;
      const nim = s.b1*s1 + s.b2*s2;
      const dre = 1   + s.a1*c1 + s.a2*c2;
      const dim =       s.a1*s1 + s.a2*s2;
      const tNr = Nr*nre - Ni*nim, tNi = Nr*nim + Ni*nre; Nr=tNr; Ni=tNi;
      const tDr = Dr*dre - Di*dim, tDi = Dr*dim + Di*dre; Dr=tDr; Di=tDi;
    }
    const den = Dr*Dr + Di*Di;
    const Hr = (Nr*Dr + Ni*Di)/den;
    const Hi = (Ni*Dr - Nr*Di)/den;
    H[i] = Math.hypot(Hr, Hi);
  }
  return H;
}
function normalizeAt(sections, fs, fref){
  const probe = [0.97*fref, fref, 1.03*fref];
  const mags = sosFreqz(sections, fs, probe);
  const Href = mags[1] || 1;
  if(!isFinite(Href) || Href<=0) return;
  const K = Math.max(1, sections.length);
  const g = Math.pow(1/(Href), 1/K);
  for(const s of sections){ s.b0*=g; s.b1*=g; s.b2*=g; }
}
function designButterworthBandpassSOS_N(fc, fs, N){
  const f1 = fc/Math.SQRT2, f2 = fc*Math.SQRT2;
  const M = Math.max(2, 2*Math.max(1, Math.round(N)));
  const hpOrd = Math.floor(M/2), lpOrd = Math.ceil(M/2);
  const hp = butterHP_sos(f1, fs, hpOrd), lp = butterLP_sos(f2, fs, lpOrd);
  const sections = hp.concat(lp);
  normalizeAt(sections, fs, fc);
  return sections;
}
window.designButterworthBandpassSOS_N = designButterworthBandpassSOS_N;
/*** IIR DF2T + SOS ***/
function filterBiquadDF2T(x, c){
  const N=x.length, y=new Float32Array(N); let s1=0,s2=0;
  const b0=c.b0, b1=c.b1, b2=c.b2, a1=c.a1, a2=c.a2;
  for(let n=0;n<N;n++){ const w=x[n]-a1*s1-a2*s2; const yn=b0*w + b1*s1 + b2*s2; s2=s1; s1=w; y[n]=yn; }
  return y;
}
function sosFilter(inSig, sosArray){ let y=Float32Array.from(inSig); for(let i=0;i<sosArray.length;i++) y=filterBiquadDF2T(y, sosArray[i]); return y; }

/*** helpers ***/
function percentile(arr, p){ if(!arr.length) return NaN; const a=Float64Array.from(arr).sort(); const pos=(a.length-1)*p; const lo=Math.floor(pos), hi=Math.ceil(pos); const w=pos-lo; return (1-w)*a[lo]+w*a[hi]; }
function ewmaSquaredToSPL(y, sr, tau){ const out=new Float32Array(y.length); const alpha = 1 - Math.exp(-1/(sr*tau)); let s=0; for(let i=0;i<y.length;i++){ const v=y[i]; s += alpha*(v*v - s); out[i] = 10*Math.log10( Math.max(1e-24, s/(P0*P0)) ); } return out; }
function movingLeqSPL(y, sr, winSec){ const win = Math.max(1, Math.round(winSec*sr)); const out=new Float32Array(y.length); let acc=0; for(let i=0;i<y.length;i++){ const v=y[i]; const vv=v*v; acc += vv; if(i>=win){ const old=y[i-win]; acc -= old*old; } const denom = P0*P0* Math.min(win, i+1) / sr; out[i] = 10*Math.log10( Math.max(1e-24, acc/denom) ); } return out; }
function centersOct(){ const a=[]; let f=16; while(f<=8000){ a.push(f); f*=2; } return a; }
function centersThird(){ const a=[]; let f=16; const step=Math.pow(2,1/3); while(f<=8000){ a.push(Number(f.toFixed(6))); f*=step; } return a; }
function fullCenters(type){ return type==='oct' ? centersOct() : centersThird(); }
function downsampleForPlot(x,y,maxPoints){ if(y.length<=maxPoints) return {x,y}; const step=y.length/maxPoints, xn=new Array(maxPoints), yn=new Array(maxPoints); for(let i=0;i<maxPoints;i++){ const k=Math.floor(i*step); xn[i]=x[k]; yn[i]=y[k]; } return {x:xn,y:yn}; }

/*** UI wiring ***/
document.getElementById('file-input').addEventListener('change', e=>{
  const f=e.target.files && e.target.files[0]; if(!f) return;
  g.files=[...e.target.files]; document.getElementById('file-name').textContent = g.files.map(x=>x.name).join(', ');
});
document.getElementById('load-btn').addEventListener('click', onClickLoad);
document.getElementById('process-btn').addEventListener('click', onProcess);
document.getElementById('band-type').addEventListener('change', refreshBandRangeUI);

function refreshBandRangeUI(){
  const type = document.getElementById('band-type').value;
  const loSel = document.getElementById('band-lo');
  const hiSel = document.getElementById('band-hi');
  const list = fullCenters(type);
  loSel.innerHTML = list.map(f=>`<option value="${f}">${Math.round(f)}</option>`).join('');
  hiSel.innerHTML = loSel.innerHTML;
  loSel.value = list[0];
  hiSel.value = list[list.length-1];
}

function onClickLoad(){
  if(!g.files || g.files.length===0){ alert('ファイルを選択してください'); return; }
  const f=g.files[0];
  const ext=f.name.toLowerCase().split('.').pop();
  setStatus('Loading '+f.name+' ...');
  const fr=new FileReader();
  if(ext==='csv' || ext==='txt'){
    fr.onload = ()=>{
      try{
        const txt=fr.result;
        const hasHeader=document.getElementById('has-header').checked;
        g.csv=parseCSV(txt, hasHeader);
        // SR推定: 先頭列が時刻と仮定（秒）
        if(g.csv.rows.length>4){
          const t = g.csv.rows.map(r=>r[0]).filter(v=>isFinite(v));
          if(t.length>4){
            const dt=[]; for(let i=1;i<t.length;i++){ const d=t[i]-t[i-1]; if(isFinite(d) && d>0) dt.push(d); }
            if(dt.length){ const sorted=Float64Array.from(dt).sort(); const med = sorted[Math.floor(sorted.length/2)] || 0; if(med>0){ g.srCSV = 1/med; document.getElementById('csv-sr').value = Math.round(g.srCSV); } }
          }
        }
        document.getElementById('config').classList.remove('hidden');
        document.getElementById('process-btn').disabled=false;
        ensureSetup(1);
        buildTabs(1);
        refreshBandRangeUI();
        setStatus('CSV loaded: '+g.csv.rows.length+' rows, SR≈'+Math.round(document.getElementById('csv-sr').value)+' Hz');
      }catch(err){ setStatus('CSV load error: '+err.message); }
    };
    fr.readAsText(f);
  }else{
    fr.onload = ()=>{
      try{
        const buf=fr.result;
        g.audio = decodePCM(buf);
        document.getElementById('csv-sr').value = g.audio.sampleRate; // WAV → CSV SR 自動反映
        document.getElementById('config').classList.remove('hidden');
        document.getElementById('process-btn').disabled=false;
        ensureSetup(g.audio.numberOfChannels);
        buildTabs(g.audio.numberOfChannels);
        refreshBandRangeUI();
        setStatus(`WAV loaded: ${g.audio.numberOfChannels} ch, ${g.audio.sampleRate} Hz, ${g.audio.length} frames`);
      }catch(err){ setStatus('WAV load error: '+err.message); }
    };
    fr.readAsArrayBuffer(f);
  }
}

/*** Channel setup UI ***/
function ensureSetup(nch){
  const root = document.getElementById('setup');
  const body = document.getElementById('setup-body');
  root.classList.remove('hidden');
  if(g.setup.length<nch){ for(let i=g.setup.length;i<nch;i++) g.setup.push({use:i===0?true:false, role:'Microphone', gain:1.0}); }
  let html = '<table><thead><tr><th style="text-align:left">Use</th><th>CH</th><th>Role</th><th>Correction ×</th></tr></thead><tbody>';
  for(let i=0;i<nch;i++){
    const st=g.setup[i]||{use:false, role:'Microphone', gain:1.0};
    html += '<tr>'
      + `<td style="text-align:center"><input type="checkbox" data-k="${i}" class="ck-use" ${st.use?'checked':''}></td>`
      + `<td style="text-align:center">CH${i+1}</td>`
      + `<td style="text-align:center"><select data-k="${i}" class="sel-role">`
      + ['Force hammer','Accelerometer','Microphone'].map(r=>`<option value="${r}" ${st.role===r?'selected':''}>${r}</option>`).join('')
      + `</select></td>`
      + `<td><input type="number" step="any" value="${st.gain}" data-k="${i}" class="num-gain" style="width:120px"></td>`
      + '</tr>';
  }
  html += '</tbody></table>';
  body.innerHTML = html;
  body.querySelectorAll('.ck-use').forEach(el=> el.addEventListener('change', ev=>{ const k=+ev.target.dataset.k; g.setup[k].use = ev.target.checked; buildTabs(g.audio?g.audio.numberOfChannels:1); }));
  body.querySelectorAll('.sel-role').forEach(el=> el.addEventListener('change', ev=>{ const k=+ev.target.dataset.k; g.setup[k].role = ev.target.value; buildTabs(g.audio?g.audio.numberOfChannels:1); }));
  body.querySelectorAll('.num-gain').forEach(el=> el.addEventListener('input', ev=>{ const k=+ev.target.dataset.k; const v=parseFloat(ev.target.value); g.setup[k].gain = isFinite(v)?v:1.0; }));
}

/*** CH tabs ***/
function buildTabs(nch){
  const tabs=document.getElementById('tabs'); tabs.innerHTML=''; tabs.classList.remove('hidden');
  for(let ch=0; ch<nch; ch++){
    if(g.setup[ch] && g.setup[ch].use){ // omit unchecked channels
      const d=document.createElement('div'); d.className='tab'+(tabs.children.length===0?' active':'');
      const nm = g.setup[ch].role || 'CH'+(ch+1);
      d.textContent = `CH${ch+1} (${nm})`;
      d.dataset.ch=ch;
      d.addEventListener('click', ()=>{ document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active')); d.classList.add('active'); renderChannel(ch); });
      tabs.appendChild(d);
    }
  }
  document.getElementById('summary').classList.remove('hidden');
  const first = tabs.querySelector('.tab'); if(first){ renderChannel(+first.dataset.ch); } else { document.getElementById('summary-title').textContent='No channel selected'; document.getElementById('table-wrap').innerHTML=''; document.getElementById('plots-wrap').innerHTML=''; }
}

/*** processing ***/
function updateProgress(pct,msg){ document.getElementById('bar').style.width = Math.max(0,Math.min(100,pct))+'%'; document.getElementById('p-label').textContent = msg||''; }

async function onProcess(){
  try{
    // overlay and clear summary during processing
    document.getElementById('overlay').style.display = 'flex';
    document.getElementById('table-wrap').innerHTML = '';
    document.getElementById('plots-wrap').innerHTML = '';
    updateProgress(0,'processing');

    const N = Math.max(1, Math.round(Number(document.getElementById('filter-order').value)||12));
    const bandType = document.getElementById('band-type').value;
    const centersAll = bandType==='oct' ? centersOct() : centersThird();
    const lo = Number(document.getElementById('band-lo').value)||16;
    const hi = Number(document.getElementById('band-hi').value)||8000;
    const centers = centersAll.filter(f=> f>=lo && f<=hi);

    let sr=0, nch=0, getData=null;
    if(g.audio){ sr=g.audio.sampleRate; nch=g.audio.numberOfChannels; getData=i=>g.audio.getChannelData(i); }
    else if(g.csv.rows.length){ sr=Number(document.getElementById('csv-sr').value)||g.srCSV||25600; nch=1; const y=Float32Array.from(g.csv.rows.map(r=> Number(r[1])||0)); getData=i=>y; }
    else{ throw new Error('no data'); }

    const timeMode = document.getElementById('time-weight').value;
    const leqWin = Math.max(1e-3, Number(document.getElementById('leq-win').value)||1);
    const usedIdx = []; for(let ch=0; ch<nch; ch++){ if(g.setup[ch] && g.setup[ch].use) usedIdx.push(ch); }
    const total = usedIdx.length * centers.length; let done=0;

    const results = []; // per ch
    for(const ch of usedIdx){
      const cfg = g.setup[ch];
      let x = getData(ch);
      if(cfg.gain && cfg.gain!==1){ const xx=new Float32Array(x.length); for(let i=0;i<x.length;i++) xx[i]=x[i]*cfg.gain; x=xx; }
      const byBand = {}; // fc -> metrics
      for(let i=0;i<centers.length;i++){
        const fc=centers[i];
        if(fc/Math.SQRT2 >= sr/2){ byBand[fc]=null; done++; updateProgress(100*done/total, `skip ${fc}Hz`); continue; }
        const sos = window.designButterworthBandpassSOS_N(fc, sr, N);
        const y  = sosFilter(x, sos);
        // SPL metrics
        const T = y.length/sr;
        const mean_p2 = (()=>{ let s=0; for(let k=0;k<y.length;k++) s+=y[k]*y[k]; return s/Math.max(1,y.length); })();
        const Leq = 10*Math.log10(Math.max(1e-24, mean_p2/(P0*P0)));
        const LE  = Leq + 10*Math.log10(Math.max(1e-24, T)); // 1s基準
        const sFast = ewmaSquaredToSPL(y, sr, 0.125);
        const sSlow = ewmaSquaredToSPL(y, sr, 1.0);
        let series = timeMode==='fast' ? sFast : timeMode==='slow' ? sSlow : timeMode==='leq' ? movingLeqSPL(y, sr, leqWin)
                     : (()=>{ const sps=sFast; let mx=-1e9; const out=new Float32Array(sps.length); for(let k=0;k<sps.length;k++){ mx=Math.max(mx,sps[k]); out[k]=mx; } return out; })();
        const Lfmax = (()=>{ let m=-1e9; for(let k=0;k<sFast.length;k++) if(sFast[k]>m) m=sFast[k]; return m; })();
        const Lsmax = (()=>{ let m=-1e9; for(let k=0;k<sSlow.length;k++) if(sSlow[k]>m) m=sSlow[k]; return m; })();
        const L05 = percentile(series, 0.95);
        const L10 = percentile(series, 0.90);
        const L50 = percentile(series, 0.50);
        const L90 = percentile(series, 0.10);
        const L95 = percentile(series, 0.05);
        byBand[fc] = {y, Leq, Lfmax, Lsmax, LE, L05, L10, L50, L90, L95, sr};
        done++; updateProgress(100*done/total, `CH${ch+1} ${Math.round(fc)}Hz`);
      }
      results.push({channelIndex:ch, role:cfg.role, byBand, centers, sr});
    }
    g.results = {results, centers, sr};
    setStatus('Processed');
    // Render current active tab
    const active = document.querySelector('#tabs .tab.active');
    if(active){ renderChannel(+active.dataset.ch); }
  }catch(err){ setStatus('Process error: '+err.message); }
  finally{ updateProgress(100,'done'); document.getElementById('overlay').style.display = 'none'; }
}

/*** render per channel ***/
function renderChannel(ch){
  if(!g.results){ document.getElementById('summary-title').textContent='Summary'; return; }
  const rec = g.results.results.find(r=>r.channelIndex===ch);
  if(!rec){ document.getElementById('summary-title').textContent=`CH${ch+1} (omitted)`; document.getElementById('table-wrap').innerHTML=''; document.getElementById('plots-wrap').innerHTML=''; return; }
  document.getElementById('summary-title').textContent = `Channel ${ch+1} (${rec.role}) — ${document.getElementById('band-type').value==='oct'?'1/1':'1/3'} octave`;
  // Build table (order: Lfmax, Lsmax, Leq, LE, percentiles)
  const centers = rec.centers;
  let html = '<table><thead><tr><th>f(Hz)</th><th>Lfmax(dB)</th><th>Lsmax(dB)</th><th>Leq(dB)</th><th>LE(dB)</th><th>L05</th><th>L10</th><th>L50</th><th>L90</th><th>L95</th></tr></thead><tbody>';
  for(const f of centers){
    const m = rec.byBand[f];
    if(!m) continue;
    html += `<tr data-f="${f}"><td class="f">${Math.round(f)}</td><td>${m.Lfmax.toFixed(1)}</td><td>${m.Lsmax.toFixed(1)}</td><td>${m.Leq.toFixed(1)}</td><td>${m.LE.toFixed(1)}</td><td>${m.L05.toFixed(1)}</td><td>${m.L10.toFixed(1)}</td><td>${m.L50.toFixed(1)}</td><td>${m.L90.toFixed(1)}</td><td>${m.L95.toFixed(1)}</td></tr>`;
  }
  html += '</tbody></table>';
  const wrap = document.getElementById('table-wrap');
  wrap.innerHTML = html;
  wrap.querySelectorAll('tbody tr').forEach(tr=>{
    tr.addEventListener('click', ()=>{
      wrap.querySelectorAll('tbody tr').forEach(t=>t.classList.remove('sel'));
      tr.classList.add('sel');
      const f = Number(tr.dataset.f);
      const target = document.getElementById(`band-${Math.round(f)}`);
      if(target){ target.scrollIntoView({behavior:'smooth', block:'center'}); }
    });
  });

  // Build vertical plots for all bands + star at Fast max-hold time
  const host = document.getElementById('plots-wrap');
  host.innerHTML = '';
  for(const f of centers){
    const m = rec.byBand[f]; if(!m) continue;
    const div = document.createElement('div'); div.className='band-plot'; div.id=`band-${Math.round(f)}`; host.appendChild(div);
    const y=m.y; const sr=m.sr; const x = new Array(y.length); for(let i=0;i<y.length;i++) x[i]=i/sr;
    const env = (()=>{ const tau=0.125; const N=y.length; const out=new Float32Array(N); const alpha=1 - Math.exp(-1/(sr*tau)); let s=0; for(let i=0;i<N;i++){ s += alpha*(y[i]*y[i]-s); out[i]=Math.sqrt(Math.max(0,s)); } return out; })();
    // Fast dB series and its max index
    const sFast = ewmaSquaredToSPL(y, sr, 0.125);
    let kmax = 0; for(let k=1;k<sFast.length;k++){ if(sFast[k]>sFast[kmax]) kmax=k; }
    const tmax = kmax/sr; const ystar = env[kmax];
    const ds1 = downsampleForPlot(x,y,2000); const ds2 = downsampleForPlot(x,env,2000);
    Plotly.react(div,[
      {x:ds1.x, y:ds1.y, name:'BP', type:'scatter', mode:'lines'},
      {x:ds2.x, y:ds2.y, name:'Env(Fast)', type:'scatter', mode:'lines'},
      {x:[tmax], y:[ystar], name:'Fast max-hold', mode:'markers', marker:{symbol:'star', size:12, line:{width:1}}}
    ], {title:`${Math.round(f)} Hz`, legend:{orientation:'h'}, margin:{l:40,r:10,t:30,b:30}});
  }
}
</script>
</body>
</html>
