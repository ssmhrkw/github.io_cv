<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>加振点・受音点 ランダム配置ツール（3D室＋2Dスラブ）</title>
  <!-- Plotly CDN（オンラインで動作） -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root{
      --bg:#0f1115; --panel:#161a22; --card:#1b2030; --ink:#e8eefc; --muted:#9aa7bd; --accent:#7aa2ff; --accent2:#ffd36e; --ok:#6ee7a6; --bad:#ff7a99; --line:#2a3142;
    }
    *{box-sizing:border-box}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; color:var(--ink); background:linear-gradient(180deg,#0d0f14,#0f1115 20%,#0f1115);
    }
    header{
      padding:16px 20px; border-bottom:1px solid var(--line); background:rgba(22,26,34,.8); backdrop-filter: blur(6px);
    }
    header h1{font-size:18px; margin:0 0 6px}
    header p{margin:0; color:var(--muted); font-size:13px}
    main{
      display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:16px;
    }
    @media (max-width: 980px){ main{grid-template-columns: 1fr} }
    .panel{
      background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:14px;
    }
    .panel h2{
      margin:0 0 10px; font-size:15px; color:#d8e3ff; letter-spacing:.02em
    }
    .grid{
      display:grid; grid-template-columns: 1fr 1fr; gap:10px;
    }
    .grid-3{grid-template-columns: repeat(3, 1fr); gap:10px}
    .row{display:flex; gap:10px; align-items:center}
    label{font-size:12px; color:var(--muted)}
    input[type="number"], input[type="text"], select, textarea{
      width:100%; background:var(--card); color:var(--ink); border:1px solid var(--line); border-radius:8px; padding:8px 10px; font-size:13px;
    }
    textarea{min-height:100px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
    .btn{
      appearance:none; border:1px solid var(--line); background:linear-gradient(180deg,#20283a,#1b2030); color:var(--ink);
      padding:10px 12px; border-radius:8px; font-size:13px; cursor:pointer;
    }
    .btn:hover{border-color:#3a4561}
    .btn-accent{background:linear-gradient(180deg,#6e8cff,#7aa2ff); color:#0b1020; font-weight:700; border:none}
    .btn-good{background:linear-gradient(180deg,#62dfa0,#6ee7a6); color:#092014; border:none}
    .btn-bad{background:linear-gradient(180deg,#ff86a1,#ff7a99); color:#24090e; border:none}
    .muted{color:var(--muted); font-size:12px}
    .plots{
      display:grid; grid-template-columns: 1fr 1fr; gap:16px;
    }
    @media (max-width: 1200px){ .plots{grid-template-columns:1fr} }
    .plot-card{background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:8px}
    .footer-note{color:var(--muted); font-size:12px; padding:8px 16px}
    .badge{
      display:inline-block; padding:2px 8px; border-radius:999px; font-size:11px; background:#26304a; color:#cfe0ff; border:1px solid #314064; margin-right:6px
    }
    .hl{color:#cfe0ff}
    .warn{color:var(--bad)}
    .ok{color:var(--ok)}
    .section{margin-top:12px; padding-top:12px; border-top:1px dashed var(--line)}
    .right{justify-content:flex-end}
    .nowrap{white-space:nowrap}
  </style>
</head>
<body>
<header>
  <h1>加振点（2Dスラブ）・受音点（3D室）ランダム配置ツール</h1>
  <p>距離制約を満たす点群をシード付きで生成し、Plotlyで可視化。プリセット保存／自由記入／JSON入出力に対応。</p>
</header>

<main>
  <!-- コントロールパネル -->
  <section class="panel" aria-label="controls">
    <h2>入力・制約</h2>

    <div class="section">
      <div class="grid">
        <div>
          <label>プリセット</label>
          <div class="row">
            <select id="presetSelect"></select>
            <button class="btn" id="loadPreset">読込</button>
          </div>
          <div class="row" style="margin-top:6px">
            <input id="presetName" type="text" placeholder="新規プリセット名（例: Lab-S-2.6m）">
            <button class="btn" id="savePreset">保存</button>
          </div>
        </div>
        <div>
          <label>乱数シード（再現性）</label>
          <input id="seedInput" type="text" value="seed-1234" />
          <div class="muted">同じシード×同じ設定 → 同じ配置になります。</div>
        </div>
      </div>
    </div>

    <div class="section">
      <span class="badge">室寸法 [m]</span>
      <div class="grid-3" style="margin-top:8px">
        <div><label>Lx（X）</label><input id="roomLx" type="number" min="0.1" step="0.1" value="5.5"></div>
        <div><label>Ly（Y）</label><input id="roomLy" type="number" min="0.1" step="0.1" value="4.0"></div>
        <div><label>Lz（高さ）</label><input id="roomLz" type="number" min="0.1" step="0.1" value="2.6"></div>
      </div>

      <div class="row" style="margin-top:10px">
        <span class="badge">スラブ寸法 [m]</span>
        <label class="muted">（室床と同寸想定。必要なら変更）</label>
      </div>
      <div class="grid-3" style="margin-top:8px">
        <div><label>Sx（X）</label><input id="slabLx" type="number" min="0.1" step="0.1" value="5.5"></div>
        <div><label>Sy（Y）</label><input id="slabLy" type="number" min="0.1" step="0.1" value="4.0"></div>
        <div><label>スラブZ</label><input id="slabZ" type="number" step="0.01" value="0.00"></div>
      </div>
    </div>

    <div class="section">
      <span class="badge">点の数</span>
      <div class="grid-3" style="margin-top:8px">
        <div><label>受音点（マイク）個数</label><input id="nMic" type="number" min="1" step="1" value="4"></div>
        <div><label>加振点（スラブ）個数</label><input id="nSrc" type="number" min="1" step="1" value="3"></div>
        <div><label>最大試行回数 / 点</label><input id="maxTries" type="number" min="10" step="10" value="5000"></div>
      </div>
    </div>

    <div class="section">
      <span class="badge">受音点（3D）制約 [m]</span>
      <div class="grid-3" style="margin-top:8px">
        <div><label>マイク同士の最小距離</label><input id="micPairMin" type="number" min="0" step="0.05" value="0.5"></div>
        <div><label>壁からの最小距離</label><input id="micWallMin" type="number" min="0" step="0.05" value="0.5"></div>
        <div><label>床からの最小距離</label><input id="micFloorMin" type="number" min="0" step="0.05" value="0.5"></div>
      </div>
      <div class="grid-3" style="margin-top:8px">
        <div><label>天井からの最小距離</label><input id="micCeilMin" type="number" min="0" step="0.05" value="0.5"></div>
        <div><label>（任意）マイク高さ固定Z</label><input id="micFixedZ" type="number" step="0.01" placeholder="空欄=固定しない"></div>
        <div><label>（任意）床上表示Z（3Dの見やすさ）</label><input id="srcLiftZ" type="number" step="0.01" value="0.05"></div>
      </div>
    </div>

    <div class="section">
      <span class="badge">加振点（2D）制約 [m]</span>
      <div class="grid-3" style="margin-top:8px">
        <div><label>点同士の最小距離</label><input id="srcPairMin" type="number" min="0" step="0.05" value="0.5"></div>
        <div><label>縁からの最小距離</label><input id="srcEdgeMin" type="number" min="0" step="0.05" value="0.5"></div>
        <div><label>（任意）正方格子ピッチ</label><input id="srcGridPitch" type="number" min="0" step="0.05" placeholder="空欄=ランダム"></div>
      </div>
      <div class="muted" style="margin-top:6px">格子ピッチを入れると「格子上からランダム」抽出になります（位置の規則性を担保したい場合用）。</div>
    </div>

    <div class="section">
      <div class="row">
        <button class="btn-accent btn" id="generate">ランダム生成</button>
        <button class="btn" id="useManual">自由記入をプロット</button>
        <button class="btn-good btn" id="exportJson">JSON出力</button>
        <label class="btn">
          JSON読込 <input id="importJson" type="file" accept="application/json" style="display:none">
        </label>
      </div>
      <div id="status" class="muted" style="margin-top:8px">準備OK。</div>
    </div>

    <div class="section">
      <h2>自由記入（手動座標）</h2>
      <div class="grid">
        <div>
          <label>受音点（x,y,z）m, 1行1点</label>
          <textarea id="manualMics" placeholder="例）\n1.2, 0.8, 1.2\n3.1, 2.5, 1.2"></textarea>
        </div>
        <div>
          <label>加振点（x,y）m, 1行1点</label>
          <textarea id="manualSrcs" placeholder="例）\n0.9, 0.9\n2.8, 1.5"></textarea>
        </div>
      </div>
      <div class="muted" style="margin-top:6px">空白・カンマ区切りどちらでもOK。単位はメートル。</div>
    </div>
  </section>

  <!-- 可視化 -->
  <section>
    <div class="plots">
      <div class="plot-card">
        <div id="roomPlot" style="width:100%;height:520px"></div>
      </div>
      <div class="plot-card">
        <div id="slabPlot" style="width:100%;height:520px"></div>
      </div>
    </div>
    <div class="footer-note">
      <span class="badge">注意</span>
      このツールは幾何学的な点配置の支援用です。音場の物理評価（例：定在波・モード密度・受音点バイアス）や規格の詳細条件は別途検討してください。
    </div>
  </section>
</main>

<script>
/* ========= 乱数（シード付き）: xmur3 + mulberry32 =========
   再現性確保のための軽量PRNG。シード文字列→32bit→[0,1)連続乱数。 */
function xmur3(str){
  let h = 1779033703 ^ str.length;
  for (let i = 0; i < str.length; i++){
    h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  return function(){
    h = Math.imul(h ^ (h >>> 16), 2246822507);
    h = Math.imul(h ^ (h >>> 13), 3266489909);
    return (h ^= h >>> 16) >>> 0;
  }
}
function mulberry32(a){
  return function(){
    let t = a += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
}
function rngFromSeed(seedStr){
  const seedFn = xmur3(seedStr);
  return mulberry32(seedFn());
}
function randRange(rng, min, max){ return min + (max - min) * rng(); }

/* ========= 小ユーティリティ ========= */
function parseNumber(id){ return Number(document.getElementById(id).value); }
function parseMaybeNumber(id){
  const v = document.getElementById(id).value.trim();
  return v === "" ? null : Number(v);
}
function setStatus(msg, ok=true){
  const el = document.getElementById('status');
  el.textContent = msg;
  el.className = ok ? 'muted ok' : 'muted warn';
}
function fmt(n){ return Number(n.toFixed(3)); }

/* ========= 制約チェック ========= */
function within(v, min, max){ return v >= min && v <= max; }
function dist3(a,b){
  const dx=a.x-b.x, dy=a.y-b.y, dz=a.z-b.z;
  return Math.hypot(dx,dy,dz);
}
function dist2(a,b){
  const dx=a.x-b.x, dy=a.y-b.y;
  return Math.hypot(dx,dy);
}

/* ========= サンプリング（受音点 3D） =========
   - 壁から micWallMin、床から micFloorMin、天井から micCeilMin を確保
   - マイク同士は micPairMin 以上
   - micFixedZ が与えられたら高さを固定
*/
function sampleMicPoints(cfg, rng){
  const {Lx,Ly,Lz} = cfg.room;
  const {nMic, micPairMin, micWallMin, micFloorMin, micCeilMin, micFixedZ, maxTries} = cfg.constraints;

  const xsMin = micWallMin, xsMax = Lx - micWallMin;
  const ysMin = micWallMin, ysMax = Ly - micWallMin;
  const zMin = (micFixedZ!==null) ? micFixedZ : micFloorMin;
  const zMax = (micFixedZ!==null) ? micFixedZ : (Lz - micCeilMin);

  if (xsMax <= xsMin || ysMax <= ysMin || zMax < zMin){
    throw new Error("受音点の可用領域がありません（距離制約が厳しすぎます）。");
  }

  const points = [];
  for (let i=0;i<nMic;i++){
    let ok=false, tries=0;
    while(!ok && tries < maxTries){
      tries++;
      const px = randRange(rng, xsMin, xsMax);
      const py = randRange(rng, ysMin, ysMax);
      const pz = (micFixedZ!==null) ? micFixedZ : randRange(rng, zMin, zMax);
      const cand = {x:px,y:py,z:pz};
      ok = points.every(p => dist3(p, cand) >= micPairMin);
      if (ok) points.push(cand);
    }
    if (!ok) throw new Error(`受音点${i+1}の配置に失敗：制約が厳しすぎるか、最大試行回数不足。`);
  }
  return points;
}

/* ========= サンプリング（加振点 2D） =========
   - 縁から srcEdgeMin、点同士は srcPairMin
   - srcGridPitch が指定されれば格子上から抽出（離散化）
*/
function sampleSrcPoints(cfg, rng){
  const {Sx,Sy, Sz} = cfg.slab;
  const {nSrc, srcPairMin, srcEdgeMin, srcGridPitch, maxTries} = cfg.constraints;

  const xsMin = srcEdgeMin, xsMax = Sx - srcEdgeMin;
  const ysMin = srcEdgeMin, ysMax = Sy - srcEdgeMin;
  if (xsMax <= xsMin || ysMax <= ysMin){
    throw new Error("加振点の可用領域がありません（縁からの離隔が広すぎます）。");
  }

  const points = [];
  const useGrid = (srcGridPitch !== null && srcGridPitch > 0);
  let gridXs=[], gridYs=[];
  if (useGrid){
    for (let x = xsMin; x <= xsMax + 1e-9; x += srcGridPitch) gridXs.push(x);
    for (let y = ysMin; y <= ysMax + 1e-9; y += srcGridPitch) gridYs.push(y);
    if (gridXs.length * gridYs.length < nSrc){
      throw new Error("格子点の候補が不足しています（ピッチを粗くするか点数を減らしてください）。");
    }
  }

  function pickCandidate(){
    if (!useGrid){
      return {x: randRange(rng, xsMin, xsMax), y: randRange(rng, ysMin, ysMax), z: Sz};
    }else{
      // ランダムに格子セルを引く（重複回避は下の衝突チェックに任せる）
      const gx = gridXs[Math.floor(rng()*gridXs.length)];
      const gy = gridYs[Math.floor(rng()*gridYs.length)];
      return {x: gx, y: gy, z: Sz};
    }
  }

  for (let i=0;i<nSrc;i++){
    let ok=false, tries=0;
    while(!ok && tries < maxTries){
      tries++;
      const cand = pickCandidate();
      ok = points.every(p => dist2(p, cand) >= srcPairMin);
      if (ok) points.push(cand);
    }
    if (!ok) throw new Error(`加振点${i+1}の配置に失敗：制約が厳しすぎるか、最大試行回数不足。`);
  }
  return points;
}

/* ========= Plotly 描画 ========= */
function makeRoomBoxTraces(Lx,Ly,Lz){
  // ワイヤーフレームを1本のScatter3dで NaN 仕切りしながら描く
  const corners = [
    [0,0,0],[Lx,0,0],[Lx,Ly,0],[0,Ly,0],[0,0,0], // 底面
    [0,0,Lz],[Lx,0,Lz],[Lx,Ly,Lz],[0,Ly,Lz],[0,0,Lz], // 上面
  ];
  // 側面縦エッジ
  const edges = [
    [0,0,0],[0,0,Lz], [Lx,0,0],[Lx,0,Lz], [Lx,Ly,0],[Lx,Ly,Lz], [0,Ly,0],[0,Ly,Lz]
  ];
  function toArrXYZ(list){ return {
    x: list.map(p=>p[0]), y: list.map(p=>p[1]), z: list.map(p=>p[2])
  };}

  // 1) bottom+top（折線）
  const a = toArrXYZ([...corners.slice(0,5), [NaN,NaN,NaN], ...corners.slice(5)]);
  const t1 = {
    type:'scatter3d', mode:'lines', x:a.x, y:a.y, z:a.z,
    line:{width:2}, hoverinfo:'skip', name:'room'
  };
  // 2) vertical edges（NaN で仕切る）
  const e = toArrXYZ([edges[0],edges[1],[NaN,NaN,NaN],
                      edges[2],edges[3],[NaN,NaN,NaN],
                      edges[4],edges[5],[NaN,NaN,NaN],
                      edges[6],edges[7]]);
  const t2 = {
    type:'scatter3d', mode:'lines', x:e.x, y:e.y, z:e.z,
    line:{width:2}, hoverinfo:'skip', name:''
  };
  return [t1,t2];
}

function plotAll(state){
  const { room, slab, pointsMic, pointsSrc, srcLiftZ } = state;

  // --- 3D 室 ---
  const boxTraces = makeRoomBoxTraces(room.Lx, room.Ly, room.Lz);
  const micTrace = {
    type:'scatter3d', mode:'markers+text',
    x: pointsMic.map(p=>p.x), y: pointsMic.map(p=>p.y), z: pointsMic.map(p=>p.z),
    marker:{size:5}, text: pointsMic.map((_,i)=>`Mic ${i+1}`), textposition:'top center', name:'受音点'
  };
  const src3DTrace = {
    type:'scatter3d', mode:'markers+text',
    x: pointsSrc.map(p=>p.x), y: pointsSrc.map(p=>p.y), z: pointsSrc.map(p=>srcLiftZ), // 低く浮かせて表示
    marker:{size:4, symbol:'x'}, text: pointsSrc.map((_,i)=>`Src ${i+1}`),
    textposition:'bottom center', name:'加振点(床投影)'
  };
  const roomLayout = {
    scene:{
      xaxis:{title:'X [m]',range:[0,room.Lx],backgroundcolor:'#0f1115',gridcolor:'#283046'},
      yaxis:{title:'Y [m]',range:[0,room.Ly],backgroundcolor:'#0f1115',gridcolor:'#283046'},
      zaxis:{title:'Z [m]',range:[0,room.Lz],backgroundcolor:'#0f1115',gridcolor:'#283046'},
      aspectmode:'cube'
    },
    margin:{l:0,r:0,t:20,b:0},
    paper_bgcolor:'#161a22', plot_bgcolor:'#161a22',
    showlegend:true
  };
  Plotly.newPlot('roomPlot', [...boxTraces, micTrace, src3DTrace], roomLayout, {responsive:true, displaylogo:false});

  // --- 2D スラブ ---
  const slabRect = {
    type:'scatter', mode:'lines',
    x: [0, slab.Sx, slab.Sx, 0, 0], y: [0, 0, slab.Sy, slab.Sy, 0],
    hoverinfo:'skip', name:'Slab', line:{width:2}
  };
  const src2D = {
    type:'scatter', mode:'markers+text',
    x: pointsSrc.map(p=>p.x), y: pointsSrc.map(p=>p.y),
    marker:{size:8}, text: pointsSrc.map((_,i)=>`S${i+1}`), textposition:'top center',
    name:'加振点'
  };
  const micProj2D = {
    type:'scatter', mode:'markers',
    x: pointsMic.map(p=>p.x), y: pointsMic.map(p=>p.y),
    marker:{size:6, symbol:'circle-open'}, name:'受音点の床投影'
  };
  const slabLayout = {
    xaxis:{title:'X [m]',range:[0,slab.Sx],scaleanchor:'y', scaleratio:1, gridcolor:'#283046'},
    yaxis:{title:'Y [m]',range:[0,slab.Sy],gridcolor:'#283046'},
    margin:{l:50,r:20,t:20,b:40},
    paper_bgcolor:'#161a22', plot_bgcolor:'#161a22',
    showlegend:true
  };
  Plotly.newPlot('slabPlot', [slabRect, src2D, micProj2D], slabLayout, {responsive:true, displaylogo:false});
}

/* ========= 入出力（テキスト ↔ 配列） ========= */
function parsePoints3D(text){
  const arr=[];
  const lines = text.split(/\n/).map(s=>s.trim()).filter(Boolean);
  for(const line of lines){
    const m = line.replace(/[，\s]+/g, ',').split(',').map(s=>s.trim()).filter(Boolean);
    if (m.length !== 3) throw new Error(`受音点の書式エラー: "${line}"`);
    const [x,y,z] = m.map(Number);
    if ([x,y,z].some(v=>Number.isNaN(v))) throw new Error(`受音点の数値エラー: "${line}"`);
    arr.push({x,y,z});
  }
  return arr;
}
function parsePoints2D(text, slabZ){
  const arr=[];
  const lines = text.split(/\n/).map(s=>s.trim()).filter(Boolean);
  for(const line of lines){
    const m = line.replace(/[，\s]+/g, ',').split(',').map(s=>s.trim()).filter(Boolean);
    if (m.length !== 2) throw new Error(`加振点の書式エラー: "${line}"`);
    const [x,y] = m.map(Number);
    if ([x,y].some(v=>Number.isNaN(v))) throw new Error(`加振点の数値エラー: "${line}"`);
    arr.push({x,y,z:slabZ});
  }
  return arr;
}
function stringify3D(points){
  return points.map(p=>`${fmt(p.x)}, ${fmt(p.y)}, ${fmt(p.z)}`).join('\n');
}
function stringify2D(points){
  return points.map(p=>`${fmt(p.x)}, ${fmt(p.y)}`).join('\n');
}

/* ========= プリセット（LocalStorage） ========= */
const PRESET_KEY = "room-slab-presets-v1";
function loadPresets(){
  let data = localStorage.getItem(PRESET_KEY);
  if (!data){
    // 初期サンプル（規格名は謳わず単なる寸法例）
    const sample = {
      "Lab-S-2.6m": {room:{Lx:5.5,Ly:4.0,Lz:2.6}, slab:{Sx:5.5,Sy:4.0,Sz:0.00},
        constraints:{micPairMin:0.5,micWallMin:0.5,micFloorMin:0.5,micCeilMin:0.5,srcPairMin:0.5,srcEdgeMin:0.5,srcGridPitch:null}},
      "Lab-M-3.0m": {room:{Lx:7.0,Ly:5.0,Lz:3.0}, slab:{Sx:7.0,Sy:5.0,Sz:0.00},
        constraints:{micPairMin:0.6,micWallMin:0.6,micFloorMin:0.6,micCeilMin:0.6,srcPairMin:0.6,srcEdgeMin:0.6,srcGridPitch:null}},
      "Square-5x5-2.8m": {room:{Lx:5.0,Ly:5.0,Lz:2.8}, slab:{Sx:5.0,Sy:5.0,Sz:0.00},
        constraints:{micPairMin:0.5,micWallMin:0.4,micFloorMin:0.4,micCeilMin:0.4,srcPairMin:0.5,srcEdgeMin:0.4,srcGridPitch:1.0}}
    };
    localStorage.setItem(PRESET_KEY, JSON.stringify(sample));
    data = JSON.stringify(sample);
  }
  return JSON.parse(data);
}
function savePresets(obj){ localStorage.setItem(PRESET_KEY, JSON.stringify(obj)); }
function refreshPresetSelect(){
  const presets = loadPresets();
  const sel = document.getElementById('presetSelect');
  sel.innerHTML = "";
  Object.keys(presets).forEach(name=>{
    const opt = document.createElement('option');
    opt.value=name; opt.textContent=name;
    sel.appendChild(opt);
  });
}

/* ========= 現在のフォーム値 → 設定オブジェクト ========= */
function readConfig(){
  const room = { Lx:parseNumber('roomLx'), Ly:parseNumber('roomLy'), Lz:parseNumber('roomLz') };
  const slab = { Sx:parseNumber('slabLx'), Sy:parseNumber('slabLy'), Sz:parseNumber('slabZ') };
  const constraints = {
    nMic:parseNumber('nMic'),
    nSrc:parseNumber('nSrc'),
    maxTries:parseNumber('maxTries'),
    micPairMin:parseNumber('micPairMin'),
    micWallMin:parseNumber('micWallMin'),
    micFloorMin:parseNumber('micFloorMin'),
    micCeilMin:parseNumber('micCeilMin'),
    micFixedZ:parseMaybeNumber('micFixedZ'),
    srcPairMin:parseNumber('srcPairMin'),
    srcEdgeMin:parseNumber('srcEdgeMin'),
    srcGridPitch:parseMaybeNumber('srcGridPitch')
  };
  const seedStr = document.getElementById('seedInput').value || "seed";
  const srcLiftZ = parseNumber('srcLiftZ');
  return {room, slab, constraints, seedStr, srcLiftZ};
}

/* ========= メイン動作 ========= */
function generateAndPlot(){
  try{
    const cfg = readConfig();
    const rng = rngFromSeed(cfg.seedStr);
    const micPoints = sampleMicPoints({room:cfg.room, constraints:cfg.constraints}, rng);
    const srcPoints = sampleSrcPoints({slab:cfg.slab, constraints:cfg.constraints}, rng);

    // テキスト欄に反映
    document.getElementById('manualMics').value = stringify3D(micPoints);
    document.getElementById('manualSrcs').value = stringify2D(srcPoints);

    plotAll({room:cfg.room, slab:cfg.slab, pointsMic:micPoints, pointsSrc:srcPoints, srcLiftZ:cfg.srcLiftZ});
    setStatus(`生成完了：受音点 ${micPoints.length} 点、加振点 ${srcPoints.length} 点。`, true);
  }catch(err){
    console.error(err);
    setStatus(`エラー：${err.message}`, false);
  }
}

function plotManual(){
  try{
    const cfg = readConfig();
    const mic = parsePoints3D(document.getElementById('manualMics').value);
    const src = parsePoints2D(document.getElementById('manualSrcs').value, cfg.slab.Sz);
    plotAll({room:cfg.room, slab:cfg.slab, pointsMic:mic, pointsSrc:src, srcLiftZ:cfg.srcLiftZ});
    setStatus(`自由記入を描画：受音点 ${mic.length} 点、加振点 ${src.length} 点。`, true);
  }catch(err){
    console.error(err);
    setStatus(`エラー（自由記入）：${err.message}`, false);
  }
}

/* ========= JSON I/O ========= */
function exportJson(){
  const cfg = readConfig();
  const data = {
    meta: {tool:"random-room-slab-points", version:1},
    config: cfg,
    manual: {
      mics: document.getElementById('manualMics').value,
      srcs: document.getElementById('manualSrcs').value
    },
    timestamp: new Date().toISOString()
  };
  const blob = new Blob([JSON.stringify(data,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'room_slab_points.json';
  document.body.appendChild(a); a.click();
  a.remove(); URL.revokeObjectURL(url);
  setStatus("JSONをダウンロードしました。", true);
}
function importJson(file){
  const reader = new FileReader();
  reader.onload = (e)=>{
    try{
      const data = JSON.parse(e.target.result);
      const cfg = data.config;
      // 値を反映
      document.getElementById('roomLx').value = cfg.room.Lx;
      document.getElementById('roomLy').value = cfg.room.Ly;
      document.getElementById('roomLz').value = cfg.room.Lz;
      document.getElementById('slabLx').value = cfg.slab.Sx;
      document.getElementById('slabLy').value = cfg.slab.Sy;
      document.getElementById('slabZ').value = cfg.slab.Sz;
      document.getElementById('nMic').value = cfg.constraints.nMic;
      document.getElementById('nSrc').value = cfg.constraints.nSrc;
      document.getElementById('maxTries').value = cfg.constraints.maxTries;
      document.getElementById('micPairMin').value = cfg.constraints.micPairMin;
      document.getElementById('micWallMin').value = cfg.constraints.micWallMin;
      document.getElementById('micFloorMin').value = cfg.constraints.micFloorMin;
      document.getElementById('micCeilMin').value = cfg.constraints.micCeilMin;
      document.getElementById('micFixedZ').value = cfg.constraints.micFixedZ ?? "";
      document.getElementById('srcPairMin').value = cfg.constraints.srcPairMin;
      document.getElementById('srcEdgeMin').value = cfg.constraints.srcEdgeMin;
      document.getElementById('srcGridPitch').value = cfg.constraints.srcGridPitch ?? "";
      document.getElementById('seedInput').value = cfg.seedStr ?? "seed";
      document.getElementById('srcLiftZ').value = cfg.srcLiftZ ?? 0.05;
      document.getElementById('manualMics').value = data.manual?.mics ?? "";
      document.getElementById('manualSrcs').value = data.manual?.srcs ?? "";
      setStatus("JSONを読込完了。", true);
    }catch(err){
      console.error(err);
      setStatus("JSONの読込に失敗しました。", false);
    }
  };
  reader.readAsText(file);
}

/* ========= イベント・初期化 ========= */
document.getElementById('generate').addEventListener('click', generateAndPlot);
document.getElementById('useManual').addEventListener('click', plotManual);
document.getElementById('exportJson').addEventListener('click', exportJson);
document.getElementById('importJson').addEventListener('change', (e)=>{ const f=e.target.files[0]; if(f) importJson(f); });

document.getElementById('loadPreset').addEventListener('click', ()=>{
  const name = document.getElementById('presetSelect').value;
  const presets = loadPresets();
  if (!presets[name]) return;
  const p = presets[name];
  // 室・スラブ
  document.getElementById('roomLx').value = p.room.Lx;
  document.getElementById('roomLy').value = p.room.Ly;
  document.getElementById('roomLz').value = p.room.Lz;
  document.getElementById('slabLx').value = p.slab.Sx;
  document.getElementById('slabLy').value = p.slab.Sy;
  document.getElementById('slabZ').value = p.slab.Sz;
  // 制約（存在すれば上書き）
  const c = p.constraints;
  if (c){
    document.getElementById('micPairMin').value = c.micPairMin;
    document.getElementById('micWallMin').value = c.micWallMin;
    document.getElementById('micFloorMin').value = c.micFloorMin;
    document.getElementById('micCeilMin').value = c.micCeilMin;
    document.getElementById('srcPairMin').value = c.srcPairMin;
    document.getElementById('srcEdgeMin').value = c.srcEdgeMin;
    document.getElementById('srcGridPitch').value = c.srcGridPitch ?? "";
  }
  setStatus(`プリセット「${name}」を読み込みました。`, true);
});

document.getElementById('savePreset').addEventListener('click', ()=>{
  const name = document.getElementById('presetName').value.trim();
  if (!name){ setStatus("プリセット名を入力してください。", false); return; }
  const presets = loadPresets();
  const cfg = readConfig();
  presets[name] = {
    room:{Lx:cfg.room.Lx, Ly:cfg.room.Ly, Lz:cfg.room.Lz},
    slab:{Sx:cfg.slab.Sx, Sy:cfg.slab.Sy, Sz:cfg.slab.Sz},
    constraints:{
      micPairMin:cfg.constraints.micPairMin,
      micWallMin:cfg.constraints.micWallMin,
      micFloorMin:cfg.constraints.micFloorMin,
      micCeilMin:cfg.constraints.micCeilMin,
      srcPairMin:cfg.constraints.srcPairMin,
      srcEdgeMin:cfg.constraints.srcEdgeMin,
      srcGridPitch:cfg.constraints.srcGridPitch
    }
  };
  savePresets(presets);
  refreshPresetSelect();
  document.getElementById('presetName').value = "";
  setStatus(`プリセット「${name}」を保存しました。`, true);
});

// 初期描画
refreshPresetSelect();
generateAndPlot();
</script>
</body>
</html>